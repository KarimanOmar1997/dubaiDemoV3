/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../core/lang.js";import{L as t}from"./Logger.js";import{a as i,d as r}from"./maybe.js";import{isAbortError as s,onAbort as a,throwIfAborted as n,isAborted as o,createAbortError as l,debounce as h}from"../core/promiseUtils.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{f as c,r as u}from"./asyncUtils.js";import{m as g}from"./handleUtils.js";import{whenOnce as p}from"../core/reactiveUtils.js";import f from"../geometry/Extent.js";import{w,o as y,k as x,c as _,b as R,h as v,q as b}from"./aaBoundingRect.js";import{D as S}from"./GridLocalOriginFactory.js";import{S as E}from"./SubView3D.js";import{h as j}from"./aaBoundingBox.js";import{n as M,G as A,T as I}from"./Matrix4PassUniform.js";import{A as D}from"./orientedBoundingBox.js";import{n as V}from"./GeometryUtil.js";import{V as L}from"./VertexAttribute.js";import{d as T}from"./debugFlags2.js";import{D as G,O,R as P}from"./RenderGeometry.js";import{U as C}from"./RibbonLineMaterial.js";import{I as U}from"./ImageMaterial.js";import{T as H}from"./enums.js";import{L as N}from"./LayerView3D.js";import z from"../views/layers/LayerView.js";import{R as F}from"./RefreshableLayerView.js";import{c as B}from"./layerViewUtils.js";import{a as q}from"./projectionUtils2.js";function W(e,t){return V(e,[[t[0],t[1],-1],[t[2],t[1],-1],[t[2],t[3],-1],[t[0],t[3],-1]])}const k=[0,0,1];let Y=class extends E{constructor(e){super(e),this.drapeSourceType=S.RasterImage,this.updatePolicy=C.SYNC,this.type="draped",this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this._drapeSourceRenderer=null}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.addHandles(g((()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))))}setDrapingExtent(e,t){this._spatialReference=t,e.forEach(((e,t)=>{this._overlays[t]=e,this._updateImageExtent(e,t)}))}destroy(){this.clear()}get spatialReference(){return this._spatialReference}_updateImageExtent(e,i){const r=this._clippedExtent(e.extent,Z);if(null==r)return;const a=function(e,t,i){const r=w(e)/y(e),s={width:i,height:i};return r>1.0001?s.height=i/r:r<.9999&&(s.width=i*r),s.width=Math.round(s.width/(w(e)/w(t))),s.height=Math.round(s.height/(y(e)/y(t))),s}(e.extent,r,e.resolution);let n=e.pixelRatio*this.view.state.pixelRatio;const{layer:o}=this;if("imageMaxWidth"in o&&null!=o.imageMaxWidth||"imageMaxHeight"in o&&null!=o.imageMaxHeight){const e=o.imageMaxWidth,t=o.imageMaxHeight;if(a.width>e){const t=e/a.width;a.height=Math.floor(a.height*t),a.width=e,n*=t}if(a.height>t){const e=t/a.height;a.width=Math.floor(a.width*e),a.height=t,n*=e}}const l=this._extents[i];l&&R(l.extent,r)&&this._imageSizeEquals(r,l.imageSize,a)||(this._extents[i]={extent:_(r),imageSize:a,pixelRatio:n},this.suspended||this._fetch(i).catch((e=>{s(e)||t.getLogger(this).error(e)})))}clear(){for(let e=0;e<this._images.length;e++)this._clearImage(e)}async doRefresh(e){const t=[];for(let i=0;i<this._extents.length;i++)this._extents[i]&&t.push(this._fetch(i,e));await Promise.allSettled(t)}async processResult(e,t,i){(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement)&&(e.image=t)}findExtentInfoAt(e){for(const t of this._extents){const i=t.extent;if(new f(i[0],i[1],i[2],i[3],this._spatialReference).contains(e))return t}return null}async redraw(e,t){await c(this._images,(async(i,r)=>{i&&(await e(i,t),await this._createStageObjects(r,i.image,t))}))}_imageSizeEquals(e,t,i){if(!this.maximumDataResolution)return!1;const r=w(e)/this.maximumDataResolution.x,s=y(e)/this.maximumDataResolution.y,a=r/t.width,n=s/t.height,o=r/i.width,l=s/i.height,h=Math.abs(a-o),d=Math.abs(n-l),m=T.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return h<=m&&d<=m}async _fetch(e,r){if(this.suspended)return;const h=this._extents[e],d=h.extent;this._images[e]||(this._images[e]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:_(d)});const m=this._images[e];m.loadingAbortController=i(m.loadingAbortController);const c=new f(d[0],d[1],d[2],d[3],this._spatialReference);if(0===c.width||0===c.height)return void this._clearImage(e);const u=new AbortController;m.loadingAbortController=u,a(r,(()=>u.abort()));const g=u.signal,p=this._waitFetchReady(g).then((async()=>{n(g);const t={requestAsImageElement:!0,pixelRatio:this._overlays[e].pixelRatio,...this.layerView.getFetchOptions(),signal:g},{height:i,width:r}=h.imageSize;return this.layer?"imagery"===this.layer.type?this.layer.internalFetchImage(c,r,i,t):this.layer.fetchImage(c,r,i,t):null})).then((e=>{if(o(g))throw t.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),l();return this.processResult(m,e)})).then((()=>{v(m.renderExtent,d)}));m.loadingPromise=p,await this.updatingHandles.addPromise(p.then((async()=>{n(g),await this._createStageObjects(e,m.image,g)})).catch((e=>{throw e&&!s(e)&&t.getLogger(this).error(e),e})).finally((()=>{p===m.loadingPromise&&(m.loadingPromise=null,m.loadingAbortController=null)})))}_clearImage(e){const t=this._images[e];if(t){null!=t.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([t.renderGeometry],G.UPDATE),t.renderGeometry=null);const e=this.view.stage,r=t.texture;r?.unload(),e.removeTexture(r),t.texture=null,t.material=null,t.loadingAbortController=i(t.loadingAbortController),t.loadingPromise=null,t.image=null,t.pixelData=null}}async _createStageObjects(e,t,i){const r=this.view.stage,s=this._images[e],a=()=>{s.texture?.unload(),r.removeTexture(s.texture),s.texture=null,s.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([s.renderGeometry],G.UPDATE),s.renderGeometry=null)};if(t){const o=new I(t,{width:t.width,height:t.height,preMultiplyAlpha:!0,wrap:{s:H.CLAMP_TO_EDGE,t:H.CLAMP_TO_EDGE}});if(await u(this._images[e===O.INNER?O.OUTER:O.INNER].loadingPromise),n(i),a(),await r.schedule((()=>o.load(r.renderView.renderingContext)),i),!o.loaded)return void a();let l;if(r.addTexture(o),s.texture=o,s.material??=new U({draped:!0,texture:o}),s.material.setParameters({texture:o}),e===O.INNER)l=W(s.material,s.renderExtent);else{const e=this._images[0].renderExtent;if(!e)return void a();l=function(e,t,i){if(!x(t,i))return W(e,i);const r=[t[1]-i[1],Math.min(t[3],i[3])-Math.max(t[1],i[1]),i[3]-t[3],123456],s=[t[0]-i[0],Math.min(t[2],i[2])-Math.max(t[0],i[0]),i[2]-t[2],123456],a=i[2]-i[0],n=i[3]-i[1],o=s[0]>0&&s[2]>0?3:2,l=r[0]>0&&r[2]>0?3:2,h=(l+1)*(o+1),d=j(3*h),m=M(2*h),c=new Array(6*(l*o-1));let u=0,g=0,p=0,f=0,w=0;for(let e=0;e<4;e++){const t=r[e];if(t<=0)continue;let l=0;for(let t=0;t<4;t++){const r=s[t];r<=0||(d[g++]=i[0]+l,d[g++]=i[1]+u,d[g++]=-1,m[p++]=l/a,m[p++]=u/n,t<3&&e<3&&(1!==t||1!==e)&&(c[w++]=f,c[w++]=f+1,c[w++]=f+o+1,c[w++]=f+1,c[w++]=f+o+2,c[w++]=f+o+1),f++,l+=r)}u+=t}const y=new Array(c.length);return new A(e,[[L.POSITION,new D(d,c,3,!0)],[L.NORMAL,new D(k,y,3,!0)],[L.UV0,new D(m,c,2,!0)]])}(s.material,e,s.renderExtent)}s.renderGeometry=new P(l),s.renderGeometry.localOrigin=this._overlays[e].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([s.renderGeometry],G.UPDATE)}else a(),s.material=null}_clippedExtent(e,t){if("local"!==this.view.viewingMode)return v(t,e);const i=this.view.basemapTerrain;return i.ready?b(e,i.extent,t):v(t,e)}async _waitFetchReady(e){await p((()=>this.view.stationary),e),n(e)}};e([d()],Y.prototype,"type",void 0),Y=e([m("esri.views.3d.layers.DrapedSubView3D")],Y);const Z=_();let J=class extends(F(N(z))){constructor(){super(...arguments),this.fullExtentInLocalViewSpatialReference=null,this.refreshDebounced=h((async e=>{this.destroyed||await this._doRefresh(e).catch((e=>{s(e)||t.getLogger(this).error(e)}))}),2e3)}get visibleAtCurrentScale(){const e=this.layer,t="effectiveScaleRange"in e?e.effectiveScaleRange:null;return B(t,this.view.scale)}isUpdating(){return super.isUpdating()||this.subView?.updating}initialize(){this._initSubView(),"local"===this.view.viewingMode&&this.addResolvingPromise((async()=>this.fullExtentInLocalViewSpatialReference=await q(this.layer.fullExtent,this.view.spatialReference))()),this._updatingHandles.add((()=>this.suspended),(()=>this._suspendedChangeHandler()))}destroy(){this.subView=r(this.subView)}_initSubView(){this.subView=new Y({layerView:this})}async doRefresh(){return this._doRefresh()}async _doRefresh(e){this.suspended||await this.subView.doRefresh(e)}getFetchOptions(){}_suspendedChangeHandler(){this.suspended?this.subView.clear():this.refreshDebounced()}get test(){}};e([d()],J.prototype,"layer",void 0),e([d()],J.prototype,"suspended",void 0),e([d()],J.prototype,"fullExtentInLocalViewSpatialReference",void 0),e([d({readOnly:!0})],J.prototype,"visibleAtCurrentScale",null),e([d()],J.prototype,"updating",void 0),e([d()],J.prototype,"subView",void 0),J=e([m("esri.views.3d.layers.DynamicLayerView3D")],J);export{J as D,Y as a};
