/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{L as s}from"./Logger.js";import{P as t}from"./PooledArray.js";import{c as e}from"./vec3f64.js";import{W as o}from"./WorkerHandle.js";import{canProjectWithoutEngine as r}from"./projectionUtils.js";import{p as i}from"./projectVectorToVector.js";var n,h;!function(s){s[s.None=0]="None",s[s.Int16=1]="Int16",s[s.Int32=2]="Int32"}(n||(n={})),function(s){s[s.Replace=0]="Replace",s[s.Outside=1]="Outside",s[s.Inside=2]="Inside",s[s.Finished=3]="Finished"}(h||(h={}));class a{constructor(s,t,e,o,r,i){this.layout=s,this.interleavedVertexData=t,this.indices=e,this.hasColors=o,this.hasModifications=r,this.positionData=i}}class p{constructor(s,t,e,o,r,i,n){this.componentOffsets=s,this.featureIds=t,this.anchorIds=e,this.anchors=o,this.transformedGeometry=r,this.globalTrafo=i,this.obb=n}}class u extends o{constructor(s){super("SceneLayerWorker","process",{process:s=>[s.geometryBuffer],project:s=>[s.positions.buffer],transformNormals:s=>[s.normals.buffer]},s,{hasInitialize:!0})}setModifications(s,t,e,o){const r={context:s,modifications:l(t,e,o),isGeodetic:o.isGeographic};this.broadcast(r,"setModifications")}setLegacySchema(s,t){const e=JSON.stringify(t);return this.broadcast({context:s,jsonSchema:e},"setLegacySchema")}destroyContext(s){return this.broadcast(s,"destroyContext")}project(s,t){return this.invokeMethod("project",s,t)}transformNormals(s,t){return this.invokeMethod("transformNormals",s,t)}}const c=new t({deallocator:null}),f=e();function l(t,e,o){c.clear();let n=1/0,a=1/0,p=-1/0,u=-1/0,l=!1;for(const t of e){const e="clip"===t.type?h.Inside:"mask"===t.type?h.Outside:h.Replace,d=t.geometry;let m=s=>s;if(d.spatialReference){if(!r(d.spatialReference,o)){s.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle").warn("Can't project modification polygon into layer spatial reference, ignoring modification");continue}m=s=>(i(s,d.spatialReference,f,o),f)}else d.hasZ||(f[2]=0,m=s=>(f[0]=s[0],f[1]=s[1],f));l=l||e===h.Outside,c.push(e),c.push(d.rings.length);for(const s of d.rings){c.push(s.length);for(const t of s){const s=m(t);c.push(s[0]),c.push(s[1]),c.push(s[2]),n=Math.min(n,s[0]),a=Math.min(a,s[1]),p=Math.max(p,s[0]),u=Math.max(u,s[1])}}}if(null!=t)if(l){const s=1e-4;c.push(h.Inside),c.push(2),c.push(4),c.push(n-s),c.push(a-s),c.push(0),c.push(p+s),c.push(a-s),c.push(0),c.push(p+s),c.push(u+s),c.push(0),c.push(n-s),c.push(u+s),c.push(0),c.push(4),c.push(t[0]),c.push(t[1]),c.push(0),c.push(t[2]),c.push(t[1]),c.push(0),c.push(t[2]),c.push(t[3]),c.push(0),c.push(t[0]),c.push(t[3]),c.push(0)}else c.push(h.Outside),c.push(1),c.push(4),c.push(t[0]),c.push(t[1]),c.push(0),c.push(t[2]),c.push(t[1]),c.push(0),c.push(t[2]),c.push(t[3]),c.push(0),c.push(t[0]),c.push(t[3]),c.push(0);c.push(h.Finished);const d=new Float64Array(c.length);for(let s=0;s<c.length;++s)d[s]=c.at(s);return d}export{n as I,a as T,p as a,u as b,l as t};
