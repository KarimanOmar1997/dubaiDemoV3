/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Evented.js";import"../core/lang.js";import"./Logger.js";import{createResolver as i}from"../core/promiseUtils.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{E as s}from"./interfaces2.js";import r from"../core/Collection.js";var n;!function(t){t[t.WhenToolEditable=0]="WhenToolEditable",t[t.WhenToolNotEditable=1]="WhenToolNotEditable",t[t.Always=2]="Always"}(n||(n={}));class l{constructor(){this._isToolEditable=!0,this._manipulators=new r,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(t){this._isToolEditable=t}get length(){return this._manipulators.length}add(t,e=n.WhenToolEditable){this.addMany([t],e)}addMany(t,e=n.WhenToolEditable){for(const i of t){const t={manipulator:i,visibilityPredicate:e,attached:!1};this._manipulators.add(t),this._attached&&this._updateManipulatorAttachment(t)}}remove(t){for(let e=0;e<this._manipulators.length;e++)if(this._manipulators.at(e).manipulator===t){const t=this._manipulators.splice(e,1)[0];this._detachManipulator(t);break}}removeAll(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._manipulators.removeAll()}attach(){this._manipulators.forEach((t=>{this._updateManipulatorAttachment(t)})),this._attached=!0}detach(){this._manipulators.forEach((t=>{this._detachManipulator(t)})),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach((({manipulator:t})=>t.destroy())),this._manipulators.destroy(),this._resourceContexts=null}on(t,e){return this._manipulators.on(t,(t=>{e(t)}))}forEach(t){for(const e of this._manipulators.items)t(e)}some(t){return this._manipulators.items.some(t)}toArray(){const t=[];return this.forEach((e=>t.push(e.manipulator))),t}intersect(t,e){let i=null,a=Number.MAX_VALUE;return this._manipulators.forEach((({manipulator:o,attached:s})=>{if(!s||!o.interactive)return;const r=o.intersectionDistance(t,e);null!=r&&r<a&&(a=r,i=o)})),i}_updateManipulatorAttachment(t){this._isManipulatorItemVisible(t)?this._attachManipulator(t):this._detachManipulator(t)}_attachManipulator(t){t.attached||(t.manipulator.attach&&t.manipulator.attach(this._resourceContexts),t.attached=!0)}_detachManipulator(t){if(!t.attached)return;const e=t.manipulator;e.grabbing=!1,e.dragging=!1,e.hovering=!1,e.selected=!1,e.detach&&e.detach(this._resourceContexts),t.attached=!1}_isManipulatorItemVisible(t){return t.visibilityPredicate===n.Always||(this._isToolEditable?t.visibilityPredicate===n.WhenToolEditable:t.visibilityPredicate===n.WhenToolNotEditable)}}let h=class extends e.EventedAccessor{constructor(t){super(t),this.manipulators=new l,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[s.MANAGER,!0],[s.USER,!0]]),this._creationFinishedResolver=i()}get active(){return null!=this.view&&this.view.activeTool===this}set visible(t){this._get("visible")!==t&&(this._set("visible",t),this._syncVisible())}get editable(){return this.getEditableFlag(s.USER)}set editable(t){this.setEditableFlag(s.USER,t)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){null!=this.view&&(this.view.focus(),this.onActivate())}deactivate(){this.onDeactivate()}cancel(){this.emit("cancel")}handleInputEvent(t){this.onInputEvent(t)}handleInputEventAfter(t){this.onInputEventAfter(t)}setEditableFlag(t,e){this._editableFlags.set(t,e),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),t===s.USER&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(t){return this._editableFlags.get(t)??!1}endDrag(){const t=this.view.inputManager.latestPointerLocation;if(!t)return;let e=!1;this.manipulators.forEach((({manipulator:i})=>{i.dragging&&(e=!0,i.events.emit("drag",{action:"end",start:t,screenPoint:t}))})),e&&(this.view.toolViewManager.activeTool=null)}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(t){}onInputEventAfter(t){}get internallyEditable(){return this.getEditableFlag(s.USER)&&this.getEditableFlag(s.MANAGER)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized)if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};t([a({constructOnly:!0})],h.prototype,"view",void 0),t([a({readOnly:!0})],h.prototype,"active",null),t([a({value:!0})],h.prototype,"visible",null),t([a({value:!0})],h.prototype,"editable",null),t([a({readOnly:!0})],h.prototype,"manipulators",void 0),t([a({readOnly:!0})],h.prototype,"updating",null),t([a()],h.prototype,"cursor",null),t([a({readOnly:!0})],h.prototype,"automaticManipulatorSelection",void 0),t([a()],h.prototype,"hasFocusedManipulators",null),t([a()],h.prototype,"hasGrabbedManipulators",void 0),t([a()],h.prototype,"hasHoveredManipulators",void 0),t([a()],h.prototype,"firstGrabbedManipulator",void 0),t([a({readOnly:!0})],h.prototype,"created",void 0),t([a({readOnly:!0})],h.prototype,"removeIncompleteOnCancel",void 0),h=t([o("esri.views.interactive.InteractiveToolBase")],h);export{h as I,l as M};
