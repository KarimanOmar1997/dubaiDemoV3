/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{B as e,a as t,h as s,b as i,c as r,d as n,e as a,f as h,g as d,i as u,j as f,k as l,l as p,m as o,n as c,o as _,p as F,q as y,r as m,s as v,t as w,u as b,v as g,w as E,x as M,y as A,z as T,A as B,C,D as L,E as x,F as z,G as U,H as j,I as $,J as k,K as I,L as P,M as V,N as q,O as D,P as G}from"./BufferView.js";import{e as H}from"./types.js";class J{constructor(e,t){this.layout=e,this.buffer="number"==typeof t?new ArrayBuffer(t*e.stride):t;for(const t of e.fields.keys()){const s=e.fields.get(t);this[t]=new s.constructor(this.buffer,s.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(e,t){const s=this[e];return s&&s.elementCount===t.ElementCount&&s.elementType===t.ElementType?s:null}slice(e,t){return new J(this.layout,this.buffer.slice(e*this.stride,t*this.stride))}copyFrom(e,t=0,s=0,i=e.count){const r=this.stride;if(r%4==0){const n=new Uint32Array(e.buffer,t*r,i*r/4);new Uint32Array(this.buffer,s*r,i*r/4).set(n)}else{const n=new Uint8Array(e.buffer,t*r,i*r);new Uint8Array(this.buffer,s*r,i*r).set(n)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class K{constructor(e){this._stride=0,this._fields=new Map,e&&(this._stride=e.stride,e.fields.forEach((e=>{return this._fields.set(e[0],{...e[1],constructor:(t=e[1].constructor,S.get(t))});var t})))}freeze(){return this}vec2f16(i,r){return this._appendField(i,s?e:t,r),this}vec2f(e,s){return this._appendField(e,t,s),this}vec2f64(e,t){return this._appendField(e,i,t),this}vec3f16(e,t){return this._appendField(e,s?r:n,t),this}vec3f(e,t){return this._appendField(e,n,t),this}vec3f64(e,t){return this._appendField(e,a,t),this}vec4f16(e,t){return this._appendField(e,s?h:d,t),this}vec4f(e,t){return this._appendField(e,d,t),this}vec4f64(e,t){return this._appendField(e,u,t),this}mat3f(e,t){return this._appendField(e,f,t),this}mat3f64(e,t){return this._appendField(e,l,t),this}mat4f(e,t){return this._appendField(e,p,t),this}mat4f64(e,t){return this._appendField(e,o,t),this}vec4u8(e,t){return this._appendField(e,c,t),this}f16(e,t){return this._appendField(e,s?_:F,t),this}f32(e,t){return this._appendField(e,F,t),this}f64(e,t){return this._appendField(e,y,t),this}u8(e,t){return this._appendField(e,m,t),this}u16(e,t){return this._appendField(e,v,t),this}i8(e,t){return this._appendField(e,w,t),this}vec2i8(e,t){return this._appendField(e,b,t),this}vec2i16(e,t){return this._appendField(e,g,t),this}vec2u8(e,t){return this._appendField(e,E,t),this}vec2u16(e,t){return this._appendField(e,M,t),this}vec4u16(e,t){return this._appendField(e,A,t),this}u32(e,t){return this._appendField(e,T,t),this}_appendField(e,t,s){this._fields.has(e)&&B(!1,`${e} already added to vertex buffer layout`);const i=t.ElementCount*H(t.ElementType),r=this._stride;this._fields.set(e,{constructor:t,size:i,offset:r,optional:s}),this._alignFields()}_alignFields(){let e=0,t=1;this._fields.forEach((s=>{const i=H(s.constructor.ElementType);e=Math.floor((e+i-1)/i)*i,s.offset=e,e+=s.size,t=Math.max(t,i)})),e=Math.floor((e+t-1)/t)*t,this._stride=e}createBuffer(e){return new J(this,e)}createView(e){return new J(this,e)}clone(){const e=new K;return e._stride=this._stride,e._fields=new Map,this._fields.forEach(((t,s)=>e._fields.set(s,t))),e.BufferType=this.BufferType,e}get stride(){return this._stride}get fields(){return this._fields}}function N(){return new K}class O{constructor(e){this.fields=new Array,e.fields.forEach(((e,t)=>{const s={...e,constructor:R(e.constructor)};this.fields.push([t,s])})),this.stride=e.stride}}const Q=[F,t,n,d,f,p,y,i,a,u,l,o,m,E,C,c,v,M,L,A,T,x,z,U,w,b,j,$,k,g,I,P,V,q,D,G];function R(e){return`${e.ElementType}_${e.ElementCount}`}const S=new Map;Q.forEach((e=>S.set(R(e),e)));export{K as I,O as P,N as n};
