/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{T as e}from"./TechniqueType.js";import{p as t}from"./screenUtils.js";import{G as s,b as r,p as i}from"./CIMSymbolHelper.js";import{m as a}from"./rasterizingUtils.js";import{E as n,c as o,L as c}from"./enums2.js";import{A as l,a as h,s as m,b as d,u,o as p,p as f,c as _,i as y,l as g,v as P,z as x,C as v,d as M,n as b,e as w,f as I,h as L,t as z,L as A,j as D,k as S,m as E,q as j,r as k,T as R,w as T,x as B,y as C,B as O,D as F,E as W,F as G,G as V,H as Z,I as q,J as X,K as Y,M as $,N,O as Q,P as H,Q as U,R as J,S as K,U as ee,V as te,W as se,X as re,Y as ie,Z as ae}from"./PieChartMeshWriter.js";import{s as ne,p as oe,y as ce}from"./definitions.js";import{c as le}from"./constants3.js";import{L as he}from"./TurboLine.js";import{m as me}from"./MapUtils.js";import{n as de,L as ue}from"./Logger.js";import{b as pe,t as fe}from"./mat2d.js";import{c as _e}from"./mat2df32.js";import{t as ye,s as ge,d as Pe,f as xe,j as ve,b as Me}from"./vec2.js";import{f as be}from"./vec2f32.js";import{c as we}from"./vec2f64.js";import{h as Ie,a as Le}from"./featureConversionUtils.js";import{O as ze}from"./OptimizedGeometry.js";import{B as Ae}from"./BoundingBox.js";import{L as De,b as Se}from"./utils30.js";import{i as Ee,clone as je}from"../core/lang.js";import ke from"../core/Error.js";import{e as Re}from"./ArcadeExpression.js";import{A as Te}from"./FeatureMetadata.js";function Be(e){let{pixelDimensions:s,texelDimensions:r,baseSize:i,referenceSize:a,strokeWidth:n,sizeRatio:o}=e;if(s||(s=e.sprite.sdf?[0,0]:[e.sprite.width,e.sprite.height]),r||(r=e.sprite.sdf?[0,0]:s),null!=e.patternHeight){const t=e.patternHeight/s[1];s[1]*=t,s[0]*=t}-1===i&&(i=s[1]),i=t(i),a=t(a),n=t(n);const c=(e.sprite.sdfDecodeCoeff??1)*o;return{...e,pixelDimensions:s,texelDimensions:r,baseSize:i,referenceSize:a,strokeWidth:n,sdfDecodeCoeff:c}}class Ce extends l{get vertexSpec(){return{createComputedParams:Be,optionalAttributes:{zoomRange:x,value1Position2Value2:P,lineLength:g},attributes:{id:y,bitset:_,pos:f,offset:p.marker,uv:u.marker,animationPointerAndBaseSizeAndReferenceSize:d,sizing:m,angle:h}}}_write(e,t){const s=this.evaluatedMeshParams.sprite,{textureBinding:r}=s;e.recordStart(this.instanceId,this.attributeLayout,r);const i=t.getDisplayId();if(this.shift&&"esriGeometryPolyline"===t.geometryType)this._writeParticles(e,t);else if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(e,t);else if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[r,a]=s.coords;this._writeQuad(e,i,r,a)}else if("esriGeometryPoint"===t.geometryType){const s=t.readXForDisplay(),r=t.readYForDisplay();this._writeQuad(e,i,s,r)}else{const s=t.readGeometryForDisplay();s&&s.forEachVertex(((t,s)=>{this._writeQuad(e,i,t,s)}))}e.recordEnd()}_writePlacedMarkers(e,r){const i=s.fromFeatureSetReaderCIM(r)?.clone();if(!i)return;const n=v.getPlacement(i,-1,this.evaluatedMeshParams.placement,t(1),e.id,M());if(!n)return;const o=r.getDisplayId();let c=n.next(),l=null;for(;null!=c;){const t=c.tx,s=-c.ty;if(Math.abs(t)>a||Math.abs(s)>a){c=n.next();continue}const r=-c.getAngle();e.recordBounds(t,s,64,64),this.shift?l&&this._writeQuad(e,o,l[0],l[1],void 0,r):this._writeQuad(e,o,t,s,void 0,r),l=[t,s],c=n.next()}}_writeParticles(e,t){const s=t.getDisplayId(),r=t.readGeometryForDisplay();if(!r)return;const i=[];r.forEachVertex(((e,t)=>{i.push([e,t])}));const a=function(e){const t=[];let s=0;for(let r=1;r<e.length;r++){const i=e[r-1],a=e[r],n=a[0]-i[0],o=a[1]-i[1],c=Math.sqrt(n*n+o*o),l=n/c,h=o/c;t.push({a:{position:i,distance:s,direction:[l,h]},b:{position:a,distance:s+c,direction:[l,h]}}),s+=c}return t}(i);let o=0;for(let e=1;e<i.length;e++){const t=i[e][0]-i[e-1][0],s=i[e][1]-i[e-1][1],r=Math.sqrt(t*t+s*s);o+=r}const c=t=>{for(const r of a){const{a:i,b:a}=r;this._writeQuad(e,s,i.position[0],i.position[1],[i.distance-t,a.position[0],a.position[1],a.distance-t],this.evaluatedMeshParams.angleToLine?Math.atan2(i.direction[1],i.direction[0]):0,o,!0)}},{placement:l}=this.evaluatedMeshParams;if(!l||"placementTemplate"in l||"CIMMarkerPlacementOnVertices"===l.type){let e;if(l&&"CIMMarkerPlacementOnVertices"!==l.type)e=l.placementTemplate;else{e=[0];for(const t of a){const{a:s,b:r}=t,i=s.position[0]-r.position[0],a=s.position[1]-r.position[1],n=Math.sqrt(i*i+a*a);e.push(n)}}let t=-1*o;for(;t<2*o;)for(const s of e)t+=s,c(t)}else"CIMMarkerPlacementAtExtremities"===l.type?l.extremityPlacement===n.JustBegin?c(1):l.extremityPlacement===n.JustEnd?(c(o-1),c(-1)):l.extremityPlacement===n.Both&&(c(1),c(o-1)):"CIMMarkerPlacementOnLine"===l.type&&c(o/2)}_writeQuad(e,t,s,r,i,a=0,n=0,o=!1){const c=this.evaluatedMeshParams.sprite,{rect:l}=c,h=l.x+ne,m=l.y+ne,d=l.x+l.width-ne,u=l.y+l.height-ne,p=e.vertexCount();o||e.recordBounds(s,r,64,64);const f={texXmin:h,texYmin:m,texXmax:d,texYmax:u,value1Position2Value2:i,angle:a/le,lineLength:n};for(let i=0;i<4;i++)this._writeVertex(e,t,s,r,f);e.indexEnsureSize(6),e.indexWrite(p),e.indexWrite(p+1),e.indexWrite(p+2),e.indexWrite(p+1),e.indexWrite(p+3),e.indexWrite(p+2)}}class Oe extends Ce{constructor(){super(...arguments),this.shift=!1}}class Fe extends Ce{constructor(){super(...arguments),this.shift=!0}}class We extends l{_write(e,t,r){const i=r??s.fromFeatureSetReaderCIM(t);if(!i)return;const a=this.evaluatedMeshParams.sprite,{textureBinding:n}=a;e.recordStart(this.instanceId,this.attributeLayout,n);const o=t.getDisplayId();this._writePoly(e,o,i.asOptimized()),e.recordEnd()}}class Ge extends We{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Be,attributes:{id:y,bitset:_,pos:f,offset:p.fill,tlbr:z,animationPointerAndBaseSizeAndReferenceSize:d,sizing:m},optionalAttributes:{zoomRange:x,value1Position2Value2:b,lineLength:j}}}_writePoly(e,t,s){const r=[];if(!k(r,s))return;const i=e.vertexCount();s.forEachVertex(((s,r)=>{this._writeVertex(e,t,s,r)})),e.indexEnsureSize(r.length);for(const t of r)e.indexWrite(i+t)}}class Ve{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}}class Ze extends We{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Be,attributes:{id:y,bitset:_,pos:f,offset:p.line,tlbr:z,animationPointerAndBaseSizeAndReferenceSize:d,sizing:m,accumulatedDistance:L,normal:I,segmentDirection:w},optionalAttributes:{zoomRange:x,value1Position2Value2:b,lineLength:g}},this._tessParams=new A,this._currentWrite=new Ve,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:65535,textured:!1},this._lineLength=0,this._lineTessellator=new he(((e,t,s,r,i,a,n,o,c,l,h)=>this._writeTesselatedVertex(e,t,s,r,i,a,n,o,c,l,h,this._lineLength)),this._writeTriangle.bind(this),!1)}_writePoly(e,r,i){const a=D(s.fromOptimized(i,"esriGeometryPolyline"),64);if(null==a)return;const{_currentWrite:n,_tessellationOptions:l}=this,{baseSize:h,capType:m,joinType:d,miterLimit:u}=this.evaluatedMeshParams,p=t(.5*h);l.halfWidth=p,l.capType=S(m||o.Round),l.joinType=E(d||c.Round),l.miterLimit=u||2,n.out=e,n.id=r,n.vertexCount=0,n.indexCount=0,n.vertexFrom=e.vertexCount(),n.vertexBounds=1;for(const{line:e,start:t,pathLength:s}of a){l.initialDistance=t%65535,n.pathLength=s,this._lineLength=0;for(let t=1;t<e.length;t++){const s=e[t].x-e[t-1].x,r=e[t].y-e[t-1].y;this._lineLength+=Math.sqrt(s*s+r*r)}this._lineTessellator.tessellate(e,l,!1)}}_writeTesselatedVertex(e,t,s,r,i,a,n,o,c,l,h,m){const{out:d,id:u,vertexBounds:p,pathLength:f}=this._currentWrite;return this.hasEffects&&d.recordBounds(e,t,p,p),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=a,this._tessParams.distance=h,this._tessParams.pathLength=f,this._tessParams.lineLength=m,this._writeVertex(d,u,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(s),this._currentWrite.indexCount+=3}}const qe=me((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class Xe extends R{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,r,i){if(this._zoomLevel=i||0,null!=r)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),r=t.readYForDisplay();this._writePoint(e,s,r,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[r,i]=s.coords;this._writePoint(e,r,i,0,t);break}case"esriGeometryMultipoint":{let r=0;const i=s.fromFeatureSetReader(t);if(i?.nextPath())for(;i.nextPoint();)this._writePoint(e,i.x,i.y,r++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return["center"===e?0:"right"===e?-1:1,"middle"===t?0:"bottom"===t?-1:1]}_createLineLabelMetric(e,t,s,r,i,a){const[n,o]=this._getMetricDir(),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,l=this.evaluatedMeshParams.scaleInfo?.minScale??0,h=this.evaluatedMeshParams.labelClassId;return new De(e,h,t,s,r,i,n,o,c,l,a)}_writePoint(e,t,s,r,i){if(t<0||t>oe||s<0||s>oe)return;const a=this._getShaping();if(!a)return;const n=i.getDisplayId(),o=this.evaluatedMeshParams.labelClassId,c=(l=i.getObjectId(),de(`${l}${r}`));var l;const h=function(e,t,s){return de(`${e}${t}${s}`)}(i.getObjectId(),o,r),[m,d]=this._getMetricDir(),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,p=this.evaluatedMeshParams.scaleInfo?.minScale??0,f=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new De(n,o,c,h,t,s,m,d,u,p,f)),this._writeGlyphs(e,n,t,s,a,0,f,void 0,!1),e.metricBoxWrite(a.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:r}=this.evaluatedMeshParams,i=this.evaluatedMeshParams.repeatLabelDistance||128,a=this._getShaping("middle");if(!a)return;const n=(e,t,s,r)=>this._placeSubdivGlyphs(e,t,s,r),o=(a.bounds.width+i)/2;this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:a,zoomRange:T(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement="bottom"===r?"above":"top"===r?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,n,o):this._writeCenterAlong(t,n,o)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:a}=this.evaluatedMeshParams,{shaping:n}=this._current,o=n.bounds.halfHeight,c=e.readGeometryForDisplay();if(!c)return;const l=new ze;Ie(l,c,!1,!1,"esriGeometryPolyline",1);const h=Ye(new ze,l,o),m=Ye(new ze,l,-o),d=Le(m,"esriGeometryPolyline",!1,!1),u=Le(h,"esriGeometryPolyline",!1,!1),p=r(u.paths,n.bounds.width),f=r(d.paths,n.bounds.width);this._current.offsetDirection="above";for(let e=0;e<p.length;e++)this._current.pathIndex=e,i(p[e],s,t,!!a);this._current.offsetDirection="below";for(let e=0;e<f.length;e++)this._current.pathIndex=e,i(f[e],s,t,!!a)}_writeCenterAlong(e,t,s){const{repeatLabel:a}=this.evaluatedMeshParams,{shaping:n}=this._current,o=r(e.readLegacyGeometryForDisplay().paths,n.bounds.width);for(let e=0;e<o.length;e++)this._current.pathIndex=e,i(o[e],s,t,!!a)}_placeSubdivGlyphs(e,t,s,r){const{allowOverrun:i,labelPosition:a,repeatLabelDistance:n}=this.evaluatedMeshParams,o=this._current.zoomRange[0],c=qe(t),l=this._current.shaping.bounds.width/2,h=Math.sqrt(n||128)/2,m=Math.min(s,r-s),d=this._current.shaping.isMultiline?B:Math.log2(m/(h+l/2)),u=0===t?d:Math.min(c,d),p=Math.max(o,this._zoomLevel+1-u),f=this._zoomLevel-p,_=this._current.shaping.bounds.width/2*2**f,y=function(e,t,s,r){return de(`${e}${t}${s*2**(B-r)}`)}(this._current.objId,this._current.pathIndex,t,this._zoomLevel),g=function(e,t,s,r,i){return de(`${e}${i}${t}${s*2**(B-r)}`)}(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?0===t&&this._placeStraight(e,p,y,g):i&&f<0?this._placeStraightAlong(e,o,y,g):"parallel"===a?this._placeStraightAlong(e,p,y,g):"curved"===a&&this._placeCurved(e,p,_,y,g)}_placeStraight(e,t,s,r){const{out:i,id:a,shaping:n,referenceBounds:o}=this._current,{x:c,y:l}=e;i.metricStart(this._createLineLabelMetric(a,s,r,c,l)),i.metricBoxWrite(n.boundsT);const h=e.angle*(180/Math.PI)%360,m=(e.angle*(180/Math.PI)+180)%360,d={clipAngle:h,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(i,a,c,l,n,0,o,d,!1);const u={clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(i,a,c,l,n,0,o,u,!1),i.metricEnd()}_placeCurved(e,t,s,r,i){const{out:a,id:n}=this._current;a.metricStart(this._createLineLabelMetric(n,r,i,e.x,e.y));const o=e.clone(),c=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(o,t,1,c),this._placeBack(e,o,t,s,1,c),this._placeForward(e,o,t,s,1,c)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(o,t,0,l),this._placeBack(e,o,t,s,0,l),this._placeForward(e,o,t,s,0,l)),a.metricEnd()}_placeStraightAlong(e,s,r,i){const{out:a,id:n,shaping:o,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:m}=this.evaluatedMeshParams,d=e.clone(),u=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360,f=o.glyphs.length>0&&!(!h&&!m);if(a.metricStart(this._createLineLabelMetric(n,r,i,e.x,e.y)),f){const r=Math.max(s,c[0],0),i=Math.min(B,c[1]),h=pe(_e(),-e.angle),m={minZoom:r,maxZoom:i,clipAngle:u,mapAligned:!0,isLineLabel:!0},d=t(this.evaluatedMeshParams.offsetX),f=t(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=be(d,-1*f),[s,r]=o.shapeBackground(fe(_e(),h,t));a.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,r,l,m),a.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=be(d,f),[s,r]=o.shapeBackground(fe(_e(),h,t));m.clipAngle=p,a.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,r,l,m),a.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(d,s,1,u,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(d,s,0,p,!0),a.metricEnd()}_placeBack(e,t,s,r,i,a){const n=e.clone();let o=e.backwardLength+0;for(;n.prev()&&!(o>=r);)this._placeOnSegment(n,t,o,s,-1,i,a),o+=n.length+0}_placeForward(e,t,s,r,i,a){const n=e.clone();let o=e.remainingLength+0;for(;n.next()&&!(o>=r);)this._placeOnSegment(n,t,o,s,1,i,a),o+=n.length+0}_placeFirst(e,s,r,i,a=!1){const{out:n,id:o,shaping:c,zoomRange:l,referenceBounds:h}=this._current,m=c.glyphs,d=t(this.evaluatedMeshParams.offsetX),u=t(this.evaluatedMeshParams.offsetY),p=be(d,u),f=pe(_e(),-e.angle);ye(p,p,f);for(const t of m){const m=t.x>c.bounds.x?r:1-r,d=m*e.remainingLength+(1-m)*e.backwardLength,u=Math.abs(t.x+t.width/2-c.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(u/(d+0))),_=Math.max(s,a?0:f);if(t.maxZoom=Math.min(l[1],B),t.angle=e.angle+(1-r)*Math.PI,t.minZoom=Math.max(l[0],_),this._writeLineGlyph(n,o,e.x,e.y,t,i,h,!0),(r||this._current.offsetDirection)&&this._isVisible(t.minZoom,t.maxZoom)){const e=new Ae(t.bounds.x+p[0],t.bounds.y+p[1],t.bounds.width,t.bounds.height);n.metricBoxWrite(e)}}}_placeOnSegment(e,s,r,i,a,n,o){const{out:c,id:l,shaping:h,referenceBounds:m}=this._current,d=h.glyphs,u=e.dx/e.length,p=e.dy/e.length,f={x:e.x+r*-a*u,y:e.y+r*-a*p},_=t(this.evaluatedMeshParams.offsetX),y=t(this.evaluatedMeshParams.offsetY),g=be(_,y),P=pe(_e(),-e.angle);ye(g,g,P);for(const t of d){const s=t.x>h.bounds.x?n:1-n;if(!(s&&1===a||!s&&-1===a))continue;const d=Math.abs(t.x+t.width/2-h.bounds.x),u=Math.max(0,this._zoomLevel+Math.log2(d/r)-.1),p=Math.max(i,this._zoomLevel+Math.log2(d/(r+e.length+0)));if(0!==u&&(t.angle=e.angle+(1-n)*Math.PI,t.minZoom=p,t.maxZoom=u,this._writeLineGlyph(c,l,f.x,f.y,t,o,m,!0),(n||this._current.offsetDirection)&&this._isVisible(t.minZoom,t.maxZoom))){const e=new Ae(t.bounds.x+g[0],t.bounds.y+g[1],t.bounds.width,t.bounds.height);c.metricBoxWrite(e)}}}_writeLineGlyph(e,t,s,r,i,a,n,o){if(s<0||s>oe||r<0||r>oe)return;e.recordStart(this.instanceId,this.attributeLayout,i.textureBinding);const{texcoords:c,offsets:l}=i,{fontSize:h,haloSize:m,outlineSize:d}=this._textMeshTransformProps;this._writeQuad(e,t,s,r,{texcoords:c,offsets:l,fontSize:h,haloSize:m,outlineSize:d,color:C(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:n,minZoom:Math.max(this._current.zoomRange[0],i.minZoom),maxZoom:Math.min(this._current.zoomRange[1],i.maxZoom),clipAngle:a,mapAligned:o,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*ce)/ce}_isVisible(e,t){let s=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);s=this._packedZoom(s),r=this._packedZoom(r);const i=this._packedZoom(this._zoomLevel);return s<=i&&i<=r}}function Ye(e,t,s){const{coords:r,lengths:i}=t,a=we(),n=we(),o=we(),c=we(),l=we(),h=we();let m=0;for(let t=0;t<i.length;t++){const d=i[t];for(let t=0;t<d;t++){const i=2*(t+m-1),u=2*(t+m),p=2*(t+m+1);t>0?ge(a,r[i],r[i+1]):ge(a,0,0),ge(n,r[u],r[u+1]),t<d-1?ge(o,r[p],r[p+1]):ge(o,0,0),0===t?ge(c,0,0):(Pe(c,n,a),xe(c,c),ge(c,c[1],-c[0])),t===d-1?ge(l,0,0):(Pe(l,o,n),xe(l,l),ge(l,l[1],-l[0])),ve(h,c,l),xe(h,h);const f=h[0]*l[0]+h[1]*l[1];0!==f&&Me(h,h,f),Me(h,h,s),e.coords.push(n[0]+h[0],n[1]+h[1])}e.lengths.push(d),m+=d}return e}class $e extends Te{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}hasArcadeDependency(e){return!1}}async function Ne(e,t,s,r){const{defaultValue:i,valueExpressionInfo:a,value:n}=t;if(a){if("dictionary-template"===a.type)return{...t,computed:e.createDictionaryTemplateField(a,s),defaultValue:i};const{expression:n}=a,o=await e.createComputedField({expression:n},r);return o?{...t,computed:o,defaultValue:i}:null}return{...t,computed:new $e(n),defaultValue:i}}async function Qe(e,t,s){const{valueExpressionInfo:r}=t,i="dictionary-template"===r.type?e.createDictionaryTemplateField(r,s):await e.createComputedField({expression:r.expression});return i?{...t,computed:i}:null}function He(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function Ue(e){if(Array.isArray(e))for(const t of e)if(Ue(t))return!0;if("object"==typeof e){if(He(e))return!0;for(const t in e)if(Ue(e[t]))return!0}return!1}class Je{static async create(e,t,s,r){const i={},a=new Map,n=new Map,o=new Map,c=new Map,l=new Map,h=new Map;for(const m in s){const d=s[m];if(null!=d&&"object"==typeof d)if(Array.isArray(d)){if("object"==typeof d[0])throw new Error(`InternalError: Cannot handle ${m}. Nested array params are not supported`);i[m]=d}else if("valueExpressionInfo"in d){if(d.value){i[m]=d.value;continue}const t=await Qe(e,d,r);if(!t){i[m]=d.defaultValue;continue}a.set(m,t),i[m]=null}else switch(d.type){case"cim-effect-infos":if(d.effectInfos.some((e=>e.overrides.length))){n.set(m,{effects:await Promise.all(d.effectInfos.map((async t=>{const s=t.overrides.map((t=>Ne(e,t,r,!1)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(Ee)}})))});break}i[m]=d.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":d.overrides.length&&o.set(m,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map((t=>Ne(e,t,r,!1))))).filter(Ee)}),i[m]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const t=d.overrides.map((t=>Ne(e,t,r,d.useLegacyLabelEvaluationRules??!1)));c.set(m,{compiledOverrides:(await Promise.all(t)).filter(Ee),rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};i[m]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const t=d.overrides.map((t=>Ne(e,t,r,!1)));c.set(m,{compiledOverrides:(await Promise.all(t)).filter(Ee),rasterizationParam:d,objectIdToResourceId:new Map});continue}if("animated"===d.resource.type){c.set(m,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};i[m]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=d;if(Ue(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const i={props:{}};for(const s in t)if(He(t[s])){const a=await Qe(e,t[s],r);i.compiledExpressionMap||(i.compiledExpressionMap=new Map);const n=i.compiledExpressionMap;a&&n.set(s,a)}else i.props[s]=t[s];s.compiledMarkerInfos.push(i)}))),l.set(m,s)}else i[m]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:s}=d,r=O(s);if(Ue(r)){const t=await Promise.all(r.map((t=>F(t,e))));h.set(m,{params:t,propertyIdToResourceId:new Map,key:m})}else{const e=W(r),s=await t.fetchResourceImmediate({type:"animation-info",resource:e});null!=s&&"sprite"===s.type&&(i[m]={dataRow:s.rect.y,dataColumn:s.rect.x})}break}default:i[m]=d}else i[m]=d}return new Je(s,i,a,n,o,c,l,h)}constructor(e,t,s,r,i,a,n,o){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=i,this._dynamicAsyncProperties=a,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=o,this.evaluator=e=>e,this._arcadeDependencies=new Set;for(const e of this._expressions())Re(this._arcadeDependencies,e)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const r of this._dynamicAsyncProperties.values()){const i=je(r.rasterizationParam.resource);"animated"===r.rasterizationParam.resource.type&&r.rasterizationParam.resource.randomizeStartTime&&(i.primitiveName="__RESERVED__PRIMITIVE__NAME__",i.startGroup=G(t.getObjectId()||0));for(const{primitiveName:e,propertyName:a,computed:n,defaultValue:o,valueExpressionInfo:c}of r.compiledOverrides)try{const c="animated"===r.rasterizationParam.resource.type?i.primitiveName:e;Se(i,c,a,n,t,s,o)}catch(e){ue.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new ke("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:e,valueExpressionInfo:c}))}const a=e.enqueueRequest({type:"cim-rasterization-info",resource:i});r.objectIdToResourceId.set(t.getObjectId(),a)}for(const r of this._dynamicAsyncAnimations.values()){const i=r.params.map((e=>V(e,t,s))).map(Z).map((e=>e.simplify())),a=q(i),n=e.enqueueRequest({type:"animation-info",resource:a});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,n)}}evaluateMeshParams(e,t,s){for(const[e,r]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=r.computed.readWithDefault(t,s,r.defaultValue);for(const[e,r]of this._dynamicPlacementProperties.entries())for(const{computed:i,defaultValue:a,propertyName:n}of r.compiledOverrides){const o=i.readWithDefault(t,s,a);r.placementInfo.placement[n]=o,this._resolvedMeshParams[e]=r.placementInfo.placement}for(const[e,r]of this._dynamicEffectProperties.entries())for(const i of r.effects){for(const{computed:e,defaultValue:r,propertyName:a}of i.compiledOverrides){const n=e.readWithDefault(t,s,r);i.effect[a]=n}this._resolvedMeshParams[e]=r.effects.map((e=>e.effect))}for(const[e,r]of this._dynamicTransformProperties.entries()){const i={type:"cim-marker-transform-info",infos:[]};for(const e of r.compiledMarkerInfos){const r={...e.props};if(e.compiledExpressionMap)for(const[i,a]of e.compiledExpressionMap){const e=a.computed.readWithDefault(t,s,a.defaultValue);r[i]="number"==typeof e||"boolean"==typeof e?e:a.defaultValue}i.infos.push(r)}this._resolvedMeshParams[e]=i}for(const[s,r]of this._dynamicAsyncProperties.entries()){const i=r.objectIdToResourceId.get(t.getObjectId());if(null==i)continue;const a=e.getResource(i);this._resolvedMeshParams[s]=a}for(const[s,r]of this._dynamicAsyncAnimations.entries()){const i=r.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(null==i)continue;const a=e.getResource(i);this._resolvedMeshParams[s]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const e of t.compiledOverrides)yield e.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(null!=t.compiledExpressionMap)for(const e of t.compiledExpressionMap.values())yield e.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*X(t)}}class Ke{async createMeshWriter(e,t,s,r,i){const a=this._getMeshWriter(r.techniqueType),n=await Je.create(e,t,r.inputParams,i),o=new a(r.id,n,r.optionalAttributes,s);return await o.loadDependencies(),o}_getMeshWriter(t){switch(t){case e.Fill:return ae;case e.DotDensity:return ie;case e.ComplexFill:return re;case e.PatternFill:return se;case e.GradientFill:return te;case e.OutlineFill:return ee;case e.PatternOutlineFill:return K;case e.ComplexOutlineFill:return J;case e.Marker:return U;case e.PieChart:return H;case e.Text:return R;case e.Line:return Q;case e.TexturedLine:return N;case e.GradientStroke:return $;case e.Heatmap:return Y;case e.Label:return Xe;case e.AnimatedMarker:return Oe;case e.AnimatedMarkerShift:return Fe;case e.AnimatedFill:return Ge;case e.AnimatedLine:return Ze;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{$e as D,Ke as M};
