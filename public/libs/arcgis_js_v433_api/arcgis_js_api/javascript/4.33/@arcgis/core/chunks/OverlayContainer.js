/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{t}from"./common.js";import{c as e,m as s,d as o,g as i,r}from"./mat3.js";import{c as a}from"./mat3f32.js";import{f as n}from"./vec2f32.js";import{f as p}from"./vec3f32.js";import{normalizeMapX as d}from"../geometry/support/normalizeUtils.js";import{l}from"./unitUtils.js";import{g as h}from"./viewpointUtils.js";import{W as c}from"./enums4.js";import{W as u}from"./WGLContainer.js";import{d as f}from"./maybe.js";import{M as m}from"./FeatureCommandQueue.js";import{s as v}from"./utils27.js";import{G as y,F as x,h as w,l as g,V as _,a as M,t as S,n as j,o as b,u as A,M as O,S as E,p as R,q as T,U as P,r as D,T as U}from"./GraphShaderModule.js";import{T as z}from"./TechniqueType.js";import{_ as G,c as W}from"./tslib.es6.js";import{q,r as C,e as I,D as L}from"./enums.js";import{V as B}from"./VertexElementDescriptor.js";class F extends T{}G([b(0,_)],F.prototype,"pos",void 0),G([b(1,_)],F.prototype,"uv",void 0);class N extends P{}G([A(O)],N.prototype,"dvs",void 0);class V extends P{}G([A(_)],V.prototype,"perspective",void 0),G([A(_)],V.prototype,"texSize",void 0),G([A(x)],V.prototype,"wrapAroundShift",void 0),G([A(x)],V.prototype,"opacity",void 0),G([A(E)],V.prototype,"texture",void 0);class K extends y{constructor(){super(...arguments),this.type="OverlayShader"}vertex(t){const e=t.uv.divide(this.config.texSize),s=new x(1).add(w(e,this.config.perspective)),o=new g(t.pos.add(new _(this.config.wrapAroundShift,0)),1),i=this.transform.dvs.multiply(o);return{uv:e,glPosition:new M(i.xy.multiply(s),0,s)}}fragment(t){const e=S(this.config.texture,t.uv).multiply(this.config.opacity),s=new j;return s.fragColor=e,s}}G([A(N)],K.prototype,"transform",void 0),G([A(V)],K.prototype,"config",void 0),G([W(0,R(F))],K.prototype,"vertex",null),G([W(0,R(class extends D{}))],K.prototype,"fragment",null);class Q extends U{constructor(){super(...arguments),this.type=z.Overlay,this._mesh=null,this.shaders={overlay:new K}}render(t,e){const{context:s,painter:o}=t,i=this._getMesh(t,e);o.setPipelineState(v);const{isWrapAround:r,wrapAroundShift:a}=e.config,n={...e.config,wrapAroundShift:0},p={shader:this.shaders.overlay,uniforms:{transform:e.transform,config:n},defines:null,optionalAttributes:null,useComputeBuffer:!1};o.setPipelineState({...v,stencil:{write:!1,test:{compare:C.EQUAL,op:{fail:q.KEEP,zFail:q.KEEP,zPass:q.REPLACE},ref:0,mask:255}}}),o.submitDrawMeshUntyped(s,p,i),r&&(n.wrapAroundShift=a,o.submitDrawMeshUntyped(s,p,i))}shutdown(){f(this._mesh)}_getMesh(t,e){const{context:s}=t;if(this._mesh){const t=this._mesh.vertexBuffers.get("positions");if(!t)throw new Error("Buffer not found");t.buffer.setData(e.position)}else{const t=null!=e.index?e.index.length:e.position.length/2;this._mesh=new m(s,{vertex:{positions:{data:e.position,attributes:[new B("pos",2,L.FLOAT,0,8)]},uvs:{data:e.tex,attributes:[new B("uv",2,L.UNSIGNED_SHORT,0,4)]}},index:null!=e.index?{index:{data:e.index}}:void 0,groups:[{index:null!=e.index?"index":void 0,primitive:I.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:t}]})}return this._mesh}}class k extends u{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=a(),this._overlayTechnique=new Q}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}doRender(t){if(t.drawPhase!==c.MAP||!this.visible)return;super.doRender(t);const e=this._overlayTechnique;for(const s of this.children)s.draw(t,e)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(a){const{state:l}=a,{id:h,size:c,pixelRatio:u,resolution:f,rotation:m,viewpoint:v,displayMat3:y}=l;if(this._viewStateId===h)return;const x=t(m),w=u*c[0],g=u*c[1];this._localOrigin=v.targetGeometry.clone();const{x:_,y:M}=this._localOrigin,S=d(_,l.spatialReference);this._localOrigin.x=S,this._localOrigin.y=M;const j=f*w,b=f*g,A=e(this._dvsMat3);s(A,A,y),o(A,A,n(w/2,g/2)),i(A,A,p(w/j,-g/b,1)),r(A,A,-x),this._viewStateId=h}_updateOverlays(e,s){const{state:o}=e,{rotation:i,spatialReference:r,worldScreenWidth:a,size:n,viewpoint:p}=o,d=this._localOrigin;let c,u=0;const f=l(r);if(f&&r.isWrappable){const e=n[0],s=n[1],d=t(i),l=Math.abs(Math.cos(d)),m=Math.abs(Math.sin(d)),v=Math.round(e*l+s*m),[y,x]=f.valid,w=h(r),{x:g,y:_}=p.targetGeometry,M=[g,_],S=[0,0];o.toScreen(S,M);const j=[0,0];let b;b=v>a?.5*a:.5*v;const A=Math.floor((g+.5*w)/w),O=y+A*w,E=x+A*w,R=[S[0]+b,0];o.toMap(j,R),j[0]>E&&(u=w),R[0]=S[0]-b,o.toMap(j,R),j[0]<O&&(u=-w),c={worldWidth:w,xBounds:[y,x]}}for(const t of s)t.updateDrawCoords(d,u,o,c)}}export{k as O};
