/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{y as t,s as e,p as s,t as i,g as r,I as n,J as o,b as a,a as c}from"./definitions.js";import u from"../Color.js";import{n as l,L as h}from"./Logger.js";import{M as p,i as f,a as d,b as m,e as x}from"./UpdateTracking2D.js";import{D as y}from"./enums.js";import{p as g}from"./screenUtils.js";import{T as _,G as k,j as S}from"./GeometryUtils.js";import{b,a as v,d as P,e as w,p as T,s as M,f as E,g as A,h as z,i as I}from"./constants3.js";import{c as L,C as D,L as F,J as N,S as O,d as Y}from"./enums2.js";import{e as C,c as G}from"./mathUtils.js";import{f as B,h as R,S as U,G as W,i as H,j as X}from"./CIMSymbolHelper.js";import{h as V}from"../core/lang.js";import{t as Z,l as j}from"./libtess.js";import{v as q,i as Q,p as J,h as $}from"./utils30.js";import{s as K,g as tt,a as et}from"./shapingUtils.js";import{o as st}from"./utils3.js";import{L as it}from"./TurboLine.js";import"./earcut.js";import{O as rt}from"./OptimizedGeometry.js";import{c as nt,t as ot,r as at}from"./mat2d.js";import{c as ct}from"./mat2df32.js";import{t as ut}from"./vec2.js";import{m as lt}from"./rasterizingUtils.js";import ht from"../core/Error.js";import{c as pt}from"../geometry/Polygon.js";const ft=96/72;class dt{static executeEffects(t,e,s,i,r){const n=ft,o=B(t);let a=new U(e);for(const e of t){const t=R(e);t&&(a=t.execute(a,e,n,s,i,o,r))}return a}static applyEffects(t,e,s){if(!t)return e;const i=B(t);let r,n=new U(W.fromJSONCIM(e));for(const e of t){const t=R(e);t&&(n=t.execute(n,e,1,null,s,i,!1))}const o=[];let a=null;for(;r=n.next();)o.push(...pt(r)),a=r.geometryType;return 0===o.length||null===a?null:"esriGeometryPolygon"===a?{rings:o}:{paths:o}}}function mt(t,e){let s;if("string"==typeof t)s=l(t+`-seed(${e})`);else{let i=12;s=t^e;do{s=107*(s>>8^s)+i|0}while(0!==--i)}return(1+s/(1<<31))/2}function xt(t){return Math.floor(mt(t,yt)*gt)}const yt=53290320,gt=10;class _t{static getPlacement(t,e,s,i,r,n){const o=H(s);return o?(-1===e&&t.invertY(),o.execute(t,s,i,r,n)):null}}function kt(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||0,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||100]}function St(t){return 1<<t}function bt(t){let e=0;for(const[s,i]of t)i&&(e|=1<<s);return e}function vt(t){let e;if(!t)return[0,0,0,0];if("string"==typeof t){const s=u.fromString(t);if(!s)return h.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils").errorOnce(new ht("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=s.toArray()}else e=t;const[s,i,r,n]=e;return[s*(n/255),i*(n/255),r*(n/255),n]}function Pt(t){switch(t){case"butt":case L.Butt:return D.BUTT;case"round":case L.Round:return D.ROUND;case"square":case L.Square:return D.SQUARE}}function wt(t){switch(t){case"bevel":case F.Bevel:return N.BEVEL;case"miter":case F.Miter:return N.MITER;case"round":case F.Round:return N.ROUND}}function Tt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function Mt(t,e){return Math.round(t*e)/e}let Et=null;function At(){return Et}function zt(t){switch(t){case y.BYTE:case y.UNSIGNED_BYTE:return 1;case y.SHORT:case y.UNSIGNED_SHORT:case y.HALF_FLOAT:return 2;case y.FLOAT:case y.INT:case y.UNSIGNED_INT:return 4}}class It{static fromVertexSpec(t,e){const{attributes:s,optionalAttributes:i}=t;let r,n,o;const a=[];for(const t in s){if(s[t].otherSource)continue;const e=s[t];"position"===e.pack?r={...e,name:t,offset:0}:"id"===e.pack?n={...e,name:t,offset:4}:"bitset"===t?o={...e,name:t,offset:7}:a.push({...e,name:t})}for(const t in i)if(!0===e[t]){const e=i[t];a.push({...e,name:t})}const c=function(t){const e=[],s=[],i=[];for(const r of t){const t=zt(r.type)*r.count;switch(t%2||t%4||4){case 4:e.push(r);continue;case 2:s.push(r);continue;case 1:i.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...i),e}(a),u=[];let l=8,h=1;for(const t of c)u.push({...t,offset:l}),l+=zt(t.type)*t.count,t.packAlternating&&(h=Math.max(t.packAlternating.count,h));const p=Uint32Array.BYTES_PER_ELEMENT,f=l%p;return new It(r,n,o,u,l+(f?p-f:0),h)}constructor(t,e,s,i,r,n){this.position=t,this.id=e,this.bitset=s,this.standardAttributes=i,this.stride=r,this.packVertexCount=n,i.push(s),this._attributes=[t,e,s,...i]}get attributeLayout(){if(!this._attributeLayout){const t=q(this._attributes),e=this._attributes.map((t=>({name:t.name,count:t.count,offset:t.offset,type:t.type,packPrecisionFactor:t.packPrecisionFactor,normalized:t.normalized??!1})));this._attributeLayout={attributes:e,hash:t,stride:this.stride}}return this._attributeLayout}}class Lt{static fromVertexSpec(t,e){const s=It.fromVertexSpec(t,e);return new Lt(s)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,e,s,i,r,n){for(let t=0;t<this._spec.packVertexCount;t++){const o=t*this._spec.stride;this._packPosition(s,i,o),this._packId(e,o);const a=this._spec.bitset;if(n){if(a.packTessellation){const t=a.packTessellation(n,r,s,i);this._pack(t,a,o)}for(const t of this._spec.standardAttributes)if(null!=t.packTessellation){const e=t.packTessellation(n,r,s,i);this._pack(e,t,o)}else if(t.packAlternating?.packTessellation){const e=t.packAlternating.packTessellation(n,r,s,i);for(let s=0;s<this._spec.packVertexCount;s++){const i=e[s];this._pack(i,t,s*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,e){for(const s of this._spec.standardAttributes)if(s.pack&&"string"!=typeof s.pack){const i=s.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++)this._pack(i,s,t*this._spec.stride)}else if(s.packAlternating?.pack){const i=s.packAlternating.pack(t,e);for(let t=0;t<this._spec.packVertexCount;t++){const e=i[t];this._pack(e,s,t*this._spec.stride)}}}_packPosition(t,e,s){const{offset:i}=this._spec.position,r=this._spec.position.packPrecisionFactor??1,n=Q(t*r,e*r);this._dataView.setUint32(s+i,n,!0)}_packId(t,e){const s=t*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(e+this._spec.id.offset,!0);this._dataView.setUint32(e+this._spec.id.offset,s|i,!0)}_pack(t,e,s){J(this._dataView,t,e,s)}}class Dt{constructor(t,e,s,i){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=i,this._evaluator.evaluator=t=>this.vertexSpec.createComputedParams(t)}get _vertexPack(){if(!this._cachedVertexPack){const t=Lt.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){(function(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1})(this.effectInfos)&&await async function(){Et=await import("./geometryEngineJSON.js").then((t=>t.g))}()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,i,r){this.ensurePacked(e,s,i);const n=this.evaluatedMeshParams.effects;if(!n||0===n.length)return void this._write(t,s,void 0,r);const o=this.getEffectCursor(t,s,n);if(!o)return;let a;for(;a=o.next();)a.invertY(),this._write(t,s,a,r)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const i=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(i,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,s,i,r){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,i,n,r)}getEffectCursor(t,e,s){const i=e.readGeometryForDisplay()?.clone();if(!i)return;const r=W.fromOptimizedCIM(i,e.geometryType),n=At();r.invertY();const o=t.id||"";return dt.executeEffects(s,r,o,n,this._preventEffectClipping)}}class Ft extends Dt{}function Nt(t){return t instanceof Ot?t:"object"==typeof t&&"type"in t?Rt[t.type].hydrate(t):new Yt(t)}class Ot{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}}class Yt extends Ot{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,s,i]=this.value;return null!=i?f.vector4.encode([t,e||0,s||0,i]):f.vector3.encode([t,e||0,s||0])}return f.scalar.encode(this.value)}}class Ct extends Ot{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new Ct(t,Nt(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof Yt))return this;const[e,s,i,r]=t.value,n=this._config.translation.from[0],o=this._config.translation.from[1],a=this._config.rotation.from,c=this._config.scale.from;if(n===this._config.translation.to[0]&&o===this._config.translation.to[1]&&a===this._config.rotation.to&&c===this._config.scale.to){const t=i+a,u=r*c,l=Math.sin(i),h=Math.cos(i);return new Yt([h*r*n-l*r*o+e,l*r*n+h*r*o+s,t,u])}return new Ct(this._config,t)}get instructions(){return f.animatedTransform.encode(this._config)}}class Gt extends Ot{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new Gt(t,Nt(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof Yt))return this;const[e,s,i,r]=t.value,n=this._config.color.from[0],o=this._config.color.from[1],a=this._config.color.from[2];let c=this._config.color.from[3];const u=this._config.opacity.from;return n===this._config.color.to[0]&&o===this._config.color.to[1]&&a===this._config.color.to[2]&&c===this._config.color.to[3]&&u===this._config.opacity.to?(c*=u,new Yt([e*n,s*o,i*a,r*c])):new Gt(this._config,t)}get instructions(){return f.animatedColor.encode(this._config)}}class Bt extends Ot{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new Bt(t,Nt(t.parent))}simplify(){const t=this._parent.simplify();return t instanceof Yt?new Bt(this._config,t):this}get instructions(){return f.animatedShift.encode(this._config)}}const Rt={AnimatedTransform:Ct,AnimatedColor:Gt,AnimatedShift:Bt};function Ut(t){return Ht(t.map((t=>Vt(t))).map((t=>Nt(t).simplify())))}function Wt(t){const e=[];return e.push(t.transform),e.push(t.fromColor),e.push(t.toColor),e.push(t.colorMix),e.push(t.toOpacity),e.push(t.opacityMix),t?.shift?e.push(t?.shift):e.push([1,1,1,1]),e}function Ht(t){const e=[],s=[];let i=0;for(const r of t){const n=[...r.encode(),...f.ret.encode()];e.push([i+t.length,0,0,0]),s.push(...n),i+=n.length}return[...e,...s]}async function Xt(t,e){const s=t;let i;if("number"==typeof s||"string"==typeof s||"boolean"==typeof s)i=s;else if(Array.isArray(s))i=await Promise.all(s.map((t=>Xt(t,e))));else if("object"==typeof s)if("valueExpressionInfo"in s){const{valueExpressionInfo:t}=s,{expression:r}=t;i={...s,computed:await e.createComputedField({expression:r})}}else{i={};for(const t in s)i[t]=await Xt(s[t],e)}return i}function Vt(t,e,s){const i=t;let r;if("number"==typeof i||"string"==typeof i||"boolean"==typeof i)r=i;else if(Array.isArray(i))r=i.map((t=>Vt(t,e,s)));else if("object"==typeof i)if("type"in i&&null!=i.type&&"Process"===i.type)switch(i.op){case"ArcadeColor":{const t=Vt(i.value,e,s);jt(Array.isArray(t)&&4===t.length),r=[t[0]/255,t[1]/255,t[2]/255,t[3]]}break;case"Transparency":{const t=Vt(i.value,e,s);jt("number"==typeof t),r=1-t/100}break;case"Divide":case"Multiply":case"Add":{const t=Vt(i.left,e,s);jt("number"==typeof t);const n=Vt(i.right,e,s);switch(jt("number"==typeof n),i.op){case"Divide":r=t/n;break;case"Multiply":r=t*n;break;case"Add":r=t+n}}break;case"Random":{const t=Vt(i.seed,e,s),n=Vt(i.min,e,s),o=Vt(i.max,e,s);r=n+mt(xt(e.getObjectId()||0),t)*(o-n)}break;case"Cond":{const t=Vt(i.condition,e,s),n=Vt(i.ifTrue,e,s),o=Vt(i.ifFalse,e,s);r=t?n:o}break;case"MatchWinding":{const t=Vt(i.sign,e,s);let n=Vt(i.angle,e,s);if(t>0)for(;n<0;)n+=2*Math.PI;else for(;n>0;)n-=2*Math.PI;r=n}}else if("computed"in i)r=function(t){if(!("computed"in t))return t;let i=t.computed.readWithDefault(e,s,[255*t.defaultValue[0],255*t.defaultValue[1],255*t.defaultValue[2],t.defaultValue[3]]);if("string"==typeof i){const t=u.fromString(i);t&&(i=[t.r,t.g,t.b,t.a])}return i}(i);else{r={};for(const t in i)r[t]=Vt(i[t],e,s)}return r}function*Zt(t){const e=t;if(Array.isArray(e))for(const t of e)yield*Zt(t);else if("object"==typeof e)if("type"in e&&null!=e.type&&"Process"===e.type)switch(e.op){case"ArcadeColor":case"Transparency":yield*Zt(e.value);break;case"Divide":case"Multiply":case"Add":yield*Zt(e.left),yield*Zt(e.right);break;case"Random":yield*Zt(e.seed),yield*Zt(e.min),yield*Zt(e.max);break;case"Cond":yield*Zt(e.condition),yield*Zt(e.ifTrue),yield*Zt(e.ifFalse);break;case"MatchWinding":yield*Zt(e.sign),yield*Zt(e.angle)}else if("computed"in e)yield e.computed;else for(const t in e)yield*Zt(e[t])}function jt(t){if(!t)throw new Error("Assertion failed.")}const qt={type:y.SHORT,count:2,packPrecisionFactor:t,pack:({scaleInfo:t},{tileInfo:e})=>kt(t,e)},Qt={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:t})=>(jt(t),t)},Jt={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},$t={type:y.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Kt={type:y.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:t})=>t},te={type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},ee={type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},se={type:y.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[t,e]},ie={type:y.UNSIGNED_BYTE,count:3,pack:"id"},re={type:y.UNSIGNED_BYTE,count:1,pack:function(t){const{sprite:e,isMapAligned:s,colorLocked:i,scaleSymbolsProportionally:r,isStroke:n}=t;let o=0;return s&&(o|=St(p.bitset.isMapAligned)),i&&(o|=St(p.bitset.colorLocked)),e.sdf&&(o|=St(p.bitset.isSDF)),r&&(o|=St(p.bitset.scaleSymbolsProportionally)),n&&(o|=St(p.bitset.isStroke)),o}},ne={type:y.SHORT,count:2,pack:"position",packPrecisionFactor:1},oe={marker:{type:y.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:t})=>[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}},line:{type:y.FLOAT,count:2,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e},{baseSize:s})=>[t*s/2,e*s/2]},fill:{type:y.FLOAT,count:2,packTessellation:()=>[0,0]}},ae={marker:{type:y.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:t,texXmin:e,texYmax:s,texYmin:i})=>[[e,i],[t,i],[e,s],[t,s]]}}},ce={type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:s,width:i,height:r}=t,n=s.x+e,o=s.y+e;return[n+1,o+1,n+i-1,o+r-1]}},ue={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:t,baseSize:e,referenceSize:s})=>[t.dataColumn,t.dataRow,e,s]},le={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:t,pixelDimensions:e,baseSize:s,sprite:i,sizeRatio:r})=>{const n=Math.max(s*i.width/i.height,s),o=i.sdfDecodeCoeff*n*r;return[e[0],e[1],t,o]}},he={type:y.BYTE,count:1,packTessellation:({angle:t})=>t};function pe(t,e,s,i,r,n,o){Oe=0;const a=(i-s)*n,c=r&&r.length,u=c?(r[0]-s)*n:a;let l,h,p,f,d,m=fe(e,s,0,0,u,n,!0);if(m&&m.next!==m.prev){if(c&&(m=function(t,e,s,i,r,n){const o=new Array;for(let r=0,a=i.length;r<a;r++){const c=fe(t,e,0,i[r]*n,r<a-1?i[r+1]*n:s*n,n,!1);c===c.next&&(c.steiner=!0),o.push(ke(c))}o.sort(Ae);for(const t of o)r=Se(t,r);return r}(e,s,i,r,m,n)),a>80*n){l=p=e[0+s*n],h=f=e[1+s*n];for(let t=n;t<u;t+=n){const i=e[t+s*n],r=e[t+1+s*n];l=Math.min(l,i),h=Math.min(h,r),p=Math.max(p,i),f=Math.max(f,r)}d=Math.max(p-l,f-h),d=0!==d?1/d:0}me(m,t,n,l,h,d,o,0)}}function fe(t,e,s,i,r,n,o){let a;if(o===function(t,e,s,i,r,n){let o=0;for(let s=i,a=r-n;s<r;s+=n)o+=(t[a+e*n]-t[s+e*n])*(t[s+1+e*n]+t[a+1+e*n]),a=s;return o}(t,e,0,i,r,n)>0)for(let s=i;s<r;s+=n)a=ge(s+e*n,t[s+e*n],t[s+1+e*n],a);else for(let s=r-n;s>=i;s-=n)a=ge(s+e*n,t[s+e*n],t[s+1+e*n],a);return a&&Ee(a,a.next)&&(_e(a),a=a.next),a}function de(t,e=t){if(!t)return t;let s,i=t;do{if(s=!1,i.steiner||!Ee(i,i.next)&&0!==ve(i.prev,i,i.next))i=i.next;else{if(_e(i),i=e=i.prev,i===i.next)break;s=!0}}while(s||i!==e);return e}function me(t,e,s,i,r,n,o,a){if(!t)return;!a&&n&&(t=be(t,i,r,n));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(n?ye(t,i,r,n):xe(t))e.push(u.index/s+o),e.push(t.index/s+o),e.push(l.index/s+o),_e(t),t=l.next,c=l.next;else if((t=l)===c){a?1===a?me(t=ze(t,e,s,o),e,s,i,r,n,o,2):2===a&&Ie(t,e,s,i,r,n,o):me(de(t),e,s,i,r,n,o,1);break}}}function xe(t){const e=t.prev,s=t,i=t.next;if(ve(e,s,i)>=0)return!1;let r=t.next.next;const n=r;let o=0;for(;r!==t.prev&&(0===o||r!==n);){if(o++,we(e.x,e.y,s.x,s.y,i.x,i.y,r.x,r.y)&&ve(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function ye(t,e,s,i){const r=t.prev,n=t,o=t.next;if(ve(r,n,o)>=0)return!1;const a=r.x<n.x?r.x<o.x?r.x:o.x:n.x<o.x?n.x:o.x,c=r.y<n.y?r.y<o.y?r.y:o.y:n.y<o.y?n.y:o.y,u=r.x>n.x?r.x>o.x?r.x:o.x:n.x>o.x?n.x:o.x,l=r.y>n.y?r.y>o.y?r.y:o.y:n.y>o.y?n.y:o.y,h=Me(a,c,e,s,i),p=Me(u,l,e,s,i);let f=t.prevZ,d=t.nextZ;for(;f&&f.z>=h&&d&&d.z<=p;){if(f!==t.prev&&f!==t.next&&we(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&ve(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,d!==t.prev&&d!==t.next&&we(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&ve(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;f&&f.z>=h;){if(f!==t.prev&&f!==t.next&&we(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&ve(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;d&&d.z<=p;){if(d!==t.prev&&d!==t.next&&we(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&ve(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function ge(t,e,s,i){const r=Fe.create(t,e,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function _e(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function ke(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function Se(t,e){const s=function(t,e){let s=e;const i=t.x,r=t.y;let n,o=-1/0;do{if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const t=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o){if(o=t,t===i){if(r===s.y)return s;if(r===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!n)return null;if(i===o)return n.prev;const a=n,c=n.x,u=n.y;let l,h=1/0;for(s=n.next;s!==a;)i>=s.x&&s.x>=c&&i!==s.x&&we(r<u?i:o,r,c,u,r<u?o:i,r,s.x,s.y)&&(l=Math.abs(r-s.y)/(i-s.x),(l<h||l===h&&s.x>n.x)&&Te(s,t)&&(n=s,h=l)),s=s.next;return n}(t,e);if(!s)return e;const i=De(s,t);return de(i,i.next),de(s,s.next)}function be(t,e,s,i){let r;for(;r!==t;r=r.next){if(r=r||t,null===r.z&&(r.z=Me(r.x,r.y,e,s,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,be(t,e,s,i);r.prevZ=r.prev,r.nextZ=r.next}return t.prevZ.nextZ=null,t.prevZ=null,function(t){let e,s=1;for(;;){let i,r=t;t=null,e=null;let n=0;for(;r;){n++,i=r;let o=0;for(;o<s&&i;o++)i=i.nextZ;let a=s;for(;o>0||a>0&&i;){let s;0===o?(s=i,i=i.nextZ,a--):0!==a&&i?r.z<=i.z?(s=r,r=r.nextZ,o--):(s=i,i=i.nextZ,a--):(s=r,r=r.nextZ,o--),e?e.nextZ=s:t=s,s.prevZ=e,e=s}r=i}if(e.nextZ=null,s*=2,n<2)return t}}(t)}function ve(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Pe(t,e,s,i){return!!(Ee(t,e)&&Ee(s,i)||Ee(t,i)&&Ee(s,e))||ve(t,e,s)>0!=ve(t,e,i)>0&&ve(s,i,t)>0!=ve(s,i,e)>0}function we(t,e,s,i,r,n,o,a){return(r-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(i-a)-(s-o)*(e-a)>=0&&(s-o)*(n-a)-(r-o)*(i-a)>=0}function Te(t,e){return ve(t.prev,t,t.next)<0?ve(t,e,t.next)>=0&&ve(t,t.prev,e)>=0:ve(t,e,t.prev)<0||ve(t,t.next,e)<0}function Me(t,e,s,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ee(t,e){return t.x===e.x&&t.y===e.y}function Ae(t,e){return t.x-e.x}function ze(t,e,s,i){let r=t;do{const n=r.prev,o=r.next.next;!Ee(n,o)&&Pe(n,r,r.next,o)&&Te(n,o)&&Te(o,n)&&(e.push(n.index/s+i),e.push(r.index/s+i),e.push(o.index/s+i),_e(r),_e(r.next),r=t=o),r=r.next}while(r!==t);return r}function Ie(t,e,s,i,r,n,o){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.index!==t.index&&Le(a,t)){let c=De(a,t);return a=de(a,a.next),c=de(c,c.next),me(a,e,s,i,r,n,o,0),void me(c,e,s,i,r,n,o,0)}t=t.next}a=a.next}while(a!==t)}function Le(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!function(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&Pe(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&Te(t,e)&&Te(e,t)&&function(t,e){let s=t,i=!1;const r=(t.x+e.x)/2,n=(t.y+e.y)/2;do{s.y>n!=s.next.y>n&&s.next.y!==s.y&&r<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)}function De(t,e){const s=Fe.create(t.index,t.x,t.y),i=Fe.create(e.index,e.x,e.y),r=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=r,r.prev=s,i.next=s,s.prev=i,n.next=i,i.prev=n,i}class Fe{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,s){const i=Oe<Ne.length?Ne[Oe++]:new Fe;return i.index=t,i.x=e,i.y=s,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const Ne=[];let Oe=0;for(let t=0;t<8096;t++)Ne.push(new Fe);const Ye=new _(0,0,0,1,0),Ce=new _(0,0,0,1,0);function Ge(t,e,s){let i=0;for(let r=1;r<s;r++){const s=t[2*(e+r-1)],n=t[2*(e+r-1)+1];i+=(t[2*(e+r)]-s)*(t[2*(e+r)+1]+n)}return i}function Be(t,e,s,i,r){let n=0;for(let o=s;o<i;o+=3){const s=2*(t[o]-r),i=2*(t[o+1]-r),a=2*(t[o+2]-r);n+=Math.abs((e[s]-e[a])*(e[i+1]-e[s+1])-(e[s]-e[i])*(e[a+1]-e[s+1]))}return n}function Re(t,e){const{coords:s,lengths:i}=e,r=t;let n=0;for(let t=0;t<i.length;){let e=t,o=i[t],a=Ge(s,n,o);const c=[];for(;++e<i.length;){const t=i[e],r=Ge(s,n+o,t);if(!(r>0))break;a+=r,c.push(n+o),o+=t}const u=r.length;pe(r,s,n,n+o,c,2,0);const l=Be(r,s,u,r.length,0),h=Math.abs(a);if(Math.abs((l-h)/Math.max(1e-7,h))>1e-5)return r.length=0,!1;t=e,n+=o}return!0}function Ue(t,e){if(null==t)return null;if(!function(t,e,s){let i=0;for(let e=0;e<t.lengths.length;e++){const r=t.lengths[e];for(let e=0;e<r;e++){const r=t.coords[2*(e+i)],n=t.coords[2*(e+i)+1];if(r<-128||r>s||n<-128||n>s)return!0}i+=r}return!1}(t,0,s+128))return t;Ye.setPixelMargin(e),Ye.reset(k.Polygon);let i=0;for(let e=0;e<t.lengths.length;e++){const s=t.lengths[e];let r=t.coords[2*(0+i)],n=t.coords[2*(0+i)+1];Ye.moveTo(r,n);for(let e=1;e<s;e++)r=t.coords[2*(e+i)],n=t.coords[2*(e+i)+1],Ye.lineTo(r,n);Ye.close(),i+=s}const r=Ye.result(!1);if(!r)return null;const n=[],o=[];for(const t of r){let e=0;for(const s of t)o.push(s.x),o.push(s.y),e++;n.push(e)}return new rt(n,o)}function We(t,e){Ce.setPixelMargin(e);const i=Ce,r=-e,n=s+e;let o=[],a=!1;if(!t.nextPath())return null;let c=t.pathLength(),u=!0;for(;u;){t.seekPathStart();const e=[];if(!t.pathSize)return null;i.reset(k.LineString),t.nextPoint();let s=t.x,l=t.y;if(a)i.moveTo(s,l);else{if(s<r||s>n||l<r||l>n){a=!0;continue}e.push({x:s,y:l})}let h=!1;for(;t.nextPoint();)if(s=t.x,l=t.y,a)i.lineTo(s,l);else{if(s<r||s>n||l<r||l>n){h=!0;break}e.push({x:s,y:l})}if(h)a=!0;else{if(a){const t=i.resultWithStarts();if(t)for(const e of t)o.push({...e,pathLength:c})}else o.push({line:e,start:0,pathLength:c});u=t.nextPath(),c=u?t.pathLength():0,a=!1}}return o=o.filter((t=>t.line.length>1)),0===o.length?null:o}Ye.setExtent(s),Ce.setExtent(s);class He{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}}const Xe={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:t,pack:({scaleInfo:t},{tileInfo:e})=>kt(t,e)}},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:y.UNSIGNED_BYTE,count:1},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>vt(t)},offset:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[Mt(t,16),Mt(e,16)]},normal:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[Mt(t,16),Mt(e,16)]},halfWidth:{type:y.HALF_FLOAT,count:1,pack:({width:t})=>g(.5*t)},referenceHalfWidth:{type:y.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>g(.5*t)}}};class Ve{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}}const Ze=65535;class je extends Dt{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Xe,this._currentWrite=new Ve,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Ze,textured:!1},this._tessParams=new He,this._initializeTessellator()}writeLineVertices(t,e,s){const i=this._getLines(e);null!=i&&this._writeVertices(t,s,i)}_initializeTessellator(){this._lineTessellator=new it(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const i=s??W.fromFeatureSetReaderCIM(e);i&&this._writeGeometry(t,e,i)}_writeGeometry(t,e,s,i){t.recordStart(this.instanceId,this.attributeLayout,i),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return We(t,$(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:r,_tessellationOptions:n,evaluatedMeshParams:o}=this,{width:a,capType:c,joinType:u,miterLimit:l,hasSizeVV:h}=o,p=g(.5*a);n.halfWidth=p,n.capType=Pt(c),n.joinType=wt(u),n.miterLimit=l;const f=!h;r.out=t,r.id=e.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=f&&p<i?0:1;for(const{line:t,start:e,pathLength:i}of s)n.initialDistance=e%Ze,r.pathLength=i,r.distanceOffset=Math.floor(e/Ze)*Ze,this._lineTessellator.tessellate(t,n,f)}_writeTesselatedVertex(t,e,s,i,r,n,o,a,c,u,l){const{out:h,id:p,vertexBounds:f,pathLength:d,distanceOffset:m}=this._currentWrite;return this.hasEffects&&h.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=u,this._tessParams.directionX=r,this._tessParams.directionY=n,this._tessParams.distance=l,this._tessParams.pathLength=d,this._tessParams.distanceOffset=m,this._writeVertex(h,p,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(s),this._currentWrite.indexCount+=3}}const qe=V("featurelayer-fast-triangulation-enabled");class Qe extends Dt{async loadDependencies(){await Promise.all([super.loadDependencies(),j()])}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);r&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,r),t.recordEnd())}_clip(t){return t?Ue(t,this.hasEffects?256:8):null}_writeGeometry(t,e,s){const i=s.maxLength>100,r=[],n=this.createTesselationParams(e);if(!i&&qe&&Re(r,s))return void(r.length&&this._writeVertices(t,e,s.coords,n,r));const o=function(t){const{coords:e,lengths:s}=t,{buffer:i}=Z(e,s);return i}(s);this._writeVertices(t,e,o,n)}_writeVertices(t,e,s,i,r){const n=e.getDisplayId(),o=t.vertexCount(),a=this.hasEffects;let c=0;if(r)for(const e of r){const r=s[2*e],o=s[2*e+1];a&&t.recordBounds(r,o,0,0),this._writeVertex(t,n,r,o,i),c++}else for(let e=0;e<s.length;e+=2){const r=Math.round(s[e]),o=Math.round(s[e+1]);a&&t.recordBounds(r,o,0,0),this._writeVertex(t,n,r,o,i),c++}t.indexEnsureSize(c);for(let e=0;e<c;e++)t.indexWrite(e+o)}}const Je={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:y.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};class $e extends Qe{constructor(){super(...arguments),this.vertexSpec=Je}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}}const Ke={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:t,pack:({scaleInfo:t},{tileInfo:e})=>kt(t,e)}},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>vt(t)}}};class ts extends Qe{constructor(){super(...arguments),this.vertexSpec=Ke}createTesselationParams(t){return null}}const es={createComputedParams:t=>t,optionalAttributes:Ke.optionalAttributes,attributes:{...Ke.attributes,tlbr:{count:4,type:y.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:s,width:i,height:r}=t,n=s.x+e,o=s.y+e;return[n,o,n+i,o+r]}},inverseRasterizationScale:{count:1,type:y.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};class ss extends ts{constructor(){super(...arguments),this.vertexSpec=es}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);if(!r)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,r),t.recordEnd()}}function is(t){const{sprite:e,aspectRatio:s,scaleProportionally:i}=t,r=g(t.height),n=r>0?r:e.height;let o=r*s;return o<=0?o=e.width:i&&(o*=e.width/e.height),{width:o,height:n}}function rs(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return bt([[b,e],[v,s]])}const ns={createComputedParams:t=>t,optionalAttributes:es.optionalAttributes,attributes:{...es.attributes,bitset:{count:1,type:y.UNSIGNED_BYTE,pack:rs},width:{count:1,type:y.HALF_FLOAT,pack:t=>is(t).width},height:{count:1,type:y.HALF_FLOAT,pack:t=>is(t).height},offset:{count:2,type:y.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[g(t),-g(e)]},scale:{count:2,type:y.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:y.UNSIGNED_BYTE,pack:({angle:t})=>S(t)}}};class os extends ss{constructor(){super(...arguments),this.vertexSpec=ns}}const as={createComputedParams:t=>t,optionalAttributes:Xe.optionalAttributes,attributes:{...Xe.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>vt(t)}}},cs={createComputedParams:t=>t,optionalAttributes:Xe.optionalAttributes,attributes:{...Xe.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>bt([[P,!0],[w,t.outlineUsesColorVV]])},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>vt(t)}}};class us extends je{constructor(){super(...arguments),this.vertexSpec=cs}}class ls extends ts{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=as,this._lineMeshWriter=this._createOutlineWriter(t,e,s,i)}_createOutlineWriter(t,e,s,i){return new us(t,e,s,i)}_write(t,e){const s=this.evaluatedMeshParams.effects,i=this.evaluatedMeshParams.outlineEffects;if(s?.length||i?.length){if(s?.length){const i=this.getEffectCursor(t,e,s);if(i){let s;for(;s=i?.next();)s.invertY(),this._writeFill(t,e,s)}}else this._writeFill(t,e);if(i?.length){const s=this.getEffectCursor(t,e,i);if(s){let i;for(;i=s?.next();)i.invertY(),this._writeOutline(t,e,i)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const s=e.readGeometryForDisplay(),i=this._clip(s);i&&(this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,W.fromOptimizedCIM(i,"esriGeometryPolyline"),e))}_writeFill(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);r&&this._writeGeometry(t,e,r)}_writeOutline(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(i);r&&this._lineMeshWriter.writeLineVertices(t,W.fromOptimizedCIM(r,"esriGeometryPolyline"),e)}_clip(t){return t?Ue(t,$(this.evaluatedMeshParams)):null}get effectInfos(){return[...this._evaluator.inputMeshParams.effects?.effectInfos??[],...this._evaluator.inputMeshParams.outlineEffects?.effectInfos??[]]}write(t,e,s,i,r){this.ensurePacked(e,s,i),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}}const hs=ns,ps=cs,fs={createComputedParams:t=>t,optionalAttributes:hs.optionalAttributes,attributes:{...hs.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>rs(t)},aux1:{count:1,type:y.HALF_FLOAT,pack:t=>is(t).width},aux2:{count:1,type:y.HALF_FLOAT,pack:t=>is(t).height},aux3:{count:2,type:y.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[g(t),g(e)]},aux4:{count:2,type:y.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*T,e*T]}}},ds={createComputedParams:t=>t,optionalAttributes:hs.optionalAttributes,attributes:{...hs.attributes,color:ps.attributes.color,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>bt([[P,!0]])},aux1:{count:1,type:y.HALF_FLOAT,pack:t=>g(.5*t.width)},aux2:{count:1,type:y.HALF_FLOAT,pack:t=>g(.5*t.referenceWidth)},aux3:{count:2,type:y.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:y.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*T+M,e*T+M]}}};class ms extends us{constructor(){super(...arguments),this.vertexSpec=ds}}class xs extends ls{constructor(){super(...arguments),this.vertexSpec=fs}_createOutlineWriter(t,e,s,i){return new ms(t,e,s,i)}write(t,e,s,i,r){this.ensurePacked(e,s,i);const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}class ys{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===O.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}}class gs extends ys{constructor(t,e,s,i){super(e,s),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(i),this.rotationMatrix01=-Math.sin(i),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:r,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this;t.forEachVertex(((t,e)=>{const s=t*n+e*o,i=t*a+e*c;r.xmin=Math.min(r.xmin,s),r.ymin=Math.min(r.ymin,i),r.xmax=Math.max(r.xmax,s),r.ymax=Math.max(r.ymax,i)})),this.center=[(r.xmin+r.xmax)/2,(r.ymin+r.ymax)/2]}}class _s extends gs{constructor(t,e,s,i){super(t,e,s,i),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:s,rotationMatrix01:i,bounds:r}=this,{xmin:n,xmax:o}=r;return[(t*s+e*i-n)/(o-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,xmax:i}=e;return[g(t)/(i-s),0]}}class ks extends gs{constructor(t,e,s,i){super(t,e,s,i),this.method="rectangular"}getRelativePosition(t,e){const{bounds:s,center:i,rotationMatrix00:r,rotationMatrix01:n,rotationMatrix10:o,rotationMatrix11:a}=this,c=t*o+e*a,u=t*r+e*n-i[0],l=c-i[1];return[u*(2/(s.xmax-s.xmin)),-l*(2/(s.ymax-s.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,ymin:i,xmax:r,ymax:n}=e;return[g(2*t)/(r-s),g(2*t)/(n-i)]}}class Ss extends gs{constructor(t,e,s){super(t,e,s,0),this.method="circular";const{xmin:i,xmax:r,ymin:n,ymax:o}=this.bounds,a=r-i,c=o-n;this.radius=Math.sqrt(a*a+c*c)/2}getRelativePosition(t,e){const{center:s,radius:i}=this;return[(t-s[0])/i,-(e-s[1])/i]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[g(t)/this.radius,0]}}function bs(t,e){if(null==t)return null;const s=C(e.angle),i=e.gradientSize,r=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new _s(t,i,r,s);case"rectangular":return new ks(t,i,r,s);case"circular":return new Ss(t,i,r);default:return h.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper").errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const vs={createComputedParams:t=>t,optionalAttributes:Ke.optionalAttributes,attributes:{...Ke.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let s=0;return t===O.Absolute&&(s|=St(m.isAbsolute)),"discrete"===e.toLowerCase()&&(s|=St(m.isDiscrete)),s}},tlbr:{count:4,type:y.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:s,width:i,height:n}=t,o=s.x+e+r,a=s.y+e;return[o,a,o+i-2*r,a+n]}},relativePosition:{count:2,type:y.HALF_FLOAT,packTessellation:({gradientStats:t},e,s,i)=>t?.getRelativePosition(s,i)??[0,0]},relativeGradientSize:{count:2,type:y.HALF_FLOAT,packTessellation:({gradientStats:t})=>t?.relativeSize??[1,1]},gradientMethod:{count:1,type:y.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return d.rectangular;case"circular":return d.circular;default:return d.linear}}}}};class Ps extends Qe{constructor(){super(...arguments),this.vertexSpec=vs}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:bs(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,s){const i=s?.asOptimized()??e.readGeometryForDisplay();this._unclippedGeometry=i;const r=this._clip(i);if(!r)return void(this._unclippedGeometry=null);const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,r),this._unclippedGeometry=null,t.recordEnd()}}const ws={optionalAttributes:es.optionalAttributes,createComputedParams:t=>t,attributes:{...es.attributes,...as.attributes}},Ts={optionalAttributes:es.optionalAttributes,createComputedParams:t=>t,attributes:{...es.attributes,...cs.attributes}};class Ms extends us{constructor(){super(...arguments),this.vertexSpec=Ts}}class Es extends ls{constructor(){super(...arguments),this.vertexSpec=ws}_createOutlineWriter(t,e,s,i){return new Ms(t,e,s,i)}write(t,e,s,i,r){this.ensurePacked(e,s,i);const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const As={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},offset:{type:y.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class zs extends Dt{constructor(){super(...arguments),this.vertexSpec=As}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if("esriGeometryPoint"===e.geometryType){const i=e.readXForDisplay(),r=e.readYForDisplay();this._writeQuad(t,s,i,r)}else if("esriGeometryMultipoint"===e.geometryType){const i=e.readGeometryForDisplay();i?.forEachVertex(((e,i)=>{e>=0&&e<=512&&i>=0&&i<=512&&this._writeQuad(t,s,e,i)}))}t.recordEnd()}_writeQuad(t,e,s,i){const r=t.vertexCount();this._writeVertex(t,e,s,i),t.indexWrite(r+0),t.indexWrite(r+1),t.indexWrite(r+2),t.indexWrite(r+1),t.indexWrite(r+3),t.indexWrite(r+2)}}class Is{constructor(t){const{offsetX:e,offsetY:s,postAngle:i,fontSize:r,haloSize:n,outlineSize:o,scaleFactor:a,transforms:c}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=i,this.fontSize=Math.min(r,96),this.haloSize=n??0,this.outlineSize=o??0,this.transforms=c,c&&c.infos.length>1){const t=st(r,i,!1,e,s,c,!1);this.fontSize=Math.min(t.size,96);const n=t.size/r;this.haloSize*=n,this.outlineSize*=n,this.postAngle=t.rotation,this.offsetX=t.offsetX,this.offsetY=t.offsetY}a&&(this.fontSize*=a,this.offsetX*=a,this.offsetY*=a)}}const Ls=28,Ds=[4,4],Fs=[16,4],Ns={topLeft:Fs,topRight:Fs,bottomLeft:Fs,bottomRight:Fs},Os=[4,2],Ys=[4,6],Cs={topLeft:Os,topRight:Os,bottomLeft:Ys,bottomRight:Ys},Gs={topLeft:Os,topRight:Ys,bottomLeft:Os,bottomRight:Ys},Bs={topLeft:Ys,topRight:Ys,bottomLeft:Ds,bottomRight:Ds},Rs={topLeft:Ds,topRight:Ds,bottomLeft:Ys,bottomRight:Ys},Us={topLeft:Ys,topRight:Ds,bottomLeft:Ys,bottomRight:Ds},Ws={topLeft:Ds,topRight:Ys,bottomLeft:Ds,bottomRight:Ys},Hs={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:t,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||28]},clipAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Vs(t||0)},referenceSymbol:{type:y.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const s=t.isLineLabel||!t.referenceBounds,i=tt(s?"center":e.horizontalAlignment),r=et(s?"middle":e.verticalAlignment),{offsetX:n,offsetY:o,size:a}=s?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[g(n),-g(o),Math.round(g(a)),i+1<<2|r+1]}},visibility:{type:y.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>bt([[E,t],[A,!!e]])},offset:{type:y.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:r}=t;return[i,r,e,s]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:i,topRight:r}=t;return[i,r,e,s]}}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontAndReferenceSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>[Math.round(g(t)),Math.round(g(e??t))]},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>vt(t)},haloColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>vt(t)},outlineAndHaloSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(g(t)),Math.round(g(e))]}}};class Xs extends Dt{constructor(){super(...arguments),this.vertexSpec=Hs,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Is(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,s){const i=this._getShaping();if(!i)return;const r=e.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(t,e,i,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(t,r,s.x,s.y,i,0);if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[n,o]=s.coords;return this._writeGlyphs(t,r,n,o,i,0)}if("esriGeometryMultipoint"===e.geometryType){const s=e.readGeometryForDisplay();return void s?.forEachVertex(((e,s)=>this._writeGlyphs(t,r,e,s,i,0)))}const n=e.readXForDisplay(),o=e.readYForDisplay();return this._writeGlyphs(t,r,n,o,i,0)}_writePlacedTextMarkers(t,e,s,i){const r=i??W.fromFeatureSetReaderCIM(e);if(!r)return;const n=_t.getPlacement(r,-1,this.evaluatedMeshParams.placement,g(1),t.id,At());if(!n)return;const o=e.getDisplayId();let a=n.next();for(;null!=a;){const e=a.tx,i=-a.ty,r=-a.getAngle();this._writeGlyphs(t,o,e,i,s,r),a=n.next()}}_getShaping(t){const e=this._textMeshTransformProps,s=this.evaluatedMeshParams;if(!s.glyphs?.glyphs.length)return null;const i=g(e.fontSize),r=g(e.offsetX),u=g(e.offsetY),l=G(g(s.lineWidth),o,n),h=a*G(s.lineHeightRatio,.25,4);return K(s.glyphs,{scale:i/c,angle:e.postAngle,xOffset:r,yOffset:u,horizontalAlignment:s.horizontalAlignment,verticalAlignment:t||s.verticalAlignment,maxLineWidth:l,lineHeight:h,decoration:s.decoration,borderLineSizePx:g(s.boxBorderLineSize),hasBackground:!!s.boxBackgroundColor,useCIMAngleBehavior:s.useCIMAngleBehavior})}_writeGlyphs(t,e,s,i,r,n,o,a,c=!0){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,h=g(l.fontSize),p=l.haloSize,f=l.outlineSize,d=g(l.offsetX),m=g(l.offsetY),[x,y]=kt(u.scaleInfo,this.getTileInfo());0!==n&&r.setRotation(n);const _=r.bounds,k=s+_.x+d,S=i+_.y-m,b=2*(u.minPixelBuffer?u.minPixelBuffer/h:1),v=Math.max(_.width,_.height)*b;r.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,r.glyphs[0].textureBinding),c&&t.recordBounds(k,S,v,v),this._writeTextBox(t,e,s,i,r.textBox,o,a),t.recordEnd());for(const n of r.glyphs){t.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),c&&t.recordBounds(k,S,v,v);const{texcoords:r,offsets:l}=n;this._writeQuad(t,e,s,i,{texcoords:r,offsets:l,fontSize:h,haloSize:p,outlineSize:f,color:vt(u.color),isBackground:!1,referenceBounds:o,minZoom:x,maxZoom:y,...a}),t.recordEnd()}0!==n&&r.setRotation(-n)}_writeTextBox(t,e,s,i,r,n,o){const a=this.evaluatedMeshParams,{fontSize:c,haloSize:u,outlineSize:l}=this._textMeshTransformProps,{boxBackgroundColor:h,boxBorderLineColor:p}=a,f={isBackground:!0,fontSize:c,haloSize:u,outlineSize:l,referenceBounds:n,...o};h&&(this._writeQuad(t,e,s,i,{texcoords:Ns,offsets:r.main,color:vt(h),...f}),p||(this._writeQuad(t,e,s,i,{texcoords:Bs,offsets:r.top,color:vt(h),...f}),this._writeQuad(t,e,s,i,{texcoords:Rs,offsets:r.bot,color:vt(h),...f}),this._writeQuad(t,e,s,i,{texcoords:Us,offsets:r.left,color:vt(h),...f}),this._writeQuad(t,e,s,i,{texcoords:Ws,offsets:r.right,color:vt(h),...f}))),p&&(this._writeQuad(t,e,s,i,{texcoords:Cs,offsets:r.top,color:vt(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Cs,offsets:r.bot,color:vt(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Gs,offsets:r.left,color:vt(p),...f}),this._writeQuad(t,e,s,i,{texcoords:Gs,offsets:r.right,color:vt(p),...f}))}_writeQuad(t,e,s,i,r){const n=t.vertexCount();this._writeVertex(t,e,s,i,r),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}const Vs=t=>Math.round(t*(254/360)),Zs={createComputedParams:t=>t,optionalAttributes:Xe.optionalAttributes,attributes:{...Xe.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:s})=>bt([[x.isAlongLine,"alongline"===t.toLowerCase()],[x.isAbsoluteSize,e===O.Absolute],[x.isDiscrete,"discrete"===s.toLowerCase()]])},tlbr:{type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:s,width:i,height:n}=t,o=s.x+e+r,a=s.y+e;return[o,a,o+i-2*r,a+n]}},accumulatedDistance:{type:y.HALF_FLOAT,count:1,packTessellation:({distance:t,pathLength:e,distanceOffset:s})=>(s+t)/e},gradientSize:{type:y.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===O.Relative?t/100:g(t)},totalLength:{type:y.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};class js extends je{get _preventEffectClipping(){return!0}constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=Zs,this._tessellationOptions.textured=!0}_write(t,e,s){const i=s??W.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:r}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,r?.textureBinding)}}const qs={createComputedParams:t=>t,optionalAttributes:Xe.optionalAttributes,attributes:{...Xe.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>bt([[v,t],[z,e],[I,s]])},tlbr:{type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:s,width:i,height:r}=t,n=s.x+e,o=s.y+e;return[n,o,n+i,o+r]}},accumulatedDistance:{type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:y.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>g(t)},capType:{type:y.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case L.Butt:case"butt":return 0;case L.Square:case"square":return 1;case L.Round:case"round":return 2;default:return 0}}}}};class Qs extends je{constructor(t,e,s,i){super(t,e,s,i),this.vertexSpec=qs,this._tessellationOptions.textured=!0}_write(t,e,s){const i=s??W.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:r}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,r?.textureBinding)}}class Js{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const e=new Js(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:s,width:i,height:r,angle:n,alignment:o,outlineSize:a,referenceSize:c,sprite:u,overrideOutlineColor:l}=t;return e.rawWidth=g(i),e.rawHeight=g(r),e.angle=n,e.alignment=o,e.outlineSize=g(a),e.referenceSize=g(c),e.overrideOutlineColor=l,e.offsetX=g(t.offsetX),e.offsetY=g(t.offsetY),"simple"!==s||u.sdf||(e.rawWidth=u.width,e.rawHeight=u.height),e._computeSize(t,!1),e}static fromComplexMeshParams(t){const e=new Js(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:s,transforms:i,size:r,scaleX:n,anchorX:o,anchorY:a,angle:c,colorLocked:u,frameHeight:l,widthRatio:h,offsetX:p,offsetY:f,outlineSize:d,referenceSize:m,scaleFactor:x,sizeRatio:y,isAbsoluteAnchorPoint:_,rotateClockwise:k,scaleSymbolsProportionally:S,sprite:b}=t;if(i&&i.infos.length>0){const t=st(r,c,k,p,f,i);r=t.size,c=t.rotation,p=t.offsetX,f=t.offsetY,k=!1}x&&(r*=x,p*=x,f*=x);const v=n*(b.width/b.height);e.alignment=s,e.rawHeight=g(r),e.rawWidth=e.rawHeight*v,e.referenceSize=g(m),e.sizeRatio=y,e.sdfDecodeCoeff=(b.sdfDecodeCoeff??1)*y,e.angle=c,e.rotateClockwise=k,e.anchorX=o,e.anchorY=a,e.offsetX=g(p),e.offsetY=g(f),_&&r&&(b.sdf?e.anchorX=o/(r*h):e.anchorX=o/(r*v),e.anchorY=a/r);const P=S&&l?r/l:1;return e.outlineSize=0===d||isNaN(d)?0:g(d)*P,e.scaleSymbolsProportionally=S,e.colorLocked=u,e._computeSize(t,!0),e}constructor(t,e,s,i,r,n,o){this.sprite=t,this.color=e,this.outlineColor=s,this.minPixelBuffer=i,this.placement=r,this.scaleInfo=n,this.effects=o,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Y.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,s){const{sprite:i,hasSizeVV:r}=t,n=!!i.sdf,o=i.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:u,outlineSize:l}=this,h=i.rect;let p=a*u,f=c*u,d=0,m=0;if(n){const t=1/(1-o);if(p*=t,f*=t,r)this.computedWidth=p,this.computedHeight=f;else{const t=s&&a>c?p:a,e=c,r=l+2;this.computedWidth=Math.min(t+r,p),this.computedHeight=Math.min(e+r,f);const n=Math.max(i.width,i.height)/Math.max(p,f);d=(this.computedWidth-p)*n,m=(this.computedHeight-f)*n}}else this.computedWidth=p*(h.width/i.width),this.computedHeight=f*(h.height/i.height),d=2*e,m=2*e;const x=h.x+e-d/2,y=h.y+e-m/2,g=x+i.width+d,_=y+i.height+m;this.texXmin=$s(x),this.texYmin=$s(y),this.texXmax=Ks(g),this.texYmax=Ks(_),this.computedWidth*=(this.texXmax-this.texXmin)/(g-x),this.computedHeight*=(this.texYmax-this.texYmin)/(_-y),this.anchorX*=p/this.computedWidth,this.anchorY*=f/this.computedHeight}}function $s(t,e=1e-7){const s=Math.ceil(t);return s-t<e?s:Math.floor(t)}function Ks(t,e=1e-7){const s=Math.floor(t);return t-s<e?s:Math.ceil(t)}const ti=128/Math.PI,ei={createComputedParams:t=>Js.from(t),optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:t,pack:({scaleInfo:t},{tileInfo:e})=>kt(t,e)}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:i,colorLocked:r})=>{let n=0;return t.sdf&&(n|=St(p.bitset.isSDF)),e===Y.MAP&&(n|=St(p.bitset.isMapAligned)),s&&(n|=St(p.bitset.scaleSymbolsProportionally)),i&&(n|=St(p.bitset.overrideOutlineColor)),r&&(n|=St(p.bitset.colorLocked)),n}},offset:{type:y.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:i,anchorY:r,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=function(t,e,s,i,r=!1){const n=ct(),o=r?1:-1;return nt(n),(e||s)&&ot(n,n,[e,-s]),i&&at(n,n,.017453292519944444*o*-i),n}(0,n,o,-t,a),u=-(.5+i)*e,l=-(.5-r)*s,h=[u,l],p=[u+e,l],f=[u,l+s],d=[u+e,l+s];return ut(h,h,c),ut(p,p,c),ut(f,f,c),ut(d,d,c),[h,p,f,d]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:i})=>[[e,i],[t,i],[e,s],[t,s]]}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>vt(t)},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>vt(t)},sizing:{type:y.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:i})=>[Tt(Math.max(t,e),128),Tt(s,128),Tt(i,128),0]},placementAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>{return e=t*ti,e%=256,Math.abs(e>=0?e:e+256);var e}},sdfDecodeCoeff:{type:y.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class si extends Dt{constructor(){super(...arguments),this.vertexSpec=ei}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,s){const i=this.evaluatedMeshParams.sprite?.textureBinding,r=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,i);const n=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(this.evaluatedMeshParams.computedWidth,n),a=Math.max(this.evaluatedMeshParams.computedHeight,n),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,l=this.evaluatedMeshParams.offsetX+c,h=-this.evaluatedMeshParams.offsetY+u;if(null!=this.evaluatedMeshParams.placement){let i=null;if(null!=s){const t=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(i=X(s,2*t,!1),null===i)return}this._writePlacedMarkers(t,e,i,o,a)}else if(s?.nextPath()){s.nextPoint();const e=s.x,i=s.y;t.recordBounds(e+l,i+h,o,a),this._writeQuad(t,r,e,i)}else if("esriGeometryPolygon"===e.geometryType){const s=e.readCentroidForDisplay();if(!s)return;const[i,n]=s.coords;t.recordBounds(i+l,n+h,o,a),this._writeQuad(t,r,i,n)}else if("esriGeometryPoint"===e.geometryType){const s=e.readXForDisplay(),i=e.readYForDisplay();t.recordBounds(s+l,i+h,o,a),this._writeQuad(t,r,s,i)}else{const s=e.readGeometryForDisplay();s?.forEachVertex(((e,s)=>{t.recordBounds(e+l,s+h,o,a),Math.abs(e)>lt||Math.abs(s)>lt||this._writeQuad(t,r,e,s)}))}t.recordEnd()}_writePlacedMarkers(t,e,s,i,r){const n=s??W.fromFeatureSetReaderCIM(e);if(!n)return;const o=_t.getPlacement(n,-1,this.evaluatedMeshParams.placement,g(1),t.id,At());if(!o)return;const a=e.getDisplayId();let c=o.next();const u=this.evaluatedMeshParams.offsetX,l=-this.evaluatedMeshParams.offsetY;for(;null!=c;){const e=c.tx,s=-c.ty;if(Math.abs(e)>lt||Math.abs(s)>lt){c=o.next();continue}const n=-c.getAngle();t.recordBounds(e+u,s+l,i,r),this._writeQuad(t,a,e,s,n),c=o.next()}}_writeQuad(t,e,s,i,r){const n=t.vertexCount(),o=null==r?null:{placementAngle:r};this._writeVertex(t,e,s,i,o),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}const ii={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:y.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=g(t),s=-e/2,i=-e/2;return[[s,i],[s+e,i],[s,i+e],[s+e,i+e]]}}},texCoords:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:y.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:y.UNSIGNED_BYTE,count:1,pack:({size:t})=>g(t)},zoomRange:{type:y.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>kt(t,e)}}};class ri extends Dt{constructor(){super(...arguments),this.vertexSpec=ii}_write(t,e){const s=e.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,r=Math.max(g(this.evaluatedMeshParams.size),i);let n,o;if("esriGeometryPoint"===e.geometryType)n=e.readXForDisplay(),o=e.readYForDisplay();else{const t=e.readCentroidForDisplay();if(!t)return;n=t?.coords[0],o=t?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,o,r,r);const a=t.vertexCount();this._writeVertex(t,s,n,o),t.indexWrite(a+0),t.indexWrite(a+1),t.indexWrite(a+2),t.indexWrite(a+1),t.indexWrite(a+3),t.indexWrite(a+2),t.recordEnd()}}export{Ft as A,Wt as B,_t as C,Xt as D,Ut as E,xt as F,Vt as G,Nt as H,Ht as I,Zt as J,zs as K,He as L,js as M,Qs as N,je as O,ri as P,si as Q,xs as R,Es as S,Xs as T,ls as U,Ps as V,ss as W,os as X,$e as Y,ts as Z,dt as _,he as a,ue as b,re as c,At as d,ee as e,se as f,mt as g,te as h,ie as i,We as j,Pt as k,Kt as l,wt as m,Jt as n,oe as o,ne as p,$t as q,Re as r,le as s,ce as t,ae as u,Qt as v,kt as w,Ls as x,vt as y,qt as z};
