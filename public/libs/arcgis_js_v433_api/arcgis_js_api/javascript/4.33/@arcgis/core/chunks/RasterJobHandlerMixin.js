/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import t from"../core/Error.js";import{open as n}from"../core/workers/workers.js";import a from"../layers/support/PixelBlock.js";import{c as i}from"./vectorFieldUtils.js";import{n as s}from"./rasterRendererHelper.js";import{c as l}from"./dataUtils.js";class c{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await n("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:e.pixelBlock.toJSON(),type:e.dataType},r);return o?new a(o):null}computeStatisticsHistograms(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");return this._workerThread.invoke("computeStatisticsHistograms",{pixelBlock:e.pixelBlock.toJSON()},r)}async decode(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o=await this._workerThread.invoke("decode",e,r);return o?new a(o):null}async symbolize(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o={extent:e.extent?.toJSON(),pixelBlock:e.pixelBlock?.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},n=await this._workerThread.invoke("symbolize",o,r);return n?new a(n):null}async updateSymbolizer(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o=e?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:o},r))}async updateRasterFunction(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:e.toJSON()},r))}async process(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o=await this._workerThread.invoke("process",{extent:e.extent?.toJSON(),primaryPixelSizes:e.primaryPixelSizes?.map((e=>null!=e?e.toJSON():null)),primaryPixelBlocks:e.primaryPixelBlocks.map((e=>null!=e?e.toJSON():null)),primaryRasterIds:e.primaryRasterIds},r);return o?new a(o):null}async stretch(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const o={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},n=await this._workerThread.invoke("stretch",o,r);return n?new a(n):null}async split(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const o={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel,useBilinear:e.useBilinear},n=await this._workerThread.invoke("split",o,r);return n&&n.forEach(((e,r)=>{n.set(r,e?a.fromJSON(e):null)})),n}async clipTile(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const o={...e,pixelBlock:e.pixelBlock.toJSON()},n=await this._workerThread.invoke("clipTile",o,r);return n?a.fromJSON(n):null}async estimateStatisticsHistograms(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const o={srcPixelBlock:e.pixelBlock.toJSON()};return await this._workerThread.invoke("estimateStatisticsHistograms",o,r)}async mosaicAndTransform(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");if(!e?.srcPixelBlocks?.length)return{pixelBlock:null};const o={...e,srcPixelBlocks:e.srcPixelBlocks.map((e=>null!=e?e.toJSON():null))},n=await this._workerThread.invoke("mosaicAndTransform",o,r);return{pixelBlock:n.pixelBlock?new a(n.pixelBlock):null,localNorthDirections:n.localNorthDirections}}async createFlowMesh(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o={buffer:e.flowData.data.buffer,maskBuffer:e.flowData.mask.buffer,width:e.flowData.width,height:e.flowData.height},{meshType:n,simulationSettings:a}=e,i=await this._workerThread.invoke("createFlowMesh",{meshType:n,flowData:o,simulationSettings:a},{...r,transferList:[o.buffer,o.maskBuffer]});return{vertexData:new Float32Array(i.vertexBuffer),indexData:new Uint32Array(i.indexBuffer)}}getProjectionOffsetGrid(e,r){if(!this._workerThread)throw new t("raster-jobhandler:no-connection","no available worker connection");const o=null!=e.datumTransformation?e.datumTransformation.steps.map((e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse}))):null,n=null!=e.rasterTransform?e.rasterTransform.toJSON():null,a={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:o,rasterTransform:n,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",a,r)}}const d=t=>{let n=class extends t{constructor(){super(...arguments),this._rasterJobHandlerConfig={instance:null,refCount:0,connectionPromise:null}}get _rasterJobHandler(){return this._rasterJobHandlerConfig.instance}increaseRasterJobHandlerUsage(){this._rasterJobHandlerConfig.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandlerConfig.refCount--,this._rasterJobHandlerConfig.refCount<=0&&this._shutdownJobHandler()}async convertVectorFieldData(e,r,o){if(null==e)return null;const t=this._rasterJobHandler;return t?t.convertVectorFieldData({pixelBlock:e,dataType:r},o):i(e,r)}async createFlowMesh(e,r){const o=this._rasterJobHandler;return o?o.createFlowMesh(e,r):l(e.meshType,e.simulationSettings,e.flowData,null!=r.signal?r.signal:(new AbortController).signal)}_initJobHandler(){const{_rasterJobHandlerConfig:e}=this;if(e.connectionPromise)return e.connectionPromise;const r=new c;return e.connectionPromise=r.initialize().then((()=>{e.instance=r,this.notifyChange("_rasterJobHandler")}),(()=>{})),e.connectionPromise}_shutdownJobHandler(){const{_rasterJobHandlerConfig:e}=this;e.instance?.destroy(),e.instance=null,e.connectionPromise=null,e.refCount=0,this.notifyChange("_rasterJobHandler"),this._cachedRendererJson=void 0}async _updateSymbolizer(e,r,o,t){const n=this._rasterJobHandlerConfig.instance;if(!n)return;const a=s({...r.toJSON(),variableName:o});JSON.stringify(this._cachedRendererJson)!==JSON.stringify(a)&&(t&&(e.rasterInfo=t),e.rendererJSON=a,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=r.toJSON())}async _symbolize(e,r){const{pixelData:o,bandIds:t,simpleStretchParams:n}=e,a=this._rasterJobHandler;if(a){const e=await a.symbolize({...o,simpleStretchParams:n,bandIds:t},r);return{extent:o.extent,pixelBlock:e}}const i=e.symbolizer.symbolize({...o,simpleStretchParams:n,bandIds:t});return{extent:o.extent,pixelBlock:i}}};return e([r({clonable:!1})],n.prototype,"_rasterJobHandler",null),e([r({clonable:!1})],n.prototype,"_cachedRendererJson",void 0),e([r({clonable:!1})],n.prototype,"_rasterJobHandlerConfig",void 0),n=e([o("esri.layers.mixins.RasterJobHandlerMixin")],n),n};export{d as R};
