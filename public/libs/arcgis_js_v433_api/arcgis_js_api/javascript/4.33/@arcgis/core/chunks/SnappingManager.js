/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import{c as i}from"./asyncUtils.js";import n from"../core/Evented.js";import"../core/lang.js";import{throwIfAborted as s,isAborted as r}from"../core/promiseUtils.js";import{watch as a,syncAndInitial as o,sync as h}from"../core/reactiveUtils.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"./Logger.js";import{subclass as d}from"../core/accessorSupport/decorators/subclass.js";import{project as p,initializeProjection as l}from"./projectionUtils.js";import{d as u,b as f}from"./elevationInfoUtils.js";import{g,a as _,h as E,m as S,j as m}from"./normalizedPoint.js";import{d as v}from"./Settings.js";import{a as w,L as y,I as P,P as T,R}from"./RightAngleSnappingHint.js";import C from"../views/interactive/snapping/SnappingOptions.js";import{D as x,L as j,j as L,P as N,k as M,c as D,s as b,f as F}from"./constraints.js";import{c as I,k as A,i as V,e as q,m as H}from"./vec3.js";import{c as z,b as O}from"./vec3f64.js";import{e as U,f as k,u as G}from"./vec2.js";import{f as Z,b as W,c as X}from"./screenUtils.js";import{m as B}from"./dehydratedPoint.js";import{l as J}from"./geodesicLengthMeasurementUtils.js";function K(t,e,i,n){i.projectToRenderScreen(t,$),i.projectToRenderScreen(e,tt),U(n,tt,$),k(n,n)}function Q(t,e,i,n,s=z()){const r=I(Y,t);return r[2]=u(n,r,e,i)||0,n.renderCoordsHelper.toRenderCoords(r,e,s),s}const Y=z(),$=Z(),tt=Z();class et{constructor(t,e,i,n){this.targetPoint=t,this.constraint=e,this.isDraped=i,this.domain=n}}class it extends et{constructor({targetPoint:t,objectId:e,constraint:i,isDraped:n}){super(t,i,n,w.FEATURE),this.objectId=e}}class nt extends it{constructor(t){super({...t,isDraped:!0,constraint:new x(t.edgeStart,t.edgeEnd,t.getGroundElevation)})}get hints(){return[new y(j.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class st extends it{constructor(t){super({...t,constraint:new L(t.edgeStart,t.edgeEnd)})}get hints(){return[new y(j.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class rt extends et{constructor(t,e,i,n){super(t,new N(t),n,w.ALL),this.first=e,this.second=i}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new P(this.targetPoint,this.isDraped,this.domain)]}}class at extends et{constructor({lineStart:t,lineEnd:e,targetPoint:i,isDraped:n}){super(i,new M(t,e),n,w.SELF),this._referenceLineHint=new y(j.REFERENCE_EXTENSION,t,e,n,this.domain)}get hints(){return[this._referenceLineHint,new y(j.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}class ot extends et{constructor({referenceLine:t,lineStart:e,targetPoint:i,isDraped:n}){const s=O(e),{left:r,right:a}=t;A(s,V(s,s,a),r),super(i,new M(e,g(s)),n,w.SELF),this._referenceLines=[{edge:t,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new y(j.TARGET,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new T(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map((t=>new y(j.REFERENCE,t.edge.left,t.edge.right,this.isDraped,this.domain,t.fadeLeft,t.fadeRight)))]}addReferenceLine(t){const e={edge:t,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((i=>{q(t.right,i.edge.left)&&(i.fadeLeft=!1,e.fadeRight=!1),q(t.right,i.edge.right)&&(i.fadeRight=!1,e.fadeRight=!1),q(t.left,i.edge.right)&&(i.fadeRight=!1,e.fadeLeft=!1),q(t.left,i.edge.left)&&(i.fadeLeft=!1,e.fadeLeft=!1)})),this._referenceLines.push(e)}}class ht extends et{constructor({targetPoint:t,constraint:e,previousVertex:i,otherVertex:n,otherVertexType:s,isDraped:r,selfSnappingType:a,objectId:o,domain:h}){super(t,e,r,h??w.SELF),this.previousVertex=i,this.otherVertex=n,this.otherVertexType=s,this.selfSnappingType=a??dt.None,this.objectId=o??null}get hints(){const t=this.previousVertex,e=this.otherVertexType===ct.CENTER?this.otherVertex:this.targetPoint,i=this.otherVertexType===ct.CENTER?this.targetPoint:this.otherVertex;return[new y(j.TARGET,e,i,this.isDraped,this.domain),new y(j.REFERENCE,t,e,this.isDraped,this.domain),new R(this.previousVertex,e,i,this.isDraped,this.domain)]}}var ct,dt;!function(t){t[t.NEXT=0]="NEXT",t[t.CENTER=1]="CENTER"}(ct||(ct={})),function(t){t[t.None=0]="None",t[t.LastVertex=1]="LastVertex",t[t.FirstVertex=2]="FirstVertex",t[t.ExistingEdge=3]="ExistingEdge"}(dt||(dt={}));class pt extends et{constructor({targetPoint:t,point1:e,point2:i,isDraped:n}){super(t,new D(g(H(z(),e,i,.5)),.5*G(_(e),_(i))),n,w.SELF),this._p1=e,this._p2=i}get hints(){return[new y(j.REFERENCE,this.targetPoint,this._p1,this.isDraped,this.domain),new y(j.REFERENCE,this.targetPoint,this._p2,this.isDraped,this.domain),new R(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}function lt(t,e,i,n){return"2d"===n.type?(ut.x=t[0],ut.y=t[1],ut.spatialReference=e,n.toScreen(ut)):(Q(t,e,i,n,ft),n.state.camera.projectToScreen(ft,gt),X(gt[0],gt[1]))}const ut=B(0,0,0,null),ft=z(),gt=W();let _t=class extends(n.EventedMixin(e)){constructor(t){super(t),this.options=new C,this._engineCache=new Map,this._loadTask=null,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Et.MAIN}initialize(){this.addHandles([a((()=>{const{distance:t,touchSensitivityMultiplier:e,effectiveSelfEnabled:i,effectiveFeatureEnabled:n,effectiveGridEnabled:s}=this.options;return{selfEnabled:i,featureEnabled:n,gridEnabled:"2d"===this.view.type&&s,viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,distance:t,touchSensitivityMultiplier:e}}),((t,e)=>{e&&(this.doneSnapping(),this.emit("changed")),this._loadTask?.abort(),this._loadTask=i((i=>this._updateEngines(t,e,i)))}),o),a((()=>this.options),(t=>{for(const e of this._engines)e.options=t}),h)])}destroy(){this._loadTask?.abort(),this._destroyEngines()}get updating(){return this._engines.some((t=>t.updating))||!this._loadTask?.finished}_destroyEngines(){this._engineCache.forEach((t=>t.destroy())),this._engineCache.clear(),this._engines=[]}async _updateEngines(t,e,i){if(!t.viewReady)return void this._destroyEngines();e?.viewSpatialReference!==t.viewSpatialReference&&this._destroyEngines();const n=this._engineCache,s=await Promise.allSettled([t.featureEnabled&&!n.has("feature")?this._createFeatureSnappingEngine(i):void 0,t.selfEnabled&&!n.has("self")?this._createSelfSnappingEngine(i):void 0,t.gridEnabled&&!n.has("grid")?this._createGridSnappingEngine(i):void 0]);if(i.aborted)for(const t of s)"fulfilled"===t.status&&t.value?.engine.destroy();else{for(const t of s)"fulfilled"===t.status&&t.value&&n.set(t.value.type,t.value.engine);this._engines=Array.from(n.values())}}async _createSelfSnappingEngine(t){const[{SelfSnappingEngine:e},i]=await Promise.all([import("./SelfSnappingEngine.js"),J()]);return s(t),{type:"self",engine:new e({view:this.view,options:this.options,geodesicLengthMeasurementUtils:i})}}async _createGridSnappingEngine(t){const{view:e}=this;if("2d"!==e.type)return;const{GridSnappingEngine:i}=await import("./GridSnappingEngine.js");return s(t),{type:"grid",engine:new i({view:e,options:this.options})}}async _createFeatureSnappingEngine(t){const{FeatureSnappingEngine:e}=await import("./FeatureSnappingEngine.js");s(t);const{view:i,options:n}=this,{spatialReference:r}=i;return{type:"feature",engine:new e({view:i,options:n,spatialReference:r})}}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,i=t*e;return i*i}snap(t){return function(t){return null!=t.scenePoint}(t)?this._snapMultiPoint(t):this._snapSinglePoint(t)}update(t){const{point:e,context:i}=t;this._removeVisualization();const n=this._currentMainCandidate;if(null==n)return e;const s=this._selectUpdateInput(t);if(null==s)return e;const{spatialReference:r}=i,a=p(s,r);if(null==a)return e;const{view:o}=this,{elevationInfo:h,visualizer:c}=i,d=[],l=E(a,o,h),u=n.constraint.closestTo(l);if(!this._arePointsWithinScreenThreshold(l,u,i)||!mt(n,i.drawConstraints))return this._resetSnappingState(),e;n.targetPoint=S(u),d.push(...n.hints);for(const t of this._currentOtherActiveCandidates)mt(t,i.drawConstraints)&&(t.targetPoint=S(u),d.push(...t.hints));return null!=c&&this.addHandles(c.draw(d,{spatialReference:r,elevationInfo:wt(i),view:o,selfSnappingZ:i.selfSnappingZ}),St),m(u,o,e,i)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:t,scenePoint:e}){switch(this._currentSnappedType){case Et.MAIN:return t;case Et.SCENE:return e}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Et.MAIN}_removeVisualization(){this.removeHandles(St)}async _snapSinglePoint({point:t,context:e,signal:i}){const{view:n}=this,{elevationInfo:s}=e,r=E(t,n,s),a=await this._fetchCandidates(r,w.ALL,e,i);return this._createSnapResult(r,Et.MAIN,a,n,t,e,i)}async _snapMultiPoint({point:t,scenePoint:e,context:i,signal:n}){const{view:s}=this,{coordinateHelper:r,elevationInfo:a,spatialReference:o}=i;await l(e.spatialReference,o);const h=p(e,o),c=E(h,s,a),d=await this._fetchCandidates(c,w.FEATURE,i,n);if(d.length>0){const t=await this._fetchCandidates(c,w.SELF,i,n);return this._createSnapResult(c,Et.SCENE,[...d,...t],s,h,i,n)}const u=E(t,s,a),f=await this._fetchCandidates(u,w.SELF,i,n);return this._createSnapResult(u,Et.MAIN,f,s,{z:r.hasZ()&&t.hasZ?t.z??0:void 0,m:r.hasM()&&t.hasM?t.m??0:void 0},i,n)}async _fetchCandidates(t,e,i,n){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(t,e,i,n))))).flat()}_createSnapResult(t,e,i,n,s,a,o){return{get valid(){return!r(o)},apply:()=>{const{spatialReference:r}=a,{snappedPoint:o,hints:h}=this._processCandidates(t,e,i,a);return this._removeVisualization(),null!=a.visualizer&&this.addHandles(a.visualizer.draw(h,{spatialReference:r,elevationInfo:f,view:n,selfSnappingZ:a.selfSnappingZ}),St),m(o,n,s,a)}}}_processCandidates(t,e,i,n){if(i.length<1)return this.doneSnapping(),{snappedPoint:t,hints:[]};this._currentSnappedType!==e&&this._resetSnappingState(),b(t,i);const s=this._currentMainCandidate;if(null!=s){const o=(a=i,(r=s)instanceof rt?vt(a,r.first)>=0&&vt(a,r.second)>=0?0:-1:vt(a,r));if(o>=0){if(!(i[o]instanceof rt))return this._intersectWithOtherCandidates(o,i,t,e,n);if(this._arePointsWithinScreenThreshold(t,s.targetPoint,n))return this._updateSnappingCandidate(s,e,i,n)}}var r,a;return this._intersectWithOtherCandidates(0,i,t,e,n)}_intersectWithOtherCandidates(t,e,i,n,s){const{coordinateHelper:r}=s,a=e[t],o=[];for(let n=0;n<e.length;++n){if(n===t)continue;const s=e[n],h=a.constraint.intersect(s.constraint);if(h)for(const t of h.closestPoints(a.targetPoint))o.push([new rt(S(t),a,s,s.isDraped),this._squaredScreenDistance(i,t,r)])}return o.length>0&&(o.sort(((t,e)=>t[1]-e[1])),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],n,e,s):mt(a,s.drawConstraints)?this._updateSnappingCandidate(a,n,e,s):{snappedPoint:i,hints:[]}}_updateSnappingCandidate(t,e,i,n){this.doneSnapping(),this._currentMainCandidate=t,this._currentSnappedType=e;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...t.hints);for(const e of i){if(t instanceof rt){if(e.constraint.equals(t.first.constraint)||e.constraint.equals(t.second.constraint))continue}else if(e.constraint.equals(t.constraint))continue;const i=e.constraint.closestTo(s);this._squaredScreenDistance(i,s,n.coordinateHelper)<v.satisfiesConstraintScreenThreshold*v.satisfiesConstraintScreenThreshold&&(e.targetPoint=s,this._currentOtherActiveCandidates.push(e),r.push(...e.hints))}return{snappedPoint:s,hints:r}}_squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(t,e,i){return this._squaredScreenDistance(t,e,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(t,e,i){return F(this._toScreen(t,i),this._toScreen(e,i))}_toScreen(t,e){return lt(t,e.spatialReference,f,this.view)}get test(){}};var Et;t([c({constructOnly:!0})],_t.prototype,"view",void 0),t([c()],_t.prototype,"options",void 0),t([c({readOnly:!0})],_t.prototype,"updating",null),t([c()],_t.prototype,"_loadTask",void 0),t([c()],_t.prototype,"_engines",void 0),t([c()],_t.prototype,"_squaredMouseProximityThreshold",null),t([c()],_t.prototype,"_squaredTouchProximityThreshold",null),_t=t([d("esri.views.interactive.snapping.SnappingManager")],_t),function(t){t[t.MAIN=0]="MAIN",t[t.SCENE=1]="SCENE"}(Et||(Et={}));const St="visualization-handle";function mt(t,e){return!e||null==e.direction&&null==e.distance||!(t instanceof nt||t instanceof st||t instanceof at||t instanceof ot||t instanceof pt)&&(!(t instanceof ht)||null==e.direction&&t.selfSnappingType===dt.LastVertex)}function vt(t,e){let i=-1;for(let n=0;n<t.length;++n)if(e.constraint.equals(t[n].constraint)){i=n;break}return i}function wt({coordinateHelper:t,elevationInfo:e}){return t.hasZ()?f:e}export{nt as D,st as E,it as F,rt as I,at as L,ct as O,ot as P,ht as R,_t as S,Q as a,dt as b,pt as c,K as r,lt as v};
