/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../request.js";import i from"../core/Accessor.js";import{B as a}from"./ByteSizeUnit.js";import r from"../core/Error.js";import{m as l}from"./handleUtils.js";import{n as s,clone as o}from"../core/lang.js";import{L as n}from"./LRUCache.js";import{P as h}from"./PooledArray.js";import{isAbortError as c,isAborted as m,onAbort as f,createAbortError as p}from"../core/promiseUtils.js";import{watch as u,initial as v}from"../core/reactiveUtils.js";import{waitTicks as d}from"../core/scheduling.js";import{objectToQuery as y}from"../core/urlUtils.js";import{property as w}from"../core/accessorSupport/decorators/property.js";import"./Logger.js";import{subclass as b}from"../core/accessorSupport/decorators/subclass.js";import{T as g}from"./TileKey.js";import{e as _}from"./memoryEstimations.js";class A{constructor(e){!function(e){if(!e?.location)throw new r("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new r("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new r("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new r("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new r("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}(e);const{location:t,data:i}=e;this.location=Object.freeze(o(t));const a=this.location.width,l=this.location.height;let n=!0,h=!0;const c=function(e,t=!1){return e<=s?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}(Math.ceil(a*l/32));let m=0;for(let e=0;e<i.length;e++){const t=e%32;i[e]?(h=!1,c[m]|=1<<t):n=!1,31===t&&++m}h?(this._availability="unavailable",this.byteSize=40):n?(this._availability="available",this.byteSize=40):(this._availability=c,this.byteSize=40+_(c))}getAvailability(e,t){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),a=i%32,r=i>>5,l=this._availability;return r<0||r>l.length?"unknown":l[r]&1<<a?"available":"unavailable"}static fromDefinition(e,i){const a=e.service.request||t,{row:l,col:s,width:o,height:n}=e,h={query:{f:"json"}};return i=i?{...h,...i}:h,a(function(e){let t;if(e.service.tileServers?.length){const i=e.service.tileServers;t=`${i&&i.length?i[e.row%i.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}else t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;const i=e.service.query;return i&&(t=`${t}?${i}`),t}(e),i).then((e=>e.data)).catch((e=>{if(422===e?.details?.httpStatus)return{location:{top:l,left:s,width:o,height:n},valid:!0,data:new Array(o*n).fill(0)};throw e})).then((e=>{if(e.location&&(e.location.top!==l||e.location.left!==s||e.location.width!==o||e.location.height!==n))throw new r("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:l,left:s,width:o,height:n}});return A.fromJSON(e)}))}static fromJSON(e){return Object.freeze(new A(e))}}function j(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}var T;function D(e,t,i){return new r("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})}let O=class extends i{static{T=this}constructor(e){super(e),this._pendingTilemapRequests={},this.request=t,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new n(2*a.MEGABYTES),this.addHandles(u((()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]}),(()=>this._initializeTilemapDefinition()),v))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,t,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const a=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return a?a.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,a){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(D(e,t,i)):this._fetchTilemap(e,t,i,a).catch((e=>e)).then((a=>{if(a instanceof A){const r=a.getAvailability(t,i);if("unavailable"===r)throw D(e,t,i);return r}if(c(a))throw a;return"unknown"}))}fetchAvailabilityUpsample(e,t,i,a,r){a.level=e,a.row=t,a.col=i;const l=this.layer.tileInfo;l.updateTileInfo(a);const s=this.fetchAvailability(e,t,i,r).catch((e=>{if(c(e))throw e;if(l.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,r);throw e}));return this._fetchAvailabilityUpsamplePrefetch(a.id,e,t,i,r,s),s}async _fetchAvailabilityUpsamplePrefetch(e,t,i,a,r,s){if(!this._prefetchingEnabled||null==e)return;const o=`prefetch-${e}`;if(this.hasHandles(o))return;const n=new AbortController;s.then((()=>n.abort()),(()=>n.abort()));let h=!1;const c=l((()=>{h||(h=!0,n.abort())}));if(this.addHandles(c,o),await d(10,n.signal).catch((()=>{})),h||(h=!0,this.removeHandles(o)),m(n))return;const f=new g(e,t,i,a),p={...r,signal:n.signal},u=this.layer.tileInfo;for(let e=0;T._prefetches.length<T._maxPrefetch&&u.upsampleTile(f);++e){const e=this.fetchAvailability(f.level,f.row,f.col,p);T._prefetches.push(e);const t=()=>{T._prefetches.removeUnordered(e)};e.then(t,t)}}static{this._maxPrefetch=4}static{this._prefetches=new h({initialSize:T._maxPrefetch})}_fetchTilemap(e,t,i,a){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new r("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l=this._tmpTilemapDefinition,s=this._tilemapFromCache(e,t,i,l);if(s)return Promise.resolve(s);const o=a?.signal;return a={...a,signal:null},new Promise(((e,t)=>{f(o,(()=>t(p())));const i=j(l);let r=this._pendingTilemapRequests[i];if(!r){r=A.fromDefinition(l,a).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>{delete this._pendingTilemapRequests[i]};this._pendingTilemapRequests[i]=r,r.then(e,e)}r.then(e,t)}))}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:y({...e.query,...i,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,a){a.level=e,a.row=t-t%this.size,a.col=i-i%this.size;const r=j(a);return this._tilemapCache.get(r)}get test(){}};e([w({constructOnly:!0})],O.prototype,"layer",void 0),e([w({constructOnly:!0})],O.prototype,"minLOD",void 0),e([w({constructOnly:!0})],O.prototype,"maxLOD",void 0),e([w({constructOnly:!0})],O.prototype,"request",void 0),e([w({constructOnly:!0})],O.prototype,"size",void 0),O=T=e([b("esri.layers.support.TilemapCache")],O);export{O as T};
