/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{x as t,y as e,p as i,z as s}from"../core/lang.js";import{L as r}from"./Logger.js";import{c as n,b as _}from"./Texture.js";import{d as a,U as u,R as h,D as f}from"./enums.js";import{f as o}from"./maybe.js";import{c}from"./memoryEstimations.js";const l=()=>r.getLogger("esri.views.webgl.BufferObject");class E{static createIndex(t,e,i){return new E(t,a.ELEMENT_ARRAY_BUFFER,e,i)}static createVertex(t,e,i){return new E(t,a.ARRAY_BUFFER,e,i)}static createUniform(t,e,i){return new E(t,a.UNIFORM_BUFFER,e,i)}static createPixelPack(t,e=u.STREAM_READ,i){const s=new E(t,a.PIXEL_PACK_BUFFER,e);return i&&s.setSize(i),s}static createPixelUnpack(t,e=u.STREAM_DRAW,i){return new E(t,a.PIXEL_UNPACK_BUFFER,e,i)}static createTransformFeedback(t,e=u.STATIC_DRAW,i){const s=new E(t,a.TRANSFORM_FEEDBACK_BUFFER,e);return s.setSize(i),s}constructor(t,e,i,s){this._context=t,this.bufferType=e,this.usage=i,this._glName=null,this._size=-1,this._indexType=void 0,t.instanceCounter.increment(h.BufferObject,this),this._glName=this._context.gl.createBuffer(),n(this._context.gl),s&&this.setData(s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get usedMemory(){if(this.bufferType===a.ELEMENT_ARRAY_BUFFER){if(this._indexType===f.UNSIGNED_INT)return 4*this._size;if(this._indexType===f.UNSIGNED_SHORT)return 2*this._size}return this._size}get _isVAOAware(){return this.bufferType===a.ELEMENT_ARRAY_BUFFER||this.bufferType===a.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(h.BufferObject,this),this._context=null):this._glName&&l().warn("Leaked WebGL buffer object")}setSize(t,e=null){if(this.bufferType===a.ELEMENT_ARRAY_BUFFER&&null!=e)switch(this._indexType=e,e){case f.UNSIGNED_SHORT:t*=2;break;case f.UNSIGNED_INT:t*=4}this._setBufferData(t)}setData(s){if(!s)return;let r=s.byteLength;this.bufferType===a.ELEMENT_ARRAY_BUFFER&&(t(s)?this._indexType=f.UNSIGNED_BYTE:e(s)?(r/=2,this._indexType=f.UNSIGNED_SHORT):i(s)&&(r/=4,this._indexType=f.UNSIGNED_INT)),this._setBufferData(r,s)}_setBufferData(t,e=null){this._size=t;const i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const s=this._context.gl;null!=e?s.bufferData(this.bufferType,e,this.usage):s.bufferData(this.bufferType,t,this.usage),n(s),this._isVAOAware&&this._context.bindVAO(i)}setSubData(t,e,i,s){if(!t)return;const r=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const{gl:_}=this._context;_.bufferSubData(this.bufferType,e*t.BYTES_PER_ELEMENT,t,i,s-i),n(_),this._isVAOAware&&this._context.bindVAO(r)}getSubData(t,e=0,i,r){if(i<0||r<0)return;const n=s(t)?t.BYTES_PER_ELEMENT:1;if(n*((i??0)+(r??0))>t.byteLength)return;e+n*(r??0)>this.usedMemory&&l().warn("Potential problem getting subdata: requested data exceeds buffer size!");const _=this._context.gl;this.bufferType===a.TRANSFORM_FEEDBACK_BUFFER?(this._context.bindBuffer(this,a.TRANSFORM_FEEDBACK_BUFFER),_.getBufferSubData(a.TRANSFORM_FEEDBACK_BUFFER,e,t,i,r),this._context.unbindBuffer(a.TRANSFORM_FEEDBACK_BUFFER)):(this._context.bindBuffer(this,a.COPY_READ_BUFFER),_.getBufferSubData(a.COPY_READ_BUFFER,e,t,i,r),this._context.unbindBuffer(a.COPY_READ_BUFFER))}async getSubDataAsync(t,e=0,i,s){await this._context.clientWaitAsync(),this.getSubData(t,e,i,s)}}const x=()=>r.getLogger("esri.views.webgl.VertexArrayObject");let d=class{constructor(t,e,i,s,r=null){this._context=t,this._locations=e,this._layout=i,this._buffers=s,this._indexBuffer=r,this._glName=null,this._initialized=!1}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}getByteLength(t){return this._buffers.get(t)?.usedMemory??0}get layout(){return this._layout}get locations(){return this._locations}get usedMemory(){return Array.from(this._buffers.values()).reduce(((t,e)=>t+e.usedMemory),this._indexBuffer?.usedMemory??0+(this._buffers.size+(this._indexBuffer?1:0))*c)}get cachedMemory(){return this.usedMemory}dispose(){this._context?(this._context.getBoundVAO()===this&&this._context.bindVAO(null),this._buffers.forEach((t=>t.dispose())),this._buffers.clear(),this._indexBuffer=o(this._indexBuffer),this.disposeVAOOnly()):(this._glName||this._buffers.size>0)&&x().warn("Leaked WebGL VAO")}disposeVAOOnly(){this._glName&&(this._context.gl.deleteVertexArray(this._glName),this._glName=null,this._context.instanceCounter.decrement(h.VertexArrayObject,this)),this._context=null}initialize(){if(this._initialized)return;const{gl:t}=this._context,e=t.createVertexArray();t.bindVertexArray(e),this._bindLayout(),t.bindVertexArray(null),this._glName=e,this._context.instanceCounter.increment(h.VertexArrayObject,this),this._initialized=!0}bind(){this.initialize(),this._context.gl.bindVertexArray(this.glName)}_bindLayout(){const{_buffers:t,_layout:e,_indexBuffer:i}=this;t||x().error("Vertex buffer dictionary is empty!");const s=this._context.gl;this._buffers.forEach(((t,i)=>{const s=e.get(i);s?_(this._context,this._locations,t,s):x().error("Vertex element descriptor is empty!")})),null!=i&&s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,i.glName)}unbind(){this.initialize(),this._context.gl.bindVertexArray(null)}};export{E as B,d as V};
