/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{a as o,s as r,c as e,f as t,n}from"./vec3.js";import{c as a}from"./vec3f64.js";import{A as i,d as s}from"./BufferView.js";import{B as c,c as d,C as l}from"./aaBoundingBox.js";import{a as f,_ as m,$ as u,k as v}from"./Matrix4PassUniform.js";import{V as h}from"./VertexAttribute.js";import{S as p}from"./ShaderOutput.js";import{c as w}from"./mat3f64.js";import{c as F}from"./mat4f64.js";import{D as M,M as V}from"./Matrix3DrawUniform.js";import{a as x,b as W,c as T}from"./Matrix4BindUniform.js";import{g as C}from"./glsl.js";import{N as R}from"./ShaderTechniqueConfiguration.js";class P{constructor(o=!1,r=!0){this.isVerticalRay=o,this.normalRequired=r}}const g=d();function b(r,e,t,n,a,s){if(!r.visible)return;const c=o(J,n,t),d=(o,r,e)=>{s(o,e,r)},l=new P(!1,e.options.normalRequired);if(r.boundingInfo){i(r.type===f.Mesh);const o=e.tolerance;j(r.boundingInfo,t,c,o,a,l,d)}else{const o=r.attributes.get(h.POSITION),e=o.indices;I(t,c,0,e.length/3,e,o.data,o.stride,a,l,d)}}const L=a();function j(o,e,t,n,a,i,s){if(null==o)return;const d=r(L,1/(f=t)[0],1/f[1],1/f[2]);var f;if(c(g,o.bbMin),l(g,o.bbMax),null!=a&&a.applyToAabb(g),U(g,e,d,n)){const{primitiveIndices:r,position:c}=o,d=r?r.length:c.indices.length/3;if(d>$){const r=o.getChildren();if(void 0!==r){for(const o of r)j(o,e,t,n,a,i,s);return}}!function(o,r,e,t,n,a,i,s,c,d,l){const f=o[0],m=o[1],u=o[2],v=r[0],h=r[1],p=r[2],{normalRequired:w}=d;for(let o=0;o<t;++o){const r=s[o],e=3*r,t=i*n[e];let d=a[t],F=a[t+1],M=a[t+2];const V=i*n[e+1];let x=a[V],W=a[V+1],T=a[V+2];const C=i*n[e+2];let R=a[C],P=a[C+1],g=a[C+2];null!=c&&([d,F,M]=c.applyToVertex(d,F,M,o),[x,W,T]=c.applyToVertex(x,W,T,o),[R,P,g]=c.applyToVertex(R,P,g,o));const b=x-d,L=W-F,j=T-M,y=R-d,O=P-F,D=g-M,I=h*D-O*p,B=p*y-D*v,H=v*O-y*h,q=b*I+L*B+j*H;if(Math.abs(q)<=G)continue;const z=f-d,N=m-F,A=u-M,k=z*I+N*B+A*H;if(q>0){if(k<0||k>q)continue}else if(k>0||k<q)continue;const U=N*j-L*A,E=A*b-j*z,$=z*L-b*N,J=v*U+h*E+p*$;if(q>0){if(J<0||k+J>q)continue}else if(J>0||k+J<q)continue;const K=(y*U+O*E+D*$)/q;K>=0&&l(K,r,w?_(b,L,j,y,O,D,S):null)}}(e,t,0,d,c.indices,c.data,c.stride,r,a,i,s)}}const S=a();function y(r,e,t,n,a,i,s,c,d){const{data:l,stride:f}=i;I(r,o(J,e,r),t,n,a,l,f,s,c,d)}function O(o,r,e,t,n,a,i,s,c,d=null,l=0){const f=o[0],m=o[1],u=o[2],v=r[0],h=r[1],p=r[2];for(let o=e;o<t;++o){const r=l+(d?d[o]:o),e=3*r,t=i*n[e],w=a[t],F=a[t+1],M=a[t+2],V=i*n[e+1],x=a[V],W=a[V+1],T=a[V+2],C=i*n[e+2],R=x-w,P=W-F,g=T-M,b=a[C]-w,L=a[C+1]-F,j=a[C+2]-M,y=h*j-L*p,O=p*b-j*v,D=v*L-b*h,I=R*y+P*O+g*D;if(Math.abs(I)<=G)continue;const B=f-w,H=m-F,q=u-M,z=B*y+H*O+q*D;if(I>0){if(z<0||z>I)continue}else if(z>0||z<I)continue;const N=H*g-P*q,A=q*R-g*B,k=B*P-R*H,U=v*N+h*A+p*k;if(I>0){if(U<0||z+U>I)continue}else if(U>0||z+U<I)continue;const E=(b*N+L*A+j*k)/I;E>=0&&c(E,r,s?_(R,P,g,b,L,j,S):null)}}function D(o,r,e,t,n,a,i,s,c,d,l,f=null,m=0){const u=o[0],v=o[1],h=o[2],p=r[0],w=r[1],F=r[2];for(let o=e;o<t;++o){const r=m+(f?f[o]:o),e=3*r,t=i*n[e],M=a[t],V=a[t+1],x=a[t+2],W=i*n[e+1],T=a[W],C=a[W+1],R=a[W+2],P=i*n[e+2],g=a[P],b=a[P+1],L=a[P+2],j=x-c,y=s/Math.sqrt(M*M+V*V+j*j),O=M+M*y,D=V+V*y,I=x+j*y,B=R-c,H=s/Math.sqrt(T*T+C*C+B*B),q=T+T*H,z=C+C*H,N=R+B*H,A=L-c,k=s/Math.sqrt(g*g+b*b+A*A),U=q-O,E=z-D,$=N-I,J=g+g*k-O,K=b+b*k-D,Q=L+A*k-I,X=w*Q-K*F,Y=F*J-Q*p,Z=p*K-J*w,oo=U*X+E*Y+$*Z;if(Math.abs(oo)<=G)continue;const ro=u-O,eo=v-D,to=h-I,no=ro*X+eo*Y+to*Z;if(oo>0){if(no<0||no>oo)continue}else if(no>0||no<oo)continue;const ao=eo*$-E*to,io=to*U-$*ro,so=ro*E-U*eo,co=p*ao+w*io+F*so;if(oo>0){if(co<0||no+co>oo)continue}else if(co>0||no+co<oo)continue;const lo=(J*ao+K*io+Q*so)/oo;lo>=0&&l(lo,r,d?_(U,E,$,J,K,Q,S):null)}}function I(t,n,a,i,s,c,d,l,f,m){const u=n,v=K,h=Math.abs(u[0]),p=Math.abs(u[1]),w=Math.abs(u[2]),F=h>=p?h>=w?0:2:p>=w?1:2,M=F,V=u[M]<0?2:1,x=(F+V)%3,W=(F+(3-V))%3,T=u[x]/u[M],C=u[W]/u[M],R=1/u[M],P=B,g=H,b=q,{normalRequired:L}=f;for(let n=a;n<i;++n){const a=3*n,i=d*s[a];r(v[0],c[i+0],c[i+1],c[i+2]);const f=d*s[a+1];r(v[1],c[f+0],c[f+1],c[f+2]);const u=d*s[a+2];r(v[2],c[u+0],c[u+1],c[u+2]),l&&(e(v[0],l.applyToVertex(v[0][0],v[0][1],v[0][2],n)),e(v[1],l.applyToVertex(v[1][0],v[1][1],v[1][2],n)),e(v[2],l.applyToVertex(v[2][0],v[2][1],v[2][2],n))),o(P,v[0],t),o(g,v[1],t),o(b,v[2],t);const h=P[x]-T*P[M],p=P[W]-C*P[M],w=g[x]-T*g[M],F=g[W]-C*g[M],V=b[x]-T*b[M],j=b[W]-C*b[M],S=V*F-j*w,y=h*j-p*V,O=w*p-F*h;if((S<0||y<0||O<0)&&(S>0||y>0||O>0))continue;const D=S+y+O;if(0===D)continue;const I=S*(R*P[M])+y*(R*g[M])+O*(R*b[M]);if(I*Math.sign(D)<0)continue;const B=I/D;B>=0&&m(B,n,L?z(v):null)}}const B=a(),H=a(),q=a();function _(o,e,a,i,s,c,d){return r(N,o,e,a),r(A,i,s,c),t(d,N,A),n(d,d),d}function z(r){return o(N,r[1],r[0]),o(A,r[2],r[0]),t(S,N,A),n(S,S),S}const N=a(),A=a();function k(o,e,t){return r(t,1/(e[0]-o[0]),1/(e[1]-o[1]),1/(e[2]-o[2]))}function U(o,r,e,t){return E(o,r,e,t,1/0)}function E(o,r,e,t,n){const a=(o[0]-t-r[0])*e[0],i=(o[3]+t-r[0])*e[0];let s=Math.min(a,i),c=Math.max(a,i);const d=(o[1]-t-r[1])*e[1],l=(o[4]+t-r[1])*e[1];if(c=Math.min(c,Math.max(d,l)),c<0)return!1;if(s=Math.max(s,Math.min(d,l)),s>c)return!1;const f=(o[2]-t-r[2])*e[2],m=(o[5]+t-r[2])*e[2];return c=Math.min(c,Math.max(f,m)),!(c<0)&&(s=Math.max(s,Math.min(f,m)),!(s>c)&&s<n)}const $=1e3,G=1e-7,J=a(),K=[a(),a(),a()];class Q{constructor(o){this.vertexBufferLayout=o}elementCount(o){return o.get(h.POSITION).indices.length}write(o,r,e,t,n,a){return m(e,t,this.vertexBufferLayout,o,r,n,a)}intersect(r,e,t,n,a,i,c){const d=this.vertexBufferLayout.createView(r).getField(h.POSITION,s);if(null==d)return;const l=o(X,i,a),f=d.count/3,m=n.options.normalRequired;!function(o,r,e,t,n,a,i,s){const c=o[0],d=o[1],l=o[2],f=r[0],m=r[1],u=r[2];for(let o=0;o<t;++o){const r=3*o,e=r+1,t=r+2,v=a*r,h=n[v],p=n[v+1],w=n[v+2],F=a*e,M=a*t,V=n[F]-h,x=n[F+1]-p,W=n[F+2]-w,T=n[M]-h,C=n[M+1]-p,R=n[M+2]-w,P=m*R-C*u,g=u*T-R*f,b=f*C-T*m,L=V*P+x*g+W*b;if(Math.abs(L)<=G)continue;const j=c-h,y=d-p,O=l-w,D=j*P+y*g+O*b;if(L>0){if(D<0||D>L)continue}else if(D>0||D<L)continue;const I=y*W-x*O,B=O*V-W*j,H=j*x-V*y,q=f*I+m*B+u*H;if(L>0){if(q<0||D+q>L)continue}else if(q>0||D+q<L)continue;const z=(T*I+C*B+R*H)/L;z>=0&&s(z,o,i?_(V,x,W,T,C,R,S):null)}}(a,l,0,f,d.typedBuffer,d.typedBufferStride,m,((o,r,e)=>{c(o,e,r)}))}}const X=a();function Y(o,r){const{attributes:e,vertex:t,varyings:n,fragment:a}=o;t.include(M,r),e.add(h.POSITION,"vec3"),n.add("vPositionWorldCameraRelative","vec3"),n.add("vPosition_view","vec3",{invariant:!0}),t.uniforms.add(new x("transformWorldFromViewTH",(o=>o.transformWorldFromViewTH)),new x("transformWorldFromViewTL",(o=>o.transformWorldFromViewTL)),new W("transformViewFromCameraRelativeRS",(o=>o.transformViewFromCameraRelativeRS)),new u("transformProjFromView",(o=>o.transformProjFromView)),new V("transformWorldFromModelRS",(o=>o.transformWorldFromModelRS)),new T("transformWorldFromModelTH",(o=>o.transformWorldFromModelTH)),new T("transformWorldFromModelTL",(o=>o.transformWorldFromModelTL))),t.code.add(C`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * position;
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`),t.code.add(C`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${r.spherical?C`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)`:C`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `),a.uniforms.add(new x("transformWorldFromViewTL",(o=>o.transformWorldFromViewTL))),t.code.add(C`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`),a.code.add(C`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`)}class Z extends R{constructor(){super(...arguments),this.transformWorldFromViewTH=a(),this.transformWorldFromViewTL=a(),this.transformViewFromCameraRelativeRS=w(),this.transformProjFromView=F()}}class oo extends R{constructor(){super(...arguments),this.transformWorldFromModelRS=w(),this.transformWorldFromModelTH=a(),this.transformWorldFromModelTL=a()}}function ro(o){o.varyings.add("linearDepth","float",{invariant:!0})}function eo(o){o.vertex.uniforms.add(new v("nearFar",(o=>o.camera.nearFar)))}function to(o){o.vertex.code.add(C`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function no(o,r){const{vertex:e}=o;switch(r.output){case p.Color:case p.ColorEmission:if(r.receiveShadows)return ro(o),void e.code.add(C`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);break;case p.Shadow:case p.ShadowHighlight:case p.ShadowExcludeHighlight:case p.ViewshedShadow:return o.include(Y,r),ro(o),eo(o),to(o),void e.code.add(C`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`)}e.code.add(C`void forwardLinearDepth() {}`)}function ao(o){to(o),o.vertex.code.add(C`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),o.vertex.code.add(C`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function io(o,r){r.hasVertexColors?(o.attributes.add(h.COLOR,"vec4"),o.varyings.add("vColor","vec4"),o.vertex.code.add(C`void forwardVertexColor() { vColor = color; }`),o.vertex.code.add(C`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):o.vertex.code.add(C`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{Q as D,no as F,P as M,ao as T,io as V,Z as a,oo as b,eo as c,y as d,U as e,ro as f,E as g,O as h,b as i,D as j,k,Y as l};
