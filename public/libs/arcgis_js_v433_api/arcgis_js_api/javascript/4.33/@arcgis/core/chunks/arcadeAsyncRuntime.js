/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{n as e,t,D as r,A as o}from"./aiServices.js";import{N as n,R as a,I as i,k as s,j as l,l as c,m as u,v as p,p as f,t as m,n as w,o as d,q as h,r as g,s as y,c as b,d as j,f as v,b as S,A as x,S as F,u as I,w as O}from"./languageUtils.js";import{a as k,A as M,F as C,r as R,b as A,c as U,d as N,e as E,f as B,g as P,h as D,i as K,j as Z}from"./arcade.js";import{A as G,E as L,e as T}from"./enum.js";import{registerFunctions as q}from"./geomasync.js";import"../core/lang.js";import z from"../geometry/Geometry.js";import W from"../geometry/SpatialReference.js";import{c as V,d as _,b as Q,a as H,i as J}from"./guards.js";import"./TimeOnly.js";import"./Logger.js";import"../config.js";import"./UnknownTimeZone.js";import"./datetime.js";import"./locale.js";import"./handleUtils.js";import"../geometry/Extent.js";import"./tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import"./MapUtils.js";import"./get.js";import"./utils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./tracking.js";import"./Warning.js";import"../geometry/Point.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObjectPool.js";import"./ObservableBase.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./events.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"../core/accessorSupport/decorators/cast.js";import"./reader.js";import"./writer.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"./persistableUrlUtils.js";import"../geometry/support/webMercatorUtils.js";import"./deepClone.js";import"../portal/Portal.js";import"../core/JSONSupport.js";import"../core/Loadable.js";import"../core/Promise.js";import"../portal/PortalGroup.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"./utils10.js";import"./commonProperties3.js";import"./ImmutableArray.js";import"./shared2.js";import"../layers/support/Field.js";import"./enumeration.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"./number.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"../geometry/Polyline.js";import"../geometry/support/jsonUtils.js";import"./featureConversionUtils.js";import"./aaBoundingBox.js";import"./OptimizedFeature.js";import"./memoryEstimations.js";import"./OptimizedGeometry.js";import"./OptimizedFeatureSet.js";import"./createFeatureId.js";import"../layers/support/FieldsIndex.js";import"../layers/support/fieldUtils.js";import"../core/sql.js";import"./constants.js";import"./timeZoneUtils.js";import"../core/sql/WhereClause.js";import"./unitConversion.js";import"./hash.js";import"./uuid.js";import"./portalUtils.js";import"./operatorsWorkerConnection.js";import"../core/workers/workers.js";import"../core/workers/Connection.js";import"./Queue.js";import"./SimpleObservable.js";import"../core/workers/RemoteClient.js";import"../intl.js";import"./date.js";import"./number2.js";import"./substitute.js";import"./messages.js";import"./utils9.js";async function Y(e,t){const r=[];for(let o=0;o<t.arguments.length;o++)r.push(await oe(e,t.arguments[o]));return r}async function X(e,t,r){return!0===t.preparsed?r(e,null,t.arguments):r(e,t,await Y(e,t))}class $ extends I{constructor(e,t){super(),this.definition=null,this.context=null,this.definition=e,this.context=t}createFunction(e){return(...t)=>{const r={spatialReference:this.context.spatialReference,console:this.context.console,lrucache:this.context.lrucache,timeZone:this.context.timeZone??null,exports:this.context.exports,libraryResolver:this.context.libraryResolver,interceptor:this.context.interceptor,services:this.context.services,abortSignal:this.context.abortSignal,localScope:{},depthCounter:{depth:e.depthCounter+1},globalScope:this.context.globalScope};if(r.depthCounter.depth>64)throw new G(e,L.MaximumCallDepth,null);return ee(this.definition,r,t,null)}}call(e,t){return re(e,t,((r,o,n)=>{const a={spatialReference:e.spatialReference,services:e.services,console:e.console,libraryResolver:e.libraryResolver,exports:e.exports,lrucache:e.lrucache,timeZone:e.timeZone??null,interceptor:e.interceptor,localScope:{},abortSignal:e.abortSignal,globalScope:e.globalScope,depthCounter:{depth:e.depthCounter.depth+1}};if(a.depthCounter.depth>64)throw new G(e,L.MaximumCallDepth,t);return ee(this.definition,a,n,t)}))}marshalledCall(e,t,r,o){return o(e,t,(async(n,a,i)=>{const s={spatialReference:e.spatialReference,services:e.services,globalScope:r.globalScope,depthCounter:{depth:e.depthCounter.depth+1},libraryResolver:e.libraryResolver,exports:e.exports,console:e.console,abortSignal:e.abortSignal,lrucache:e.lrucache,timeZone:e.timeZone??null,interceptor:e.interceptor,localScope:{}};return i=i.map((t=>!l(t)||t instanceof F?t:O(t,e,o))),O(await ee(this.definition,s,i,t),r,o)}))}}async function ee(e,r,o,n){const s=e.body;if(o.length!==e.params.length)throw new G(r,L.WrongNumberOfParameters,null);for(let n=0;n<o.length;n++){const a=e.params[n];"Identifier"===a.type&&null!=r.localScope&&(r.localScope[t(a)]={value:o[n]})}const l=await ne(r,s);if(l instanceof a)return l.value;if(l===c)throw new G(r,L.UnexpectedToken,n);if(l===u)throw new G(r,L.UnexpectedToken,n);return l instanceof i?l.value:l}class te extends x{constructor(e){super(),this.source=e}global(e){const r=this.executingContext.globalScope[t(e)];if(l(r.value)&&!(r.value instanceof F)){const o=new F;return o.fn=r.value,o.parameterEvaluator=re,o.context=this.executingContext,this.executingContext.globalScope[t(e)]={value:o},o}return r.value}setGlobal(e,r){if(l(r))throw new G(null,L.AssignModuleFunction,null);this.executingContext.globalScope[t(e)]={value:r}}hasGlobal(e){return void 0===this.executingContext.exports[e]&&(e=t(e)),void 0!==this.executingContext.exports[e]}async loadModule(t){const r=t.spatialReference??W.WebMercator;this.moduleScope=ve(null,null,t.timeZone),this.executingContext={spatialReference:r,services:t.services,libraryResolver:new M(t.libraryResolver._moduleSingletons,this.source.syntax.loadedModules),exports:{},abortSignal:t.abortSignal??e,globalScope:this.moduleScope,console:t.console??Se,lrucache:t.lrucache,timeZone:t.timeZone??null,interceptor:t.interceptor,localScope:null,depthCounter:{depth:1}},await ce(this.executingContext,this.source.syntax)}}async function re(e,t,r){return!0===t.preparsed?r(e,null,t.arguments):r(e,t,await Y(e,t))}async function oe(e,o){o.breakpoint&&await o.breakpoint();try{switch(o.type){case"UpdateExpression":return await async function(e,o){const n=o.argument;if("CallExpression"===n.type)throw new G(e,L.NeverReach,o);if("MemberExpression"===n.type){const t=await oe(e,n.object);let a,i;if(!0===n.computed)a=await oe(e,n.property);else{if("Identifier"!==n.property.type)throw new G(e,L.Unrecognized,o);a=n.property.name}if(H(t)){if(!J(a))throw new G(e,L.ArrayAccessorMustBeNumber,o);if(a<0&&(a=t.length+a),a<0||a>=t.length)throw new G(e,L.OutOfBounds,o);i=m(t[a]),t[a]="++"===o.operator?i+1:i-1}else if(t instanceof r){if(!1===Q(a))throw new G(e,L.KeyAccessorMustBeString,o);if(!0!==t.hasField(a))throw new G(e,L.FieldNotFound,o,{key:a});i=m(t.field(a)),t.setField(a,"++"===o.operator?i+1:i-1)}else if(t instanceof te){if(!1===Q(a))throw new G(e,L.ModuleAccessorMustBeString,o);if(!0!==t.hasGlobal(a))throw new G(e,L.ModuleExportNotFound,o);i=m(t.global(a)),t.setGlobal(a,"++"===o.operator?i+1:i-1)}else{if(!j(t))throw b(t)?new G(e,L.Immutable,o):new G(e,L.InvalidParameter,o);if(!1===Q(a))throw new G(e,L.KeyAccessorMustBeString,o);if(!0!==t.hasField(a))throw new G(e,L.FieldNotFound,o,{key:a});i=m(t.field(a)),t.setField(a,"++"===o.operator?i+1:i-1)}return!1===o.prefix?i:"++"===o.operator?i+1:i-1}const a=t(n);let i;if(null!=e.localScope&&void 0!==e.localScope[a])return i=m(e.localScope[a].value),e.localScope[a]={value:"++"===o.operator?i+1:i-1},!1===o.prefix?i:"++"===o.operator?i+1:i-1;if(void 0!==e.globalScope[a])return i=m(e.globalScope[a].value),e.globalScope[a]={value:"++"===o.operator?i+1:i-1},!1===o.prefix?i:"++"===o.operator?i+1:i-1;throw new G(e,L.InvalidIdentifier,o)}(e,o);case"AssignmentExpression":return await async function(e,o){const n=o.left;if("MemberExpression"===n.type){const t=await oe(e,n.object);let a;if(!0===n.computed)a=await oe(e,n.property);else{if("Identifier"!==n.property.type)throw new G(e,L.InvalidIdentifier,o);a=n.property.name}const i=await oe(e,o.right);if(H(t)){if(!J(a))throw new G(e,L.ArrayAccessorMustBeNumber,o);if(a<0&&(a=t.length+a),a<0||a>t.length)throw new G(e,L.OutOfBounds,o);if(a===t.length){if("="!==o.operator)throw new G(e,L.OutOfBounds,o);t[a]=le(i,o.operator,t[a],o,e)}else t[a]=le(i,o.operator,t[a],o,e)}else if(t instanceof r){if(!1===Q(a))throw new G(e,L.KeyAccessorMustBeString,o);if(!0===t.hasField(a))t.setField(a,le(i,o.operator,t.field(a),o,e));else{if("="!==o.operator)throw new G(e,L.FieldNotFound,o,{key:a});t.setField(a,le(i,o.operator,null,o,e))}}else if(t instanceof te){if(!1===Q(a))throw new G(e,L.KeyAccessorMustBeString,o);if(!0!==t.hasGlobal(a))throw new G(e,L.ModuleExportNotFound,o);t.setGlobal(a,le(i,o.operator,t.global(a),o,e))}else{if(!j(t))throw b(t)?new G(e,L.Immutable,o):new G(e,L.InvalidParameter,o);if(!1===Q(a))throw new G(e,L.KeyAccessorMustBeString,o);if(!0===t.hasField(a))t.setField(a,le(i,o.operator,t.field(a),o,e));else{if("="!==o.operator)throw new G(e,L.FieldNotFound,o,{key:a});t.setField(a,le(i,o.operator,null,o,e))}}return p}const a=t(n);if(null!=e.localScope&&void 0!==e.localScope[a]){const t=await oe(e,o.right);return e.localScope[a]={value:le(t,o.operator,e.localScope[a].value,o,e)},p}if(void 0!==e.globalScope[a]){const t=await oe(e,o.right);return e.globalScope[a]={value:le(t,o.operator,e.globalScope[a].value,o,e)},p}throw new G(e,L.InvalidIdentifier,o)}(e,o);case"TemplateLiteral":return await async function(e,t){let r="",o=0;for(const n of t.quasis)if(r+=n.value?n.value.cooked:"",!1===n.tail){if(t.expressions[o]){const n=await oe(e,t.expressions[o]);if(l(n))throw new G(e,L.NoFunctionInTemplateLiteral,t);r+=w(n)}o++}return r}(e,o);case"Identifier":return fe(e,o);case"MemberExpression":return await async function(e,t){const o=await oe(e,t.object);if(null===o)throw new G(e,L.MemberOfNull,t);if(!1===t.computed){if("Identifier"===t.property.type){if(o instanceof r||y(o))return o.field(t.property.name);if(o instanceof z)return D(o,t.property.name,e,t);if(o instanceof te){if(!o.hasGlobal(t.property.name))throw new G(e,L.InvalidIdentifier,t);return o.global(t.property.name)}throw new G(e,L.InvalidMemberAccessKey,t)}throw new G(e,L.InvalidMemberAccessKey,t)}let n=await oe(e,t.property);if(o instanceof r||y(o)){if(Q(n))return o.field(n);throw new G(e,L.InvalidMemberAccessKey,t)}if(o instanceof te){if(Q(n))return o.global(n);throw new G(e,L.InvalidMemberAccessKey,t)}if(o instanceof z){if(Q(n))return D(o,n,e,t);throw new G(e,L.InvalidMemberAccessKey,t)}if(H(o)){if(J(n)&&isFinite(n)&&Math.floor(n)===n){if(n<0&&(n=o.length+n),n>=o.length||n<0)throw new G(e,L.OutOfBounds,t);return o[n]}throw new G(e,L.InvalidMemberAccessKey,t)}if(b(o)){if(J(n)&&isFinite(n)&&Math.floor(n)===n){if(n<0&&(n=o.length()+n),n>=o.length()||n<0)throw new G(e,L.OutOfBounds,t);return o.get(n)}throw new G(e,L.InvalidMemberAccessKey,t)}if(Q(o)){if(J(n)&&isFinite(n)&&Math.floor(n)===n){if(n<0&&(n=o.length+n),n>=o.length||n<0)throw new G(e,L.OutOfBounds,t);return o[n]}throw new G(e,L.InvalidMemberAccessKey,t)}throw new G(e,L.InvalidMemberAccessKey,t)}(e,o);case"Literal":return o.value;case"CallExpression":return await async function(e,r){if("MemberExpression"===r.callee.type){const t=await oe(e,r.callee.object);if(!(t instanceof te))throw new G(e,L.FunctionNotFound,r);const o=!1===r.callee.computed?r.callee.property.name:await oe(e,r.callee.property);if(!t.hasGlobal(o))throw new G(e,L.FunctionNotFound,r);const n=t.global(o);if(!l(n))throw new G(e,L.CallNonFunction,r);return n.call(e,r)}if("Identifier"!==r.callee.type)throw new G(e,L.FunctionNotFound,r);const o=t(r.callee);if(null!=e.localScope&&void 0!==e.localScope[o]){const t=e.localScope[o];if(l(t.value))return t.value.call(e,r);throw new G(e,L.CallNonFunction,r)}if(void 0!==e.globalScope[o]){const t=e.globalScope[o];if(l(t.value))return t.value.call(e,r);throw new G(e,L.CallNonFunction,r)}throw new G(e,L.FunctionNotFound,r)}(e,o);case"UnaryExpression":return await async function(e,t){const r=await oe(e,t.argument);if(_(r)){if("!"===t.operator)return!r;if("-"===t.operator)return-1*m(r);if("+"===t.operator)return 1*m(r);if("~"===t.operator)return~m(r);throw new G(e,L.UnsupportedUnaryOperator,t)}if("-"===t.operator)return-1*m(r);if("+"===t.operator)return 1*m(r);if("~"===t.operator)return~m(r);throw new G(e,L.UnsupportedUnaryOperator,t)}(e,o);case"BinaryExpression":return await async function(e,t){const r=await oe(e,t.left),o=await oe(e,t.right);switch(t.operator){case"|":case"<<":case">>":case">>>":case"^":case"&":return g(m(r),m(o),t.operator);case"==":return h(r,o);case"!=":return!h(r,o);case"<":case">":case"<=":case">=":return d(r,o,t.operator);case"+":return Q(r)||Q(o)?w(r)+w(o):m(r)+m(o);case"-":return m(r)-m(o);case"*":return m(r)*m(o);case"/":return m(r)/m(o);case"%":return m(r)%m(o);default:throw new G(e,L.UnsupportedOperator,t)}}(e,o);case"LogicalExpression":return await async function(e,t){const r=await oe(e,t.left);if(!_(r))throw new G(e,L.LogicalExpressionOnlyBoolean,t);switch(t.operator){case"||":{if(!0===r)return r;const o=await oe(e,t.right);if(_(o))return o;throw new G(e,L.LogicExpressionOrAnd,t)}case"&&":{if(!1===r)return r;const o=await oe(e,t.right);if(_(o))return o;throw new G(e,L.LogicExpressionOrAnd,t)}default:throw new G(e,L.LogicExpressionOrAnd,t)}}(e,o);case"ArrayExpression":return await async function(e,t){const r=[];for(let o=0;o<t.elements.length;o++)r.push(await oe(e,t.elements[o]));for(let o=0;o<r.length;o++){if(l(r[o]))throw new G(e,L.NoFunctionInArray,t);r[o]===p&&(r[o]=null)}return r}(e,o);case"ObjectExpression":return await async function(e,t){const o=[];for(let r=0;r<t.properties.length;r++){const n=t.properties[r],a=await oe(e,n.value),i="Identifier"===n.key.type?n.key.name:await oe(e,n.key);o[r]={key:i,value:a}}const n=Object.create(null),a=new Map;for(let r=0;r<o.length;r++){const i=o[r];if(l(i.value))throw new G(e,L.NoFunctionInDictionary,t);if(!1===Q(i.key))throw new G(e,L.KeyMustBeString,t);let s=i.key.toString();const c=s.toLowerCase();a.has(c)?s=a.get(c):a.set(c,s),i.value===p?n[s]=null:n[s]=i.value}const i=new r(n);return i.immutable=!1,i}(e,o);default:throw new G(e,L.Unrecognized,o)}}catch(t){throw T(e,o,t)}}async function ne(e,o){o.breakpoint&&await o.breakpoint();try{switch(o.type){case"ImportDeclaration":return await async function(e,r){const o=t(r.specifiers[0].local),n=e.libraryResolver.loadLibrary(o);let a;return e.libraryResolver._moduleSingletons?.has(n.uri)?a=e.libraryResolver._moduleSingletons.get(n.uri):(a=new te(n),await a.loadModule(e),e.libraryResolver._moduleSingletons?.set(n.uri,a)),e.globalScope[o]={value:a},p}(e,o);case"ExportNamedDeclaration":return await async function(e,r){if(await ne(e,r.declaration),"FunctionDeclaration"===r.declaration.type)e.exports[t(r.declaration.id)]="function";else if("VariableDeclaration"===r.declaration.type)for(const o of r.declaration.declarations)e.exports[t(o.id)]="variable";return p}(e,o);case"VariableDeclaration":return await pe(e,o,0);case"BlockStatement":return await ce(e,o);case"FunctionDeclaration":return await async function(e,r){const o=t(r.id);return e.globalScope[o]={value:new $(r,e)},p}(e,o);case"ReturnStatement":return await async function(e,t){if(null===t.argument)return new a(p);const r=await oe(e,t.argument);return new a(r)}(e,o);case"IfStatement":return await async function(e,t){const r=await oe(e,t.test);if(!0===r)return ne(e,t.consequent);if(!1===r)return null!==t.alternate?ne(e,t.alternate):p;throw new G(e,L.BooleanConditionRequired,t)}(e,o);case"ExpressionStatement":return await async function(e,t){const r=await oe(e,t.expression);return r===p?p:new i(r)}(e,o);case"ForStatement":return await async function(e,t){try{for(null!==t.init&&("VariableDeclaration"===t.init.type?await ne(e,t.init):await oe(e,t.init));;){if(null!==t.test){const r=await oe(e,t.test);if(!0===e.abortSignal?.aborted)throw new G(e,L.Cancelled,t);if(!1===r)break;if(!0!==r)throw new G(e,L.BooleanConditionRequired,t)}const r=await ne(e,t.body);if(r===c)break;if(r instanceof a)return r;null!==t.update&&await oe(e,t.update)}return p}catch(e){throw e}}(e,o);case"WhileStatement":return await async function(e,t){let r=await oe(e,t.test);if(!1===r)return p;if(!0!==r)throw new G(e,L.BooleanConditionRequired,t);for(;!0===r;){const o=await ne(e,t.body);if(o===c)break;if(o instanceof a)return o;if(r=await oe(e,t.test),!0!==r&&!1!==r)throw new G(e,L.BooleanConditionRequired,t)}return p}(e,o);case"ForInStatement":return await async function(e,o){const n=await oe(e,o.right);"VariableDeclaration"===o.left.type&&await ne(e,o.left);const a=t("VariableDeclaration"===o.left.type?o.left.declarations[0].id:o.left);let i=null;if(null!=e.localScope&&void 0!==e.localScope[a]&&(i=e.localScope[a]),null===i&&void 0!==e.globalScope[a]){const t=e.globalScope[a].value;i=e.globalScope[a]={value:t}}if(null===i)throw new G(e,L.InvalidIdentifier,o);return H(n)||Q(n)?await ae(e,o,n,i):b(n)?await ie(e,o,n,i):n instanceof r||y(n)?await ae(e,o,n.keys(),i,"k"):v(n)?await se(e,o,n,i):S(n)?await ae(e,o,K(n),i,"k"):p}(e,o);case"ForOfStatement":return await async function(e,o){const n=await oe(e,o.right);"VariableDeclaration"===o.left.type&&await ne(e,o.left);const i=t("VariableDeclaration"===o.left.type?o.left.declarations[0].id:o.left);let s=null;if(null!=e.localScope&&void 0!==e.localScope[i]&&(s=e.localScope[i]),null===s&&void 0!==e.globalScope[i]){const t=e.globalScope[i].value;s=e.globalScope[i]={value:t}}if(null===s)throw new G(e,L.InvalidIdentifier,o);return H(n)||Q(n)?await ae(e,o,n,s,"k"):b(n)?await ie(e,o,n,s,"k"):n instanceof r||y(n)?await async function(e,t,o,n){for(const i of o.keys()){const s=o.field(i);n.value=r.containerEntry(i,s);const l=await ne(e,t.body);if(l===c)break;if(l instanceof a)return l}return p}(e,o,n,s):v(n)?await se(e,o,n,s):S(n)?await async function(e,t,o,n){for(const i of K(o)){const s=D(o,i,e,t,1);n.value=r.containerEntry(i,s);const l=await ne(e,t.body);if(l===c)break;if(l instanceof a)return l}return p}(e,o,n,s):p}(e,o);case"BreakStatement":return c;case"EmptyStatement":return p;case"ContinueStatement":return u;default:throw new G(e,L.Unrecognized,o)}}catch(t){throw T(e,o,t)}}async function ae(e,t,r,o,n="i"){const i=r.length;for(let s=0;s<i;s++){if("k"===n){if(s>=r.length)throw new G(e,L.OutOfBounds,t);o.value=r[s]}else o.value=s;const i=await ne(e,t.body);if(i===c)break;if(i instanceof a)return i}return p}async function ie(e,t,r,o,n="i"){const i=r.length();for(let s=0;s<i;s++){o.value="k"===n?r.get(s):s;const i=await ne(e,t.body);if(i===c)break;if(i instanceof a)return i}return p}async function se(e,t,r,o){const n=r.iterator(e.abortSignal);let i;for(;null!=(i=await n.next());){const n=C.createFromGraphicLikeObject(i.geometry,i.attributes,r,e.timeZone);n._underlyingGraphic=i,o.value=n;const s=await ne(e,t.body);if(s===c)break;if(s instanceof a)return s}return p}function le(e,t,r,o,n){switch(t){case"=":return e===p?null:e;case"/=":return m(r)/m(e);case"*=":return m(r)*m(e);case"-=":return m(r)-m(e);case"+=":return Q(r)||Q(e)?w(r)+w(e):m(r)+m(e);case"%=":return m(r)%m(e);default:throw new G(n,L.UnsupportedOperator,o)}}async function ce(e,t){return ue(e,t,0)}async function ue(e,t,r){if(r>=t.body.length)return p;const o=await ne(e,t.body[r]);return o instanceof a||o===c||o===u||r===t.body.length-1?o:ue(e,t,r+1)}async function pe(e,r,o){return o>=r.declarations.length||(await async function(e,r){let o=null;if(o=null===r.init?null:await oe(e,r.init),null!==e.localScope){if(o===p&&(o=null),"Identifier"!==r.id.type)throw new G(e,L.InvalidIdentifier,r);const n=t(r.id);return void(null!=e.localScope&&(e.localScope[n]={value:o}))}if("Identifier"!==r.id.type)throw new G(e,L.InvalidIdentifier,r);const n=t(r.id);o===p&&(o=null),e.globalScope[n]={value:o}}(e,r.declarations[o]),o===r.declarations.length-1||await pe(e,r,o+1)),p}function fe(e,r){const o=t(r);if(null!=e.localScope&&void 0!==e.localScope[o])return e.localScope[o].value;if(void 0!==e.globalScope[o])return e.globalScope[o].value;throw new G(e,L.InvalidIdentifier,r)}async function me(e,t){f(null===t.arguments?[]:t.arguments,3,3,e,t);const r=await oe(e,t.arguments[0]);if(!1===_(r))throw new G(e,L.BooleanConditionRequired,t);return oe(e,r?t.arguments[1]:t.arguments[2])}async function we(e,t){f(null===t.arguments?[]:t.arguments,2,3,e,t);const r=await oe(e,t.arguments[0]);if(3===t.arguments.length){const o=await oe(e,t.arguments[1]),n=P(r,o);return null!=n&&""!==n?n:oe(e,t.arguments[2])}return null==r||""===r?oe(e,t.arguments[1]):r}async function de(e,t){if(t.arguments.length<2)throw new G(e,L.WrongNumberOfParameters,t);if(2===t.arguments.length)return oe(e,t.arguments[1]);if((t.arguments.length-1)%2==0)throw new G(e,L.WrongNumberOfParameters,t);return he(e,t,1,await oe(e,t.arguments[0]))}async function he(e,t,r,o){const n=await oe(e,t.arguments[r]);if(h(n,o))return oe(e,t.arguments[r+1]);const a=t.arguments.length-r;return 1===a?oe(e,t.arguments[r]):2===a?null:3===a?oe(e,t.arguments[r+2]):he(e,t,r+2,o)}async function ge(e,t){if(t.arguments.length<3)throw new G(e,L.WrongNumberOfParameters,t);if(t.arguments.length%2==0)throw new G(e,L.WrongNumberOfParameters,t);const r=await oe(e,t.arguments[0]);if(!1===_(r))throw new G(e,L.BooleanConditionRequired,t.arguments[0]);return ye(e,t,0,r)}async function ye(e,t,r,o){if(!0===o)return oe(e,t.arguments[r+1]);if(3===t.arguments.length-r)return oe(e,t.arguments[r+2]);const n=await oe(e,t.arguments[r+2]);if(!1===_(n))throw new G(e,L.ModuleExportNotFound,t.arguments[r+2]);return ye(e,t,r+2,n)}const be=function(){const e=Object.create(null);R(e,X),A(e,X),U(e,X,fe),N(e,X),E(e,X),B(e,X),q({functions:e,compiled:!1,signatures:null,evaluateIdentifier:null,mode:"async",standardFunction:X,standardFunctionAsync:re}),e.iif=me,e.defaultvalue=we,e.decode=de,e.when=ge;const t=function(){this.textformatting={value:r.textFormatting()}};(t.prototype=Object.create(null)).infinity=Object.freeze({value:Number.POSITIVE_INFINITY}),t.prototype.pi=Object.freeze({value:Math.PI});for(const[r,o]of Object.entries(e))t.prototype[r]=Object.freeze({value:new n(o)});return t}();function je(e){const t={mode:"async",compiled:!1,functions:Object.create(null),signatures:[],standardFunction:X,standardFunctionAsync:re,evaluateIdentifier:fe};for(let r=0;r<e.length;r++)e[r].registerFunctions(t);for(const[e,r]of Object.entries(t.functions))be.prototype[e]=Object.freeze({value:new n(r)});for(let e=0;e<t.signatures.length;e++)k(t.signatures[e],"async")}function ve(e,t,r){const o=new be;null==e&&(e={}),null==t&&(t={});for(const e in t)o[e]={value:new n(t[e])};for(const t in e)o[t]={value:V(e[t])?C.createFromGraphic(e[t],r):e[t]};return o}function Se(e){console.log(e)}async function xe(t,r){const o=r.spatialReference??W.WebMercator;let n=null;t.usesModules&&(n=new M(new Map,t.loadedModules));const p=ve(r.vars,r.customfunctions,r.timeZone),f={spatialReference:o,services:r.services,exports:{},libraryResolver:n,abortSignal:r.abortSignal??e,globalScope:p,console:r.console??Se,timeZone:r.timeZone??null,lrucache:r.lrucache,interceptor:r.interceptor,localScope:null,depthCounter:{depth:1}},m=await ce(f,t);if(m instanceof a||m instanceof i){const e=m.value;if(s(e))return null;if(l(e))throw new G(f,L.IllegalResult,null);return e}if(s(m))return null;if(m===c)throw new G(f,L.IllegalResult,null);if(m===u)throw new G(f,L.IllegalResult,null);throw new G(f,L.NeverReach,null)}je([Z]),je([o]);export{xe as executeScript,je as extend};
