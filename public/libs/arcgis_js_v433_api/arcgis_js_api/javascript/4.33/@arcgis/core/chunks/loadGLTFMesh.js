/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import t from"../Color.js";import{d as e}from"./colorUtils2.js";import r from"../request.js";import o from"../core/Error.js";import{g as s}from"./MapUtils.js";import{r as i,i as n}from"./mathUtils.js";import{b as a,f as m}from"./mat3.js";import{c as p}from"./mat3f64.js";import{f as l}from"./vec3f64.js";import{f as c}from"./vec4f64.js";import u from"../geometry/support/MeshComponent.js";import f from"../geometry/support/MeshMaterialMetallicRoughness.js";import j from"../geometry/support/MeshTexture.js";import g from"../geometry/support/MeshTextureTransform.js";import{M as d}from"./MeshVertexAttributes.js";import{s as x}from"./meshVertexSpaceUtils.js";import{g as y,n as T,y as h,C as v,d as b,D as w,a as U,e as M}from"./BufferView.js";import{c as C,d as S,e as R,l as A}from"./vec32.js";import{a as B,n as E,l as P}from"./vec42.js";import{e as $}from"./types.js";import"../core/lang.js";import{c as V}from"./vertexSpaceConversion.js";import{D as O}from"./DefaultLoadingContext.js";import{loadGLTF as D}from"./loader.js";import{c as F,n as I,f as L}from"./indexUtils.js";import{i as G}from"./resourceUtils3.js";import{T as k}from"./enums.js";import{f as q}from"./vec33.js";import"./ensureType.js";import"./Logger.js";import"../config.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"../core/promiseUtils.js";import"./handleUtils.js";import"./events.js";import"./maybe.js";import"./persistableUrlUtils.js";import"./tslib.es6.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"./Warning.js";import"./get.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/MeshMaterial.js";import"./imageUtils.js";import"./reader.js";import"./writer.js";import"../core/Clonable.js";import"./meshProperties.js";import"./vec3.js";import"./common.js";import"../geometry/Point.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/support/MeshGeoreferencedVertexSpace.js";import"./enumeration.js";import"../geometry/support/MeshLocalVertexSpace.js";import"./vec2.js";import"./vec4.js";import"./vec2f64.js";import"./mat4.js";import"./mat4f64.js";import"./spatialReferenceEllipsoidUtils.js";import"./computeTranslationToOriginAndRotation.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"./projectPointToVector.js";import"./projectionUtils.js";import"./SimpleObservable.js";import"../geometry/Extent.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./Axis.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./projectXYZToVector.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./asyncUtils.js";import"./Version.js";import"./quat.js";import"./quatf64.js";import"./Indices.js";import"./basicInterfaces.js";function z(t,e,r,o,s,i){const n=t.typedBuffer,a=t.typedBufferStride,m=i?.count??t.count;let p=(i?.dstIndex??0)*a;for(let t=0;t<m;++t)n[p]=e,n[p+1]=r,n[p+2]=o,n[p+3]=s,p+=a}function N(t,e){return new t(new ArrayBuffer(e*t.ElementCount*$(t.ElementType)))}async function _(e,n,a){const m=new O(function(t){const e=t?.resolveFile;return e?{busy:!1,request:async(t,o,s)=>{const i=e?.(t)??t,n="image"===o?"image":"binary"===o||"image+type"===o?"array-buffer":"json";return(await r(i,{responseType:n,signal:s?.signal,timeout:0})).data}}:null}(a)),p=(await D(m,n,a,!0)).model,u=p.lods.shift(),h=new Map,v=new Map;p.textures.forEach(((t,e)=>{return h.set(e,new j({data:(G((o=t).data),o.data),wrap:(r=o.parameters.wrap,{horizontal:Q(r.s),vertical:Q(r.t)})}));var r,o})),p.materials.forEach(((e,r)=>v.set(r,function(e,r){const o=new t((a=e.color,m=e.opacity,c(W(a[0]),W(a[1]),W(a[2]),m))),s=e.emissiveFactor?new t(function(t){return l(W(t[0]),W(t[1]),W(t[2]))}(e.emissiveFactor)):null,n=t=>t?new g({scale:t.scale?[t.scale[0],t.scale[1]]:[1,1],rotation:i(t.rotation??0),offset:t.offset?[t.offset[0],t.offset[1]]:[0,0]}):null;var a,m;return new f({color:o,colorTexture:r.get(e.colorTexture),normalTexture:r.get(e.normalTexture),emissiveColor:s,emissiveTexture:r.get(e.emissiveTexture),occlusionTexture:r.get(e.occlusionTexture),alphaMode:K(e.alphaMode),alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,metallic:e.metallicFactor,roughness:e.roughnessFactor,metallicRoughnessTexture:r.get(e.metallicRoughnessTexture),colorTextureTransform:n(e.colorTextureTransform),normalTextureTransform:n(e.normalTextureTransform),occlusionTextureTransform:n(e.occlusionTextureTransform),emissiveTextureTransform:n(e.emissiveTextureTransform),metallicRoughnessTextureTransform:n(e.metallicRoughnessTextureTransform)})}(e,h))));const w=function(t){let e=0;const r={color:!1,tangent:!1,normal:!1,texCoord0:!1},o=new Map,i=new Map,n=[];for(const m of t.parts){const{position:t,normal:p,color:l,tangent:c,texCoord0:u}=m.attributes,f=`\n      ${H(t,o)}/\n      ${H(p,o)}/\n      ${H(l,o)}/\n      ${H(c,o)}/\n      ${H(u,o)}/\n      ${a=m.transform,null!=a?a.toString():"-"}\n    `;let j=!1;const g=s(i,f,(()=>(j=!0,{start:e,length:t.count})));j&&(e+=t.count),p&&(r.normal=!0),l&&(r.color=!0),c&&(r.tangent=!0),u&&(r.texCoord0=!0),n.push({gltf:m,writeVertices:j,region:g})}var a;return{vertexAttributes:{position:N(M,e),normal:r.normal?N(b,e):null,tangent:r.tangent?N(y,e):null,color:r.color?N(T,e):null,texCoord0:r.texCoord0?N(U,e):null},parts:n,components:[]}}(u);for(const t of w.parts)J(w,t,v);const{position:C,normal:S,tangent:R,color:A,texCoord0:B}=w.vertexAttributes,E=x(e,a),P=e.spatialReference.isGeographic?x(e):E,$=V({vertexAttributes:{position:C.typedBuffer,normal:S?.typedBuffer,tangent:R?.typedBuffer},vertexSpace:P,spatialReference:e.spatialReference},E,{allowBufferReuse:!0,sourceUnit:a?.unitConversionDisabled?void 0:"meters"});if(!$)throw new o("load-gltf-mesh:vertex-space-projection",`Failed to load mesh from glTF because we could not convert the vertex space from ${P.type} to ${E.type}`);return{transform:null,vertexSpace:E,components:w.components,spatialReference:e.spatialReference,vertexAttributes:new d({...$,color:A?.typedBuffer,uv:B?.typedBuffer})}}function H(t,e){if(null==t)return"-";const r=t.typedBuffer;return`${s(e,r.buffer,(()=>e.size))}/${r.byteOffset}/${r.byteLength}`}function J(t,e,r){e.writeVertices&&function(t,e){const{position:r,normal:o,tangent:s,color:i,texCoord0:l}=t.vertexAttributes,c=e.region.start,{attributes:u,transform:f}=e.gltf,j=u.position.count;if(C(r.slice(c,j),u.position,f),null!=u.normal&&null!=o){const t=a(p(),f),e=o.slice(c,j);S(e,u.normal,t),n(t)&&R(e,e)}else null!=o&&q(o,0,0,1,{dstIndex:c,count:j});if(null!=u.tangent&&null!=s){const t=m(p(),f),e=s.slice(c,j);B(e,u.tangent,t),n(t)&&E(e,e)}else null!=s&&z(s,0,0,1,1,{dstIndex:c,count:j});if(null!=u.texCoord0&&null!=l?I(l.slice(c,j),u.texCoord0):null!=l&&L(l,0,0,{dstIndex:c,count:j}),null!=u.color&&null!=i){const t=u.color,e=i.slice(c,j);if(4===t.elementCount)t instanceof y?P(e,t,1,255):(t instanceof T||t instanceof h)&&P(e,t,1/255,255);else{z(e,255,255,255,255);const r=v.fromTypedArray(e.typedBuffer,e.typedBufferStride);t instanceof b?A(r,t,1,255):(t instanceof v||t instanceof w)&&A(r,t,1/255,255)}}else null!=i&&z(i.slice(c,j),255,255,255,255)}(t,e);const{indices:o,attributes:s,primitiveType:i,material:l}=e.gltf;let c=F(o||s.position.count,i);const f=e.region.start;if(f){const t=new Uint32Array(c);for(let e=0;e<c.length;e++)t[e]+=f;c=t}t.components.push(new u({name:e.gltf.name,faces:c,material:r.get(l),shading:s.normal?"source":"flat",trustSourceNormals:!0}))}function K(t){switch(t){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function Q(t){switch(t){case k.CLAMP_TO_EDGE:return"clamp";case k.MIRRORED_REPEAT:return"mirror";case k.REPEAT:return"repeat"}}function W(t){return t**(1/e)*255}export{_ as loadGLTFMesh};
