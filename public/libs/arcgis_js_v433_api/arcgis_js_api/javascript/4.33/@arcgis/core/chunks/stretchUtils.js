/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{b as t}from"./maybe.js";import n from"../layers/support/PixelBlock.js";import{g as e}from"./pixelRangeUtils.js";import{a as s}from"./stretchRendererUtils.js";function i(t){return["u8","s8"].includes(t.pixelType)&&null!=t.statistics?.[0]?.min&&null!=t.statistics[0]?.max&&1===t.bandCount}function a(t,n){const{attributeTable:e,bandCount:s}=t;return!((null!=e||!i(t))&&(null==e||s>1||n&&null==e.fields.find((t=>t.name.toLowerCase()===n.toLowerCase()))))}function o(t){const{bandCount:n,dataType:e,pixelType:s}=t;return"elevation"===e||"generic"===e&&1===n&&("s16"===s||"s32"===s||"f32"===s||"f64"===s)}function r(t,n=!1){const{bandCount:e,colormap:s,pixelType:i}=t;return 1===e&&(!!s?.length||!n&&"u8"===i)}function l(t,n=!1){const{attributeTable:e,bandCount:s}=t;return 1===s&&(!n||null!=e||null!=t.histograms)}function u(t){const{dataType:n}=t;return"vector-uv"===n||"vector-magdir"===n}function c(t){const{dataType:n}=t;return"vector-uv"===n||"vector-magdir"===n}function f(t){return!!t?.length&&t.length<=16384}function m(t){if(null==t)return!1;const{max:n,min:e,size:s}=t;return(n-e)/s===1&&e>=-.5&&.5===Math.abs(e%1)&&n<=255.5}function h(t,n=256){n=Math.min(n,256);const{size:e,counts:s}=t,i=new Float64Array(e);i[0]=s[0]/n;for(let t=1;t<e;t++)i[t]=i[t-1]+s[t]/n;const a=new Uint8Array(n),o=n/i[i.length-1];if(e<=n){const s=m(t)?Math.max(0,Math.round(t.min+.5)):0;for(let t=s;t<n;t++)a[t]=t>=e+s?255:Math.min(255,Math.trunc(i[t-s]*o))}else{const t=i.map((t=>Math.min(255,Math.trunc(t*o))));for(let s=0;s<n;s++)a[s]=t[Math.round(e/n)];a[n-1]=255}return a}function p(t){const{minCutOff:n,maxCutOff:e,gamma:s,pixelType:i,rounding:a}=t;if(!["u8","u16","s8","s16"].includes(i))return null;const o=n.length,r="s8"===i?-127:"s16"===i?-32767:0,l=["u16","s16"].includes(i)?65536:256,u=[],c=[],{minOutput:f=0,maxOutput:m=255}=t,h=m-f;for(let t=0;t<o;t++)c[t]=e[t]-n[t],u[t]=0===c[t]?0:h/c[t];const p=[];if(s&&s.length>=o){const t=O(o,s);for(let i=0;i<o;i++){const o=[];for(let u=0;u<l;u++){if(0===c[i]){o[u]=f;continue}const l=u+r,p=(l-n[i])/c[i];let g=1;if(s[i]>1&&(g-=(1/h)**(p*t[i])),l<e[i]&&l>n[i]){const t=g*h*p**(1/s[i])+f;o[u]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}else l>=e[i]?o[u]=m:o[u]=f}p[i]=o}}else for(let t=0;t<o;t++){const s=[];for(let i=0;i<l;i++){const o=i+r;if(o<=n[t])s[i]=f;else if(o>=e[t])s[i]=m;else{const e=(o-n[t])*u[t]+f;s[i]="floor"===a?Math.floor(e):"round"===a?Math.round(e):e}}p[t]=s}if(null!=t.contrastOffset){const n=g(t.contrastOffset,t.brightnessOffset);for(let t=0;t<o;t++){const e=p[t];for(let t=0;t<l;t++)e[t]=n[e[t]]}}return{lut:p,offset:r}}function g(t,n){const e=Math.min(Math.max(t,-100),100),s=Math.min(Math.max(n??0,-100),100),i=new Uint8Array(256);for(let t=0;t<256;t++){let n=0;e>0&&e<100?n=(200*t-25500+510*s)/(2*(100-e))+128:e<=0&&e>-100?n=(200*t-25500+510*s)*(100+e)/2e4+128:100===e?(n=200*t-25500+256*(100-e)+510*s,n=n>0?255:0):-100===e&&(n=128),i[t]=n>255?255:n<0?0:n}return i}function d(t,n,e){const s=[];for(let e=0;e<n.length;e++){let i=0,a=0,o=0;"min"in n[e]?({min:i,max:a,avg:o}=n[e]):[i,a,o]=n[e];let r=o??0;"u8"!==t&&(r=255*(r-i)/(a-i)),s.push(x(r))}return s}function x(t){if(t<=0||t>=255)return 1;const n=t+(150===t?0:t<150?45*Math.cos(.01047*t):17*Math.sin(.021*t)),e=Math.log(t/255),s=Math.log(n/255);if(0===s)return 1;const i=e/s;return isNaN(i)?1:Math.min(9.9,Math.max(.01,i))}function M(t){const{pixels:n,mask:e,pixelType:s,bandMasks:i}=t,a=n.map(((t,n)=>function(t,n,e){let s=1/0,i=-1/0,a=0,o=0,r=0,l=0;const u=t.length,c=new Map,f=[];for(let e=0;e<u;e++){const u=t[e];if(!n||n[e]){f.push(u);const t=(c.get(u)??0)+1;c.set(u,t),t>l&&(l=t,r=u),s=u<s?u:s,i=u>i?u:i,a+=u,o++}}if(0===o)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const m=a/o;let h=0;for(let e=0;e<u;e++)n&&!n[e]||(h+=(t[e]-m)**2);const p=n?n.filter((t=>t)).length:u,g=p<=1?0:Math.sqrt(h/(p-1));f.sort(((t,n)=>t-n));const d=o>>>1,x={min:s,max:i,avg:m,stddev:g,mode:r,median:o%2?f[Math.floor(d)]:(f[d-1]+f[d])/2};if(["u8","s8","u4","u2","u1"].includes(e)){const e=i-s+1,a=new Uint32Array(e);for(let e=0;e<u;e++)n&&!n[e]||a[t[e]-s]++;return{statistics:x,histogram:{min:s-.5,max:i+.5,size:e,counts:a}}}const M=new Uint32Array(256),y=(i-s)/256;if(0===y)return{statistics:x,histogram:{min:s,max:i,size:1,counts:new Uint32Array(1).fill(o)}};const b=new Uint32Array(257);for(let e=0;e<u;e++)n&&!n[e]||b[Math.floor((t[e]-s)/y)]++;for(let t=0;t<255;t++)M[t]=b[t];return M[255]=b[255]+b[256],{statistics:x,histogram:{min:s,max:i,size:256,counts:M}}}(t,i?.[n]??e,s)));return{statistics:a.map((({statistics:t})=>t)),histograms:a.map((({histogram:t})=>t))}}function y(t){if(!t?.pixels?.length)return null;const{pixels:n,mask:e,bandMasks:s,pixelType:i}=t,a=t.width*t.height,o=n.length,r=[],l=[],u=256;let c,f;for(let m=0;m<o;m++){let o=new Uint32Array(u);const h=n[m],p=s?.[m]??e;if("u8"===i){if(c=255,f=0,p){for(let t=0;t<a;t++)if(p[t]){const n=h[t];c=n<c?n:c,f=n>f?n:f,o[n]++}}else for(let t=0;t<a;t++){const n=h[t];c=n<c?n:c,f=n>f?n:f,o[n]++}o=o.slice(c,f+1)}else{let n=!1;t.statistics||(t.updateStatistics(),n=!0);const e=t.statistics;c=e[m].minValue,f=e[m].maxValue;const s=(f-c)/u;if(0===s){!e||t.validPixelCount||n||t.updateStatistics();const s=(t.validPixelCount||t.width*t.height)/u;for(let t=0;t<u;t++)o[t]=Math.round(s*(t+1))-Math.round(s*t)}else{const t=new Uint32Array(257);for(let n=0;n<a;n++)p&&!p[n]||t[Math.floor((h[n]-c)/s)]++;for(let n=0;n<255;n++)o[n]=t[n];o[255]=t[255]+t[256]}}const g="u8"===i?c-.5:c,d="u8"===i?f+.5:f;r.push({min:g,max:d,size:o.length,counts:o});let x=0,M=0,y=0;for(let t=0;t<o.length;t++)x+=o[t],M+=t*o[t];const b=M/x;for(let t=0;t<o.length;t++)y+=o[t]*(t-b)**2;const v=Math.sqrt(y/(x-1)),O=(d-g)/o.length,C=(b+("u8"===i?0:.5))*O+c,w=v*O;l.push({min:c,max:f,avg:C,stddev:w})}return{statistics:l,histograms:r}}function b(t){const n=[];for(let e=0;e<t.length;e++){const{min:s,max:i,size:a,counts:o}=t[e];let r=0,l=0;for(let t=0;t<a;t++)r+=o[t],l+=t*o[t];const u=l/r;let c=0;for(let t=0;t<a;t++)c+=o[t]*(t-u)**2;const f=(i-s)/a,m=(u+.5)*f+s,h=Math.sqrt(c/(r-1))*f;n.push({min:s,max:i,avg:m,stddev:h})}return n}function v(n,i){const{pixelBlock:a,bandIds:o,returnHistogramLut:r,rasterInfo:l}=i;let u=null,c=null,f=n.stretchType;if("number"==typeof f&&(f=s[f]),n.dra)if("minMax"===f&&a?.statistics)u=a.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=y(a);u=null!=t?t.statistics:null,c=null!=t?t.histograms:null}else u=n.statistics?.length?n.statistics:l.statistics,c="histograms"in n?n.histograms:void 0,c||(c=l.histograms);"percentClip"!==f&&"histogramEqualization"!==f||c?.length||(f="minMax");const m=u?.length||c?.length||l.bandCount,p=[],g=[];u&&!Array.isArray(u[0])&&(u=u.map((t=>[t.min,t.max,t.avg,t.stddev])));const[d,x]=e(l.pixelType);if(!u?.length){u=[];for(let t=0;t<m;t++)u.push([d,x,1,1]);"standardDeviation"===f&&(f="minMax")}switch(f){case"none":for(let t=0;t<m;t++)p[t]=d,g[t]=x;break;case"minMax":for(let t=0;t<m;t++){const n=u[t];p[t]=n[0],g[t]=n[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:t=2}=n;for(let n=0;n<m;n++){const e=u[n];p[n]=e[2]-t*e[3],g[n]=e[2]+t*e[3],p[n]<e[0]&&(p[n]=e[0]),g[n]>e[1]&&(g[n]=e[1])}}break;case"histogramEqualization":t(c);for(let t=0;t<m;t++)p[t]=c[t].min,g[t]=c[t].max;break;case"percentClip":t(c);for(let t=0;t<c.length;t++){const e=c[t],s=new Uint32Array(e.size),i=[...e.counts];i.length>=20&&(i[0]=i[1]=i[2]=i[i.length-1]=i[i.length-2]=0);let a=0;const o=(e.max-e.min)/e.size,r=-.5===e.min&&1===o?.5:0;for(let t=0;t<e.size;t++)a+=i[t],s[t]=a;let l=(n.minPercent||0)*a/100;p[t]=e.min+r;for(let n=0;n<e.size;n++)if(s[n]>l){p[t]=e.min+o*(n+r);break}l=(1-(n.maxPercent||0)/100)*a,g[t]=e.max+r;for(let n=e.size-2;n>=0;n--)if(s[n]<l){g[t]=e.min+o*(n+2-r);break}if(g[t]<p[t]){const n=p[t];p[t]=g[t],g[t]=n}}break;default:for(let t=0;t<m;t++){const n=u[t];p[t]=n[0],g[t]=n[1]}}let M,b,v;return"histogramEqualization"===f?(t(c),b=c[0].size||256,M=0,r&&(v=c.map((t=>h(t))))):(b=n.max||255,M=n.min||0),function(t,n){if(null==n||0===n.length)return t;const e=Math.max.apply(null,n),{minCutOff:s,maxCutOff:i,minOutput:a,maxOutput:o,histogramLut:r}=t;return s.length===n.length||s.length<=e?t:{minCutOff:n.map((t=>s[t])),maxCutOff:n.map((t=>i[t])),histogramLut:r?n.map((t=>r[t])):null,minOutput:a,maxOutput:o}}({minCutOff:p,maxCutOff:g,maxOutput:b,minOutput:M,histogramLut:v},o)}function O(t,n){const e=new Float32Array(t);for(let s=0;s<t;s++)n[s]>1?n[s]>2?e[s]=6.5+(n[s]-2)**2.5:e[s]=6.5+100*(2-n[s])**4:e[s]=1;return e}function C(t,e){if(!t?.pixels?.length)return t;const{mask:s,bandMasks:i,width:a,height:o,pixels:r}=t,{minCutOff:l,maxCutOff:u,minOutput:c,maxOutput:f,gamma:m}=e,h=a*o,p=e.outputPixelType||"u8",g=t.pixels.map((()=>n.createEmptyBand(p,h))),d=g.length,x=f-c,M=[],y=[];for(let t=0;t<d;t++)y[t]=u[t]-l[t],M[t]=0===y[t]?0:x/y[t];const b=p.startsWith("u")||p.startsWith("s"),v=m&&m.length>=d,C=!!e.isRenderer;if(v){const t=O(d,m);for(let n=0;n<d;n++){const e=i?.[n]??s;for(let s=0;s<h;s++)if(null==e||e[s]){if(0===y[n]){g[n][s]=c;continue}const e=r[n][s],i=(e-l[n])/y[n];let a=1;if(m[n]>1&&(a-=(1/x)**(i*t[n])),e<u[n]&&e>l[n]){const t=a*x*i**(1/m[n])+c;g[n][s]=C?Math.floor(t):b?Math.round(t):t}else e>=u[n]?g[n][s]=f:g[n][s]=c}}}else for(let t=0;t<d;t++){const n=i?.[t]??s;for(let e=0;e<h;e++)if(null==n||n[e]){const n=r[t][e];if(n<u[t]&&n>l[t]){const s=(n-l[t])*M[t]+c;g[t][e]=C?Math.floor(s):b?Math.round(s):s}else n>=u[t]?g[t][e]=f:g[t][e]=c}}const w=new n({width:a,height:o,mask:s,bandMasks:i,pixels:g,pixelType:p});return w.updateStatistics(),w}export{r as a,a as b,l as c,o as d,c as e,i as f,M as g,y as h,u as i,b as j,v as k,m as l,p as m,f as n,d as o,h as p,g as q,O as r,C as s};
