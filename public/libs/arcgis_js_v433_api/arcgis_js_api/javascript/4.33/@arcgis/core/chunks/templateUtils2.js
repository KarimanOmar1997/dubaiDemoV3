/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{g as i}from"./MapUtils.js";import{debounce as t,throwIfAborted as n}from"../core/promiseUtils.js";import{a as r}from"./SetUtils.js";import{a as s,i as o,b as a}from"./layerUtils.js";import{_ as d}from"./tslib.es6.js";import{id as c}from"../kernel.js";import l from"../core/Collection.js";import v from"../core/Error.js";import p from"../core/Evented.js";import u from"../core/Loadable.js";import f from"../core/Promise.js";import{R as m}from"./ReactiveMap.js";import{whenOnce as h,watch as g}from"../core/reactiveUtils.js";import{normalize as y}from"../core/urlUtils.js";import{property as w}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{subclass as S}from"../core/accessorSupport/decorators/subclass.js";import{U as I}from"./UpdatingHandles.js";import{p as b}from"../request.js";import A from"../portal/Portal.js";import{h as _}from"./utils9.js";import L from"../rest/featureService/FeatureService.js";import V from"../core/Accessor.js";function T(e){return"feature"===e.type}let U=class extends V{constructor(e){super(e),this.layers=new l,this.lockType="none",this.tables=new l,this.versionInfo=null,this.versionService=null}get layersAndTables(){return new l([...this.layers.toArray(),...this.tables.toArray()])}updateLockType(){this.lockType=this.versionInfo?this.versionService.getLockType(this.versionInfo.versionIdentifier)??"none":"none"}get featureServiceVersion(){return this.featureService.sourceJSON?.currentVersion??0}};d([w({constructOnly:!0})],U.prototype,"canCreateVersion",void 0),d([w({constructOnly:!0})],U.prototype,"canEditVersionedData",void 0),d([w({constructOnly:!0})],U.prototype,"featureService",void 0),d([w({constructOnly:!0})],U.prototype,"layers",void 0),d([w()],U.prototype,"layersAndTables",null),d([w()],U.prototype,"lockType",void 0),d([w({constructOnly:!0})],U.prototype,"tables",void 0),d([w()],U.prototype,"versionInfo",void 0),d([w({constructOnly:!0})],U.prototype,"versionService",void 0),d([w()],U.prototype,"hasAdvancedEditingUserTypeExtension",void 0),d([w()],U.prototype,"loggedInServiceUser",void 0),d([w()],U.prototype,"featureServiceVersion",null),U=d([S("esri.undoredo.support.ServiceVersionInfo")],U);const j=new Map;function k(t){return i(j,t,(()=>{const i=new E({view:t});return t.addHandles({remove(){j.delete(t),i.destroy()}}),i.load().catch((i=>{e.getLogger("esri.views.Services").error("Failed to load service metadata",i)})),i}))}let E=class extends(u.LoadableMixin(f.EsriPromiseMixin(p.EventedAccessor))){constructor(i){super(i),this._updatingHandles=new I,this.items=new l,this.tablesAndLayersLookup=new m,this.additionalLayers=new l,this._debouncedCheckAndUpdateServiceInfos=t((async()=>{const e=[];for(const i of this.items){if(0===i.layersAndTables.length)continue;const t=i.layersAndTables.getItemAt(0);t?.gdbVersion!==i.versionInfo?.versionIdentifier.name&&e.push(i)}0!==e.length&&(await h((()=>!this.updating)),await this._updateVersionInfos(e))})),this._debouncedLayersChanged=t((async()=>{const i=this._detectNewLayersAndTables();0!==i.length&&(await h((()=>!this._updatingHandles.updating)),await this._updatingHandles.addPromise((async()=>{const t=new Set;for(const n of i)if("feature"===n.type||"subtype-group"===n.type){if(!n.url)continue;const i=b(n.url).url.path,r=this._findServiceInfo(i);if(r)this.tablesAndLayersLookup.set(n,r),n.isTable?r.tables.push(n):r.layers.push(n);else if(!t.has(i))try{await this._addServiceInfo(i,n)}catch(t){e.getLogger(this).error(`Failed to load feature service: ${i}`,t)}finally{t.add(i)}}})()))})),this._processed=new Set}destroy(){this._set("view",null),this.items.removeAll(),this.tablesAndLayersLookup.clear()}async load(i){return n(i),this.addHandles([g((()=>this.view.map),(()=>{this._reset()})),g((()=>this._allLayersAndTables),(()=>{this._debouncedLayersChanged().catch((i=>{e.getLogger(this).warn("Failed to update service info",i)}))})),g((()=>this.items.map((e=>e.layersAndTables.map((e=>e.gdbVersion??"")).join(",")))),(()=>{this.checkAndUpdateServiceInfos().catch((i=>{e.getLogger(this).warn("Failed to update service info",i)}))}))]),this.addResolvingPromise(this._debouncedLayersChanged()),this}get updating(){return"loading"===this.loadStatus||this._updatingHandles.updating}checkAndUpdateServiceInfos(){return this._debouncedCheckAndUpdateServiceInfos()}changeVersion(e,i,t){return this._updatingHandles.addPromise((async()=>{await this._changeVersionInternal(e,i,t)})())}createVersion(e){return this._updatingHandles.addPromise((async()=>{const i=e.featureServerUrl,t=this._findServiceInfo(i);if(!t?.versionService)throw new v("services:no-version-management-service","No version management service");const n=t.hasAdvancedEditingUserTypeExtension,r=t.loggedInServiceUser.toUpperCase(),s=(o=e.ownerName)&&0!==o.trim().length?e.ownerName?.trim().toUpperCase():r;var o;if(s!==r){if(t.featureServiceVersion<=11.1)throw new v("services:versioning-api-error","Version management API too old");if(!n)throw new v("services:no-advanced-editing-user-type-extension","No advanced editing extension on service")}if("SDE"===s?.toUpperCase()&&"DEFAULT"===e.versionName.toUpperCase())throw new v("services:no-valid-version-name","No valid version name");{const i=await t.versionService.getVersionInfos();if(i?.find((i=>i.versionIdentifier.name.toUpperCase()===(s+"."+e.versionName).toUpperCase()||i.versionIdentifier.name.toUpperCase()===(r+"."+e.versionName).toUpperCase())))throw new v("services:no-valid-version-name","No valid version name")}const a=await t.versionService.createVersion({versionName:e.versionName,access:s!==r?"public":e.access,description:e.description});if(s!==r){const{guid:i,name:n}=a.versionIdentifier;await t.versionService.alterVersion({guid:i,name:n},{ownerName:s,access:e.access})}e.switchToVersion&&await this._changeVersionInternal(i,a.versionIdentifier.name,a.versionIdentifier.guid),this.emit("version-created",{versionIdentifier:a.versionIdentifier,versionManagementService:t.versionService})})())}deleteVersion(e,i,t){return this._updatingHandles.addPromise((async()=>{const n=this._findServiceInfo(e);if(!n?.versionService)throw new v("services:no-version-management-service","No version management service");if(n.featureServiceVersion<=11.1)throw new v("services:versioning-api-error","Version management API too old");if(!n.hasAdvancedEditingUserTypeExtension)throw new v("services:no-advanced-editing-user-type-extension","No advanced editing extension on service");const r={name:i,guid:t};await n.versionService.deleteVersion(r)&&(await this._updateVersionInfo(n),this.emit("version-deleted",{versionIdentifier:r,versionManagementService:n.versionService}))})())}startEditing(e){return this._updatingHandles.addPromise((async()=>{const i=this._findServiceInfo(e);if(!i?.versionService)throw new v("services:no-version-management-service","No version management service");if(!i.hasAdvancedEditingUserTypeExtension)throw new v("services:no-advanced-editing-user-type-extension","No advanced editing extension on service");const t=i.versionInfo?.versionIdentifier??{name:i.versionService.defaultVersionIdentifier.name,guid:i.versionService.defaultVersionIdentifier.guid};let n=!0;("none"!==i.versionService.getLockType(t)||(n=await i.versionService.startReading(t),n))&&(n=await i.versionService.startEditing(t),i.updateLockType())})())}finishEditing(e,i){return this._updatingHandles.addPromise((async()=>{const t=this._findServiceInfo(e);if(!t?.versionService)throw new v("services:no-version-management-service","No version management service");if(!t.hasAdvancedEditingUserTypeExtension)throw new v("services:no-advanced-editing-user-type-extension","No advanced editing extension on service");const n=t.versionInfo?.versionIdentifier??{name:t.versionService.defaultVersionIdentifier.name,guid:t.versionService.defaultVersionIdentifier.guid},r=t.versionService.getLockType(n);if("none"!==r)return"read"===r?(await t.versionService.stopReading(n),void t.updateLockType()):"edit"===r?(await t.versionService.stopEditing(n,i),await t.versionService.stopReading(n),void t.updateLockType()):void 0})())}async _changeVersionInternal(e,i,t){const n=this._findServiceInfo(e);if(!n?.versionService)throw new v("services:no-version-management-service","No version management service");const r=n.versionInfo?.versionIdentifier??{name:n.versionService.defaultVersionIdentifier.name,guid:n.versionService.defaultVersionIdentifier.guid},s={name:i,guid:t};await n.versionService.changeVersion(this.view?.map,r,s)&&await this._updateVersionInfo(n)}async _updateVersionInfo(e){const i=e.versionService;if(!i)return;if(0===e.layersAndTables.length)return;const t=e.layersAndTables.getItemAt(0)?.gdbVersion,n=t?await i.getVersionIdentifierFromName(t):i.defaultVersionIdentifier;e.versionInfo=await i.getVersionInfoExtended(n)}_findServiceInfo(e){return this.items.find((i=>i.featureService.url===e))??null}_removeFeatureService(e){this.items.remove(e)}_reset(){this.additionalLayers.removeAll(),this._processed.clear(),this.tablesAndLayersLookup.clear(),this.items.removeAll()}async _findPortal(e){const i=c?.findServerInfo(e??"");if(!i?.owningSystemUrl)return null;const t=`${i.owningSystemUrl}/sharing/rest`,n=A.getDefault();return n?.loaded&&y(n.restUrl)===y(t)?n:new A({authMode:"immediate",url:i.owningSystemUrl}).load()}_updateVersionInfos(i){return this._updatingHandles.addPromise((async()=>{for(const t of i)await this._updateVersionInfo(t).catch((i=>{e.getLogger(this).error("Failed to update version details",i)}))})())}async _addServiceInfo(e,i){const t=new L({url:e});await t.load();const n=await this._findPortal(e),r=n?.user?.username;let s=!1;r&&(s=await _(n,r,"advediting"));let o=null;t.versionManagementServiceUrl&&(o=new(0,(await import("../versionManagement/VersionManagementService.js")).default)({url:t.versionManagementServiceUrl}),await o.load());const a=i.isTable?[]:[i],d=i.isTable?[i]:[],c=new U({loggedInServiceUser:r??"",hasAdvancedEditingUserTypeExtension:s,versionInfo:null,lockType:"none",canEditVersionedData:!0,canCreateVersion:!0,featureService:t,versionService:o,layers:new l(a),tables:new l(d)});return o&&await this._updateVersionInfo(c),this.items.push(c),this.tablesAndLayersLookup.set(i,c),i.isTable?c.tables.push(i):c.layers.push(i),c}get _allLayersAndTables(){return[...this.view.map?.allLayers??[],...this.view.map?.allTables??[],...this.additionalLayers]}_detectNewLayersAndTables(){const e=new Set(this._allLayersAndTables),i=[];for(const t of e)"feature"!==t.type&&"subtype-group"!==t.type||this._processed.has(t)||i.push(t);for(const i of this._processed)if(!e.has(i)&&(s(i)||o(i))){const e=this.tablesAndLayersLookup.get(i);if(!e)continue;this.tablesAndLayersLookup.delete(i),i.isTable?e.tables.remove(i):e.layers.remove(i),0===e.layersAndTables.length&&this._removeFeatureService(e)}return this._processed=e,i}};function N(e){return null!=e&&"prototype"in e}function x(e){return M(e)&&!("definition"in e)}function C(e){return M(e)&&"definition"in e}function M(e){return null!=e&&"templateId"in e}function P(e){return C(e)&&"feature"===e?.type&&(null==e.definition||T(e.definition))}function H(e){return C(e)&&"group"===e?.type&&(null==e.definition||"group"===e.definition.type)}function F(e){return C(e)&&"preset"===e?.type&&(null==e.definition||"preset"===e.definition.type)}function O(e){return C(e)&&null!=e?.definition}d([w({constructOnly:!0})],E.prototype,"view",void 0),d([w()],E.prototype,"items",void 0),d([w()],E.prototype,"tablesAndLayersLookup",void 0),d([w()],E.prototype,"additionalLayers",void 0),d([w()],E.prototype,"updating",null),d([w()],E.prototype,"_allLayersAndTables",null),E=d([S("esri.undoredo.support.Services")],E);const R=e=>null==e||"object"!=typeof e?[]:[..."templates"in e&&Array.isArray(e.templates)?e.templates:[],..."types"in e&&Array.isArray(e.types)?e.types.flatMap((e=>e.templates)):[]];async function D(t,o,a){if(null==o)return t.map((e=>({layer:e,templates:R(e)})));const d=await async function(e,i){const t=await k(i).load(),n=new Set;for(const i of e)r(n,q(t,i));return await Promise.all(Array.from(n).map((e=>e.featureService.load()))),n}(t,o);n(a);const c=new Map,l=Array.from(d).map((e=>async function({serviceInfo:e,out:t,signal:r}){const{featureService:o,layersAndTables:a}=e,d=await async function({featureService:e,layers:t,signal:n}){if(!e.capabilities?.editing.supportsSharedTemplates)return new Map;const r=new Map(t.map((e=>[e.layerId,e]))),s=await e.querySharedTemplates({query:{layers:Array.from(r.keys())},requestOptions:{signal:n}}),o=new Map;for(const e of s)for(const t of e.layerIds)r.has(t)&&i(o,r.get(t),(()=>[])).push(e);return o}({featureService:o,layers:a.toArray(),signal:r});n(r);for(const[e,i]of d.entries())if(0!==i.length)if(s(e)){const n=$(i),r=[],s=n.get(1/0)??r;for(const i of e.sublayers){const e=n.get(i.subtypeCode)??r;t.set(i,[...e,...s])}}else t.set(e,i)}({serviceInfo:e,out:c,signal:a}))),v=await Promise.allSettled(l);for(const i of v.filter((e=>"rejected"===e.status)))e.getLogger("esri.editing.templateUtils").warn("Failed to fetch shared templates for service. Will use standard templates if available.",i.reason);return t.map((e=>({layer:e,templates:c.get(e)??R(e)})))}function q(e,i){return a(i)&&i.parent?e.tablesAndLayersLookup.get(i.parent):o(i)?e.tablesAndLayersLookup.get(i):null}function $(e){const t=new Map;for(const n of e)i(t,n.subtypeCode??1/0,(()=>[])).push(n);return t}export{N as a,M as b,O as c,P as d,F as e,H as f,k as g,C as h,x as i,D as j,T as k};
