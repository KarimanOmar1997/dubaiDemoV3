/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../request.js";import{r as t}from"./asyncUtils.js";import r from"../core/Error.js";import{L as s}from"./Logger.js";import{a}from"./memoryEstimations.js";import{N as n}from"./NestedMap.js";import{throwIfAbortError as o}from"../core/promiseUtils.js";import{V as i}from"./Version.js";import{a as u}from"./vec3f64.js";import{q as l,e as c}from"./aaBoundingBox.js";import{a as m}from"./Indices.js";import{r as p}from"./requestImageUtils.js";import{A as f}from"./orientedBoundingBox.js";import{C as d,A as y}from"./basicInterfaces.js";import{T as g,G as x}from"./Matrix4PassUniform.js";import{V as h}from"./VertexAttribute.js";import{D as w}from"./DefaultMaterial.js";import{T as v}from"./enums.js";const b=()=>s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class A{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}async function j(r,s){const n=await async function(r,s){const a=s?.streamDataRequester;if(a)return async function(e,r,s){const a=await t(r.request(e,"json",s));return!0===a.ok?a.value:(o(a.error),void P(a.error.details.url))}(r,a,s);const n=await t(e(r,s));return!0===n.ok?n.value.data:(o(n.error),void P(n.error))}(r,s),i=await async function(e,t){const r=new Array;for(const s in e){const a=e[s],n=a.images[0].data;if(!n){b().warn("Externally referenced texture data is not yet supported");continue}const o=a.encoding+";base64,"+n,i="/textureDefinitions/"+s,u="rgba"===a.channels?a.alphaChannelUsage||"transparency":"none",l={noUnpackFlip:!0,wrap:{s:v.REPEAT,t:v.REPEAT},preMultiplyAlpha:E(u)!==y.Opaque},c=t?.disableTextures?Promise.resolve(null):p(o,t);r.push(c.then((e=>({refId:i,image:e,parameters:l,alphaChannelUsage:u}))))}const s=await Promise.all(r),a={};for(const e of s)a[e.refId]=e;return a}(n.textureDefinitions??{},s);let u=0;for(const e in i)if(i.hasOwnProperty(e)){const t=i[e];u+=t?.image?t.image.width*t.image.height*4:0}return new A(n,i,u+a(n))}function P(e){throw new r("",`Request for object resource failed: ${e}`)}function I(e){const t=e.params,r=t.topology;let s=!0;switch(t.vertexAttributes||(b().warn("Geometry must specify vertex attributes"),s=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(b().warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),s=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(b().warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),s=!1)):(b().warn(`Indexed geometry does not specify face indices for '${r}' attribute`),s=!1)}}else b().warn("Indexed geometries must specify faces"),s=!1;break}default:b().warn(`Unsupported topology '${r}'`),s=!1}e.params.material||(b().warn("Geometry requires material"),s=!1);const a=e.params.vertexAttributes;for(const e in a)a[e].values||(b().warn("Geometries with externally defined attributes are not yet supported"),s=!1);return s}function M(e,t){const r=new Array,s=new Array,a=new Array,o=new n,l=e.resource,c=i.parse(l.version||"1.0","wosr");T.validate(c);const p=l.model.name,y=l.model.geometries,v=l.materialDefinitions??{},b=e.textures;let A=0;const j=new Map;for(let e=0;e<y.length;e++){const n=y[e];if(!I(n))continue;const i=O(n),l=n.params.vertexAttributes,c=[],p=e=>{if("PerAttributeArray"===n.params.topology)return null;const t=n.params.faces;for(const r in t)if(r===e)return t[r].values;return null},P=l[h.POSITION],M=P.values.length/P.valuesPerElement;for(const e in l){const t=l[e],r=t.values,s=p(e)??m(M);c.push([e,new f(r,s,t.valuesPerElement,!0)])}const U=i.texture,T=b&&b[U];if(T&&!j.has(U)){const{image:e,parameters:t}=T,r=new g(e,t);s.push(r),j.set(U,r)}const k=j.get(U),q=k?k.id:void 0,B=i.material;let R=o.get(B,U);if(null==R){const e=v[B.slice(B.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=T?E(T.alphaChannelUsage):void 0,s={ambient:u(e.diffuse),diffuse:u(e.diffuse),opacity:1-(e.transparency||0),textureAlphaMode:r,textureAlphaCutoff:.33,textureId:q,doubleSided:!0,cullFace:d.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:T?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(s,t.materialParameters),R=new w(s,t),o.set(B,U,R)}a.push(R);const C=new x(R,c);A+=c.find((e=>e[0]===h.POSITION))?.[1]?.indices.length??0,r.push(C)}return{engineResources:[{name:p,stageResources:{textures:s,materials:a,geometries:r},pivotOffset:l.model.pivotOffset,numberOfVertices:A,lodThreshold:null}],referenceBoundingBox:U(r)}}function U(e){const t=l();return e.forEach((e=>{const r=e.boundingInfo;null!=r&&(c(t,r.bbMin),c(t,r.bbMax))})),t}function E(e){switch(e){case"mask":return y.Mask;case"maskAndTransparency":return y.MaskBlend;case"none":return y.Opaque;default:return y.Blend}}function O(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const T=new i(1,2,"wosr");export{j as l,M as p};
