/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{m as t}from"../chunks/handleUtils.js";import n from"./Error.js";import{o as e}from"../chunks/events.js";import{L as r}from"../chunks/Logger.js";import{r as o}from"../chunks/maybe.js";import"./lang.js";import"../config.js";const i=(u=globalThis,{setTimeout:(n,e)=>{const r=u.setTimeout(n,e);return t((()=>u.clearTimeout(r)))}});var u;async function s(t,n){const e=t.slice(),r=await Promise.all(t.map(((t,e)=>n(t,e))));return e.filter(((t,n)=>r[n]))}function c(t="Aborted"){return new n("AbortError",t)}function l(t,n="Aborted"){if(f(t))throw c(n)}function a(t){return t instanceof AbortSignal?t:t?.signal??void 0}function f(t){const n=a(t);return null!=n&&n.aborted}function m(t){if(v(t))throw t}function h(t){if(!v(t))throw t}function w(t,n){const r=a(t);if(null!=r){if(!r.aborted)return e(r,"abort",(()=>n()));n()}}function p(t,n){const r=a(t);if(null!=r)return l(r),e(r,"abort",(()=>n(c())))}function b(t,n){return null==a(n)?t:new Promise(((e,r)=>{let i=w(n,(()=>r(c())));const u=()=>{i=o(i)};t.then(u,u),t.then(e,r)}))}function d(t,e,r){return Promise.race([t,k(e).then((()=>{throw new n("timeout",`Did not resolve within ${e} milliseconds (${r??"timeout"})`)}))])}function v(t){return"AbortError"===t?.name}async function y(t){try{return await t}catch(t){if(!v(t))throw t;return}}async function j(t,n=r.getLogger("esri")){try{return await t}catch(t){v(t)||n.error(t)}}async function g(t){if(!t)return;if("function"!=typeof t.forEach){const n=Object.keys(t),e=n.map((n=>t[n])),r=await g(e),o={};return n.map(((t,n)=>o[t]=r[n])),o}const n=t;return Promise.allSettled(n).then((t=>Array.from(n,((n,e)=>{const r=t[e];return"fulfilled"===r.status?{promise:n,value:r.value}:{promise:n,error:r.reason}}))))}async function T(t){return(await g(t)).filter((t=>!!t.value)).map((t=>t.value))}async function P(t){return(await Promise.allSettled(t)).filter((t=>"fulfilled"===t.status)).map((t=>t.value))}async function A(t){return(await Promise.allSettled(t)).filter((t=>"rejected"===t.status)).map((t=>t.reason))}function k(t,n=void 0,e){const r=new AbortController;return w(e,(()=>r.abort())),new Promise(((e,o)=>{let i=setTimeout((()=>{i=0,e(n)}),t);w(r,(()=>{i&&(clearTimeout(i),o(c()))}))}))}function E(t,e,r,o){const i=r&&"abort"in r?r:null;null!=o||i||(o=r);let u=setTimeout((()=>{u=0,i?.abort()}),e);const s=()=>o||new n("promiseUtils:timeout","The wrapped promise did not resolve within "+e+" ms");return t.then((t=>{if(0===u)throw s();return clearTimeout(u),t}),(t=>{throw clearTimeout(u),0===u?s():t}))}function S(t,n){const e=new AbortController,r=setTimeout((()=>e.abort()),n);return w(t,(()=>{e.abort(),clearTimeout(r)})),{...t,signal:e.signal}}function C(t){return t&&"function"==typeof t.then}function L(t){return C(t)?t:Promise.resolve(t)}function U(t,n=-1){let e,r,o,i,u=null;const s=(...l)=>{if(e){r=l,i&&i.reject(c()),i=$();const t=i.promise;if(u){const t=u;u=null,t.abort()}return t}if(o=i||$(),i=null,n>0){const r=new AbortController;e=L(t(...l,r.signal));const o=e;k(n).then((()=>{e===o&&(i?r.abort():u=r)}))}else e=1,e=L(t(...l));const a=()=>{const t=r;r=o=e=u=null,null!=t&&s(...t)},f=e,m=o;return f.then(a,a),f.then(m.resolve,m.reject),m.promise};return s}function $(){let t,n;const e=new Promise(((e,r)=>{t=e,n=r})),r=n=>{t(n)};return r.resolve=n=>t(n),r.reject=t=>n(t),r.timeout=(t,n)=>i.setTimeout((()=>r.reject(n)),t),r.promise=e,r}function x(t,n){return t.then(n,n)}function D(t,n){n.then(t.resolve,t.reject)}async function O(t){await Promise.resolve(),l(t)}export{k as after,A as allSettledErrors,P as allSettledValues,x as always,i as c,c as createAbortError,$ as createResolver,U as debounce,g as eachAlways,T as eachAlwaysValues,s as filter,y as ignoreAbortErrors,v as isAbortError,f as isAborted,C as isPromiseLike,j as logOnError,w as onAbort,p as onAbortOrThrow,D as settleWithPromise,a as signalFromSignalOrOptions,m as throwIfAbortError,l as throwIfAborted,h as throwIfNotAbortError,E as timeout,O as waitTick,L as when,b as whenOrAbort,d as whenOrTimeout,S as wrapAbortWithTimeout};
