/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{S as e}from"../../chunks/SimpleGeometryCursor.js";import{l as t,p as r,i as o}from"../../chunks/pe.js";import"../../chunks/assets.js";import"../../config.js";import"../../core/lang.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../chunks/Logger.js";import"../../chunks/jsonUtils.js";import"../../chunks/MapUtils.js";import"../../core/promiseUtils.js";import"../../chunks/handleUtils.js";import"../../chunks/events.js";import"../../chunks/maybe.js";import"../../chunks/persistableUrlUtils.js";let n,s,i,a,c,m,p,u,f,j,l,h,k;function T(){return!!n&&o()}async function g(){if(!T()){const[e,o]=await Promise.all([import("../../chunks/ProjectionTransformation.js").then((e=>e.bk)),import("../../chunks/ProjectionTransformation.js").then((e=>e.bj)).then((({injectPe:e})=>e)),t()]);n=new e.OperatorProject,o(r)}}function x(){return!!i&&T()}async function E(){if(!x()){const[e,t,r,o]=await Promise.all([import("../../chunks/apiConverter.js"),import("../../chunks/ProjectionTransformation.js").then((e=>e.bl)).then((({CompositeGeographicTransformationEditor:e})=>e)),import("../../chunks/ProjectionTransformation.js").then((e=>e.bm)).then((({create:e,createFromWKT:t})=>({create:e,createFromWKT:t}))),import("../../chunks/ProjectionTransformation.js").then((e=>e.bn)).then((({create:e,createEx:t,createFromAoi:r})=>({create:e,createEx:t,createFromAoi:r}))),g()]);s=e.fromExtent,i=e.fromGeometry,a=e.fromSpatialReference,c=e.getSpatialReference,m=e.toGeometry,p=t,u=r.create,f=r.createFromWKT,j=o.createEx,l=o.createFromAoi,h=o.create,k=n.supportsCurves()}}function P(e,t,r={}){const o=y(c(e),t,r);return m(function(e,t){return n.execute(e,t,null)}(i(e),o),t)}function w(t,r,o={}){return function(t,r){const o=n.executeMany(new e(t),r,null);return Array.from(o)}(t.map(i),y(c(t),r,o)).map((e=>m(e,r)))}function y(e,t,r={}){let o;const n=a(e),i=a(t);if(r?.geographicTransformation){const e=new p;e.setInputSpatialReference(n),e.setOutputSpatialReference(i);for(const t of r.geographicTransformation.steps){let r;r=t.wkid?u(t.wkid,t.isInverse):f(t.wkt,t.isInverse),e.add(r)}o=e.create()}else if(r?.areaOfInterestExtent)return l(n,i,s(r.areaOfInterestExtent).asEnvelope2D());return o?j(n,i,o):h(n,i)}export{P as execute,w as executeMany,x as isLoaded,E as load,k as supportsCurves};
