/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import t from"../../config.js";import s from"../../core/Error.js";import{L as e}from"../../chunks/Logger.js";import n from"../Polygon.js";import o from"../Polyline.js";import{c as r,o as i,u as c,g as l}from"../../chunks/normalizeUtilsCommon.js";import{l as p}from"../../chunks/unitUtils.js";import{geographicToWebMercator as u,webMercatorToGeographic as a}from"./webMercatorUtils.js";import{c as h,s as m}from"../../chunks/simplify.js";import"../../core/lang.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/Warning.js";import"../../chunks/get.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/coordsUtils.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/zmUtils.js";import"./jsonUtils.js";import"../Multipoint.js";import"../../chunks/utils10.js";import"../../chunks/utils11.js";const f=()=>e.getLogger("esri.geometry.support.normalizeUtils");function j(t){const s=[];let e=0,n=0;for(let o=0;o<t.length;o++){const r=t[o];let i=null;for(let t=0;t<r.length;t++)i=r[t],s.push(i),0===t?(e=i[0],n=e):(e=Math.min(e,i[0]),n=Math.max(n,i[0]));i&&s.push([(e+n)/2,0])}return s}function g(t,e){if(!(t instanceof o||t instanceof n)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw f().error(t),new s("internal:geometry",t)}const r=l(t),i=[];for(const t of r){const s=[];i.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const o=t[n][0],r=t[n][1],i=t[n+1][0],c=t[n+1][1],l=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),p=(c-r)/l,u=(i-o)/l,a=l/e;if(a>1){for(let t=1;t<=a-1;t++){const n=t*e,i=u*n+o,c=p*n+r;s.push([i,c])}const t=(l+Math.floor(a-1)*e)/2,n=u*t+o,i=p*t+r;s.push([n,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new n({rings:i,spatialReference:t.spatialReference}):new o({paths:i,spatialReference:t.spatialReference})}function k(t,s,e){if(s){const s=g(t,1e6);t=a(s,!0)}return e&&(t=c(t,e)),t}function y(t,s,e){if(Array.isArray(t)){const n=t[0];if(n>s){const e=i(n,s);t[0]=n+e*(-2*s)}else if(n<e){const s=i(n,e);t[0]=n+s*(-2*e)}}else{const n=t.x;if(n>s){const e=i(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<e){const s=i(n,e);t=t.clone().offset(s*(-2*e),0)}}return t}async function d(s,e,a){if(!Array.isArray(s))return d([s],e);e&&"string"!=typeof e&&f().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const j="string"==typeof e?e:e?.url??t.geometryServiceUrl;let g,x,b,M,U,w,R,P,S=0;const A=[],L=[];for(const t of s)if(null!=t)if(g||(g=t.spatialReference,x=p(g),b=g.isWebMercator,w=b?102100:4326,M=r[w].maxX,U=r[w].minX,R=r[w].plus180Line,P=r[w].minus180Line),x)if("mesh"===t.type)L.push(t);else if("point"===t.type)L.push(y(t.clone(),M,U));else if("multipoint"===t.type){const s=t.clone();s.points=s.points.map((t=>y(t,M,U))),L.push(s)}else if("extent"===t.type){const s=t.clone()._normalize(!1,!1,x);L.push(s.rings?new n(s):s)}else if(t.extent){const s=t.extent,e=i(s.xmin,U)*(2*M);let n=0===e?t.clone():c(t.clone(),e);s.offset(e,0);let{xmin:o,xmax:r}=s;o=Number(o.toFixed(9)),r=Number(r.toFixed(9)),s.intersects(R)&&r!==M?(S=r>S?r:S,n=k(n,b),A.push(n),L.push("cut")):s.intersects(P)&&o!==U?(S=r*(2*M)>S?r*(2*M):S,n=k(n,b,360),A.push(n),L.push("cut")):L.push(n)}else L.push(t.clone());else L.push(t);else L.push(t);let v=i(S,M),z=-90;const T=v,N=new o;for(;v>0;){const t=360*v-180;N.addPath([[t,z],[t,-1*z]]),z*=-1,v--}if(A.length>0&&T>0){const t=function(t,s){let e=-1;for(let n=0;n<s.cutIndexes.length;n++){const o=s.cutIndexes[n],r=s.geometries[n],c=l(r);for(let t=0;t<c.length;t++){const s=c[t];s.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<s.length;t++){const n=s[t][0];e=n>e?n:e}e=Number(e.toFixed(9));const n=-360*i(e,180);for(let e=0;e<s.length;e++){const s=r.getPoint(t,e);r.setPoint(t,e,s.clone().offset(n,0))}return!0}}))}if(o===e){if("polygon"===t[0].type)for(const s of l(r))t[o]=t[o].addRing(s);else if("polyline"===t[0].type)for(const s of l(r))t[o]=t[o].addPath(s)}else e=o,t[o]=r}return t}(A,await h(j,A,N,a)),e=[],n=[];for(let o=0;o<L.length;o++){const r=L[o];if("cut"!==r)n.push(r);else{const r=t.shift(),i=s[o];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(e.push(r),n.push("simplify")):n.push(b?u(r):r)}}if(!e.length)return n;const o=await m(j,e,a),r=[];for(let t=0;t<n.length;t++){const s=n[t];"simplify"!==s?r.push(s):r.push(b?u(o.shift()):o.shift())}return r}const F=[];for(let t=0;t<L.length;t++){const s=L[t];if("cut"!==s)F.push(s);else{const t=A.shift();F.push(!0===b?u(t):t)}}return F}function x(t){if(!t)return null;const s=t.extent;if(!s)return null;const e=t.spatialReference&&p(t.spatialReference);if(!e)return s;const[n,o]=e.valid,r=2*o,{width:i}=s;let c,{xmin:l,xmax:u}=s;if([l,u]=[u,l],"extent"===t.type||0===i||i<=o||i>r||l<n||u>o)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;c=j(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;c=j(t.paths);break;case"multipoint":c=t.points}const a=s.clone();for(let t=0;t<c.length;t++){let s=c[t][0];s<0?(s+=o,u=Math.max(s,u)):(s-=o,l=Math.min(s,l))}return a.xmin=l,a.xmax=u,a.width<i?(a.xmin-=o,a.xmax-=o,a):s}function b(t,s,e){const n=p(e);if(null==n)return t;const[o,r]=n.valid,i=2*r;let c=0,l=0;s>r?c=Math.ceil(Math.abs(s-r)/i):s<o&&(c=-Math.ceil(Math.abs(s-o)/i)),t>r?l=Math.ceil(Math.abs(t-r)/i):t<o&&(l=-Math.ceil(Math.abs(t-o)/i));let u=t+(c-l)*i;const a=u-s;return a>r?u-=i:a<o&&(u+=i),u}function M(t,s){const e=p(s);if(e){const[s,n]=e.valid,o=n-s;if(t<s)for(;t<s;)t+=o;if(t>n)for(;t>n;)t-=o}return t}export{b as getClosestDenormalizedXToReference,x as getDenormalizedExtent,d as normalizeCentralMeridian,M as normalizeMapX,g as straightLineDensify};
