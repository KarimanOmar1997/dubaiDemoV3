/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as o}from"../../chunks/tslib.es6.js";import t from"../../Color.js";import s from"../../core/Clonable.js";import e from"../../core/Collection.js";import{r}from"../../chunks/collectionUtils.js";import i from"../../core/JSONSupport.js";import{c as n,l as p}from"../../chunks/mathUtils.js";import{property as l}from"../../core/accessorSupport/decorators/property.js";import"../../core/lang.js";import"../../chunks/Logger.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import{I as a}from"../../chunks/ensureType.js";import"../../chunks/colorUtils2.js";import"../../config.js";import"../../chunks/MapUtils.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../core/Error.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/Warning.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../chunks/jsonUtils.js";let h=class extends(s.ClonableMixin(i)){constructor(){super(...arguments),this.color=null,this.position=0}};o([l({type:t,json:{type:[a],write:{enabled:!0,isRequired:!0}}})],h.prototype,"color",void 0),o([l({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],h.prototype,"position",void 0),h=o([c("esri.layers.voxel.VoxelColorStop")],h);const u=h;let y=class extends(s.ClonableMixin(i)){constructor(){super(...arguments),this.opacity=1,this.position=0}};o([l({type:Number,json:{name:"alpha",write:{enabled:!0,isRequired:!0}}})],y.prototype,"opacity",void 0),o([l({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],y.prototype,"position",void 0),y=o([c("esri.layers.voxel.VoxelOpacityStop")],y);const m=y;let d=class extends(s.ClonableMixin(i)){constructor(){super(...arguments),this.enabled=!1,this.range=null}};o([l({type:Boolean,json:{default:!1,write:!0}})],d.prototype,"enabled",void 0),o([l({type:[Number],json:{write:{isRequired:!0}}})],d.prototype,"range",void 0),d=o([c("esri.layers.voxel.VoxelRangeFilter")],d);const f=d;var j;!function(o){o[o.Color=1]="Color",o[o.Alpha=2]="Alpha",o[o.Both=3]="Both"}(j||(j={}));let g=class extends(s.ClonableMixin(i)){constructor(o){super(o),this.interpolation=null,this.stretchRange=null,this.rangeFilter=null,this._colorMapSize=256,this.colorStops=new(e.ofType(u)),this.opacityStops=new(e.ofType(m))}set colorStops(o){this._set("colorStops",r(o,this._get("colorStops"),e.ofType(u)))}set opacityStops(o){this._set("opacityStops",r(o,this._get("opacityStops"),e.ofType(m)))}getPreviousNext(o,t,s){let e=o;for(;--e>0&&t[e].type!==s&&t[e].type!==j.Both;);let r=o;const i=t.length;for(;++r<i&&t[r].type!==s&&t[r].type!==j.Both;);return[e,r]}get rasterizedTransferFunction(){const o=[];if(this.colorStops.length<2)return o;const s=[],e=[];for(const t of this.colorStops){if(!t.color)return o;e.push({color:{r:t.color.r,g:t.color.g,b:t.color.b,a:Math.round(255*(1-t.color.a))},position:t.position,type:j.Color})}if(0===this.opacityStops.length)for(const o of e)s.push({color:o.color,position:o.position});else{for(const o of this.opacityStops){const t=n(o.position,0,1),s=Math.round(255*n(1-o.opacity,0,1));let r=!1;for(const o of e)if(o.type===j.Color&&Math.abs(o.position-t)<1e-5){o.color.a=s,o.type=j.Both,r=!0;break}r||e.push({color:{r:0,g:0,b:0,a:s},position:o.position,type:j.Alpha})}e.sort(((o,t)=>o.position<t.position?-1:1));const o=e.length;for(let t=0;t<o;++t){const s=e[t];if(s.type!==j.Both)if(s.type===j.Color){const[r,i]=this.getPreviousNext(t,e,j.Alpha);if(-1!==r&&i!==o){const o=(s.position-e[r].position)/(e[i].position-e[r].position);s.color.a=Math.round(p(e[r].color.a,e[i].color.a,o))}else s.color.a=-1!==r?e[r].color.a:e[i].color.a}else{const[r,i]=this.getPreviousNext(t,e,j.Color);if(-1!==r&&i!==o){const o=(s.position-e[r].position)/(e[i].position-e[r].position),t=e[r].color,n=e[i].color;S.forEach((e=>{s.color[e]=Math.round(p(t[e],n[e],o))}))}else-1!==r?S.forEach((o=>{s.color[o]=e[r].color[o]})):S.forEach((o=>{s.color[o]=e[i].color[o]}))}}for(const o of e)s.push({color:o.color,position:o.position})}s[0].position=0,s[s.length-1].position=1;let r=0,i=1;for(let e=0;e<this._colorMapSize;++e){const l=e/this._colorMapSize;for(;l>s[i].position;)r=i++;const c=(l-s[r].position)/(s[i].position-s[r].position),a=s[r].color,h=s[i].color,u=new t;S.forEach((o=>{u[o]=Math.round(p(a[o],h[o],c))})),u.a=n(1-p(a.a,h.a,c)/255,0,1),o.push(u)}return o}getColorForContinuousDataValue(o,t){const s=this.rasterizedTransferFunction;if(this.colorStops.length<2||!Array.isArray(this.stretchRange)||this.stretchRange.length<2||s.length<256)return null;let e=this.stretchRange[0],r=this.stretchRange[1];if(e>r){const o=e;e=r,r=o}o=n(o,e,r);const i=s[Math.round((o-e)/(r-e)*(this._colorMapSize-1))].clone();return t||(i.a=1),i}};o([l({type:["linear","nearest"],json:{write:!0}})],g.prototype,"interpolation",void 0),o([l({type:[Number],json:{write:{enabled:!0,isRequired:!0}}})],g.prototype,"stretchRange",void 0),o([l({type:e.ofType(u),json:{write:{enabled:!0,overridePolicy(){return{enabled:!!this.colorStops&&this.colorStops.length>0}}}}})],g.prototype,"colorStops",null),o([l({type:e.ofType(m),json:{read:{source:"alphaStops"},write:{enabled:!0,target:"alphaStops",overridePolicy(){return{enabled:!!this.opacityStops&&this.opacityStops.length>0}}}}})],g.prototype,"opacityStops",null),o([l({type:f,json:{write:!0}})],g.prototype,"rangeFilter",void 0),o([l({type:[t],clonable:!1,json:{read:!1}})],g.prototype,"rasterizedTransferFunction",null),g=o([c("esri.layers.voxel.VoxelTransferFunctionStyle")],g);const b=g,S=["r","g","b"];export{b as default};
