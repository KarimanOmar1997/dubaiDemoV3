// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","./SimpleGeometryCursor","./Geometry","./Envelope","./Envelope2D","./MultiPathImpl","./Point2D"],(function(e,t,s,n,r,i,h){"use strict";function a(e,t,s,n,r){return o(e,t,null,s,n,r)}function o(e,t,i,h,o,l){const p=e.getGeometryType();if(p===s.GeometryType.enumPoint){const s=e.getXY();return t.contains(s)?e:e.createInstance()}if(p===s.GeometryType.enumEnvelope){const s=r.Envelope2D.constructEmpty();if(e.queryEnvelope(s),s.intersect(t)){const t=e.clone();return t.setEnvelope(s),t}return e.createInstance()}if(e.isEmpty())return e;if(t.isEmpty())return e.createInstance();const x=t.clone();{const t=new r.Envelope2D;if(e.queryLooseEnvelope(t),x.containsEnvelope(t))return e;if(!x.isIntersecting(t))return e.createInstance();0===o&&(t.intersect(x),t.inflate(Math.max(.1*t.maxDimension(),1)),t.intersect(x),x.assign(t))}let c=h;if((null!==i||Number.isNaN(c))&&(c=n.calculateToleranceFromGeometryForOp(i,x,!1).total()),p===s.GeometryType.enumGeometryCollection){const t=e,s=e.createInstance();for(let e=0,n=t.getGeometryCount();e<n;e++){const n=t.getGeometry(e);if(n.isEmpty())continue;const r=a(n,x,c,o,l);r.isEmpty()||(r===n?s.addGeometry(r.clone()):s.addGeometry(r))}return s}s.isMultiVertex(p)||s.throwInvalidArgumentException("Clip: geometry not supported");const u=e.getImpl().getAccelerators();if(null!==u){const e=u.getRasterizedGeometry();s.geometryReleaseAssert(null===e)}switch(p){case s.GeometryType.enumMultiPoint:{const t=e;let n;const r=t.getPointCount(),i=t.getImpl().getAttributeStreamRef(0);let h=0;for(let e=0;e<r;e++){const s=i.readPoint2D(2*e);x.contains(s)||(0===h&&(n=t.createInstance()),h<e&&n.addPoints(t,h,e),h=e+1)}return h>0&&n.addPoints(t,h,r),0===h?t:(s.geometryReleaseAssert(null!==n),n)}case s.GeometryType.enumPolygon:case s.GeometryType.enumPolyline:return function(e,t,s,n,r){return new m(t,r).clipMultiPath2(e,s,n)}(e,x,c,o,l);default:s.throwInternalErrorException("")}}class m{constructor(e,t){this.m_shape=new i.EditShape,this.m_geometry=i.nullHandle,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new r.Envelope2D(e),this.m_progressTracker=t}progress_(){}clipMultiPath2(e,t,n){return e.getGeometryType()===s.GeometryType.enumPolygon?this.clipPolygonOrProjectedPolyline2(e,n):this.clipPolyline(e,t)}clipPolygonOrProjectedPolyline2(e,t){const n=e.getGeometryType()===s.GeometryType.enumPolyline;if(0===this.m_extent.width()||0===this.m_extent.height())return e.createInstance();const a=r.Envelope2D.constructEmpty();e.queryLooseEnvelope(a),this.m_geometry=n?this.m_shape.addGeometry(e):this.m_shape.addGeometry(e,this.m_extent);const o=r.Envelope2D.constructEmpty(),l=r.Envelope2D.constructEmpty(),p=new h.Point2D,x=new h.Point2D,c=h.makePrimitiveArray(9,Number.NaN),u=h.makePrimitiveArray(9,Number.NaN),_=h.makeObjectArray(h.Point2D,9);let y=null;const g=new i.Line,d=[];let v=!1;for(let e=0;!v&&e<4;e++){let t=!1;const r=!!(1&e);let h=0;switch(e){case 0:h=this.m_extent.xmin,t=a.xmin<=h&&a.xmax>=h;break;case 1:h=this.m_extent.ymin,t=a.ymin<=h&&a.ymax>=h;break;case 2:h=this.m_extent.xmax,t=a.xmin<=h&&a.xmax>=h;break;case 3:h=this.m_extent.ymax,t=a.ymin<=h&&a.ymax>=h}if(t){v=!0;for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==i.nullHandle;){let a=!0,P=-1,f=-1;const E=this.m_shape.getFirstVertex(t);let I=E;do{this.progress_(),y=this.m_shape.getSegment(I);let t=y;if(null===t){const e=this.m_shape.getNextVertex(I);if(e===i.nullHandle){s.geometryReleaseAssert(n),0===P&&d.push(I);break}this.m_shape.queryXY(I,p),g.setStartXY(p),this.m_shape.queryXY(e,x),g.setEndXY(x),t=g}t.queryLooseEnvelope(o);let E=m.checkSegmentIntersection(o,e,h);t.isCurve()&&0===E&&t.isCurve()&&(g.setStartXY(t.getStartXY()),g.setEndXY(t.getEndXY()),this.m_shape.replaceCurveWithLine(I),t=g,g.queryEnvelope(o),E=m.checkSegmentIntersection(o,e,h));let V=0,S=i.nullHandle;if(-1===E){const n=t.intersectionWithAxis2D(r,h,c,u);if(n>0){let e=null;if(t.isCurve()){e=_,s.geometryReleaseAssert(n<=9);for(let e=0;e<n;e++)r?_[e].setCoords(c[e],h):_[e].setCoords(h,c[e]);V=this.m_shape.splitSegmentAxisAware(I,u,n,e,r?1:0)}else V=this.m_shape.splitSegmentAxisAware(I,u,n,null,-1)}else V=0;V+=1;let i=I,o=this.m_shape.getNextVertex(i);t=null;for(let t=0;t<V;t++){this.m_shape.queryXY(i,p),this.m_shape.queryXY(o,x),y=this.m_shape.getSegment(i);let t=y;null===t&&(g.setStartXY(p),g.setEndXY(x),t=g),t.queryEnvelope(l);let s=m.checkSegmentIntersection(l,e,h);t.isCurve()&&0===s&&(this.m_shape.replaceCurveWithLine(i),g.setStartXY(p),g.setEndXY(x),t=g,t.queryEnvelope(l),s=m.checkSegmentIntersection(l,e,h)),-1===s&&(r?Math.abs(p.y-h)<Math.abs(x.y-h)?(p.y=h,this.m_shape.setXY(i,p)):(x.y=h,this.m_shape.setXY(o,x)):Math.abs(p.x-h)<Math.abs(x.x-h)?(p.x=h,this.m_shape.setXY(i,p)):(x.x=h,this.m_shape.setXY(o,x)),y=this.m_shape.getSegment(i),t=y,null===t&&(g.setStartXY(p),g.setEndXY(x),t=g),t.queryEnvelope(l),s=m.checkSegmentIntersection(l,e,h),-1===s&&(s=m.checkSegmentIntersectionLoose(l,e,h)));const n=P;P=s,-1===f&&(f=P),0===n&&1===P||1===n&&0===P||0===n&&0===P&&d.push(i),1===P&&(v=!1,a=!1),i=o,S=i,o=this.m_shape.getNextVertex(o)}}if(0===V){const e=P;P=E,-1===f&&(f=P),0===e&&P>=1||e>=1&&0===P||0===e&&0===P&&d.push(I),1===P&&(v=!1,a=!1),S=this.m_shape.getNextVertex(I)}if(I=S,d.length>=256){for(let e=1,t=d.length-1;e<t;e++){const t=d[e];n?this.m_shape.snapVertexForPoleClipping(t,h):this.m_shape.removeVertex(t,!1)}d[1]=d.at(-1),d.length=2}}while(I!==E);if(!a){0!==f||!n&&0!==P&&2!==P||d.push(E);for(let e=0,t=d.length;e<t;e++){const t=d[e];n?this.m_shape.snapVertexForPoleClipping(t,h):this.m_shape.removeVertex(t,!1)}}d.length=0,t=a||0===this.m_shape.getPathSize(t)?this.m_shape.removePath(t):this.m_shape.getNextPath(t)}}}if(v)return e.createInstance();y=null,n?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),t>0&&this.densifyAlongClipExtent(t);const P=this.m_shape.getGeometry(this.m_geometry);return P.getGeometryType()===s.GeometryType.enumPolygon&&P.setFillRule(e.getFillRule()),P}clipPolyline(e,t){const s=r.Envelope2D.constructEmpty(),n=r.Envelope2D.constructEmpty(),a=h.makePrimitiveArray(9,Number.NaN),o=h.makePrimitiveArray(9,Number.NaN),l=new i.SegmentBuffer;let p=e;const x=r.Envelope2D.constructEmpty();e.queryLooseEnvelope(x);for(let t=0;t<4;t++){let r=!1;const i=!!(1&t);let c=0;switch(t){case 0:c=this.m_extent.xmin,r=x.xmin<=c&&x.xmax>=c;break;case 1:c=this.m_extent.ymin,r=x.ymin<=c&&x.ymax>=c;break;case 2:c=this.m_extent.xmax,r=x.xmin<=c&&x.xmax>=c;break;case 3:c=this.m_extent.ymax,r=x.ymin<=c&&x.ymax>=c}if(!r)continue;const u=p;p=e.createInstance();const _=u.getImpl().querySegmentIterator();_.resetToFirstPath();const y=new h.Point2D,g=new h.Point2D;for(;_.nextPath();){let e=-1,r=!0;for(;_.hasNextSegment();){this.progress_();const h=_.nextSegment(),x=h.isDegenerate(0);h.queryLooseEnvelope(s);const u=m.checkSegmentIntersection(s,t,c);if(-1===u){const s=h.intersectionWithAxis2D(i,c,a,o);let u=0;y.assign(h.getStartXY());for(let _=0;_<=s;_++){const d=_<s?o[_]:1;if(u===d)continue;h.queryCut(u,d,l,!1);const v=l.get();let P=!1;if(v.getStartXY().equals(y)||(v.setStartXY(y),P=!0),_<s&&(i?(g.x=a[_],g.y=c):(g.x=c,g.y=a[_]),v.getEndXY().equals(g)||(v.setEndXY(g),P=!0)),P&&v.normalizeAfterEndpointChange(),!x&&v.isDegenerate(0))continue;v.queryEnvelope(n);let f=m.checkSegmentIntersection(n,t,c);if(-1===f){const e=v.getStartXY(),s=v.getEndXY();P=!1,i?Math.abs(e.y-c)<Math.abs(s.y-c)?(e.y=c,v.setStartXY(e),e.equals(v.getStartXY())||(v.setStartXY(e),P=!0)):(s.y=c,s.equals(v.getEndXY())||(v.setEndXY(s),P=!0)):Math.abs(e.x-c)<Math.abs(s.x-c)?(e.x=c,e.equals(v.getStartXY())||(v.setStartXY(e),P=!0)):(s.x=c,s.equals(v.getEndXY())||(v.setEndXY(s),P=!0)),P&&v.normalizeAfterEndpointChange(),v.queryEnvelope(n),f=m.checkSegmentIntersection(n,t,c),-1===f&&(f=m.checkSegmentIntersectionLoose(n,t,c))}y.assign(v.getEndXY()),u=d,e=f,e>=1?(p.addSegment(v,r),r=!1):r=!0}}else e=u,e>=1?(p.addSegment(h,r),r=!1):r=!0}}}return p}static checkSegmentIntersection(e,t,n){switch(t){case 0:return e.xmin<n&&e.xmax<=n?0:e.xmin>=n?e.xmax===n?2:1:-1;case 1:return e.ymin<n&&e.ymax<=n?0:e.ymin>=n?e.ymax===n?2:1:-1;case 2:return e.xmin>=n&&e.xmax>n?0:e.xmax<=n?e.xmin===n?2:1:-1;case 3:return e.ymin>=n&&e.ymax>n?0:e.ymax<=n?e.ymin===n?2:1:-1}return s.throwInternalErrorException(""),0}static checkSegmentIntersectionLoose(e,t,n){switch(t){case 0:{const t=Math.abs(e.xmin-n),r=Math.abs(e.xmax-n);return e.xmin<n?t>r?0:1:(s.throwInternalErrorException(""),1)}case 1:{const t=Math.abs(e.ymin-n),r=Math.abs(e.ymax-n);return e.ymin<n?t>r?0:1:(s.throwInternalErrorException(""),1)}case 2:{const t=Math.abs(e.xmin-n),r=Math.abs(e.xmax-n);return e.xmax>n?t<r?0:1:(s.throwInternalErrorException(""),1)}case 3:{const t=Math.abs(e.ymin-n),r=Math.abs(e.ymax-n);return e.ymax>n?t<r?0:1:(s.throwInternalErrorException(""),1)}}return s.throwInternalErrorException(""),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const e=new h.Point2D;for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==i.nullHandle;t=this.m_shape.getNextPath(t)){let s=this.m_shape.getFirstVertex(t);for(let n=0,r=this.m_shape.getPathSize(t);n<r;n++,s=this.m_shape.getNextVertex(s))this.progress_(),this.m_shape.queryXY(s,e),this.m_extent.xmin!==e.x&&this.m_extent.xmax!==e.x&&this.m_extent.ymin!==e.y&&this.m_extent.ymax!==e.y||(this.m_shape.setUserIndex(s,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(s))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(e){const t=new h.Point2D(0,0),n=new h.Point2D(0,0),r=h.makePrimitiveArray(2048,Number.NaN);for(let a=this.m_shape.getFirstPath(this.m_geometry);a!==i.nullHandle;a=this.m_shape.getNextPath(a)){const i=this.m_shape.getFirstVertex(a);let o=i;do{const i=this.m_shape.getNextVertex(o);this.m_shape.queryXY(o,t);let a=-1;if(t.x===this.m_extent.xmin?(this.m_shape.queryXY(i,n),n.x===this.m_extent.xmin&&(a=1)):t.x===this.m_extent.xmax&&(this.m_shape.queryXY(i,n),n.x===this.m_extent.xmax&&(a=1)),t.y===this.m_extent.ymin?(this.m_shape.queryXY(i,n),n.y===this.m_extent.ymin&&(a=0)):t.y===this.m_extent.ymax&&(this.m_shape.queryXY(i,n),n.y===this.m_extent.ymax&&(a=0)),-1===a){o=i;continue}if(this.isCurve(o)){o=i;continue}const m=t.clone(),l=new h.Point2D(0,0);if(a){const s=t.y-this.m_extent.ymin;l.y=h.sign(n.y-t.y),m.y=e*h.copySign(Math.floor(Math.abs(s)/e),s)+this.m_extent.ymin,l.y<0&&(m.y+=e)}else{const s=t.x-this.m_extent.xmin;l.x=h.sign(n.x-t.x),m.x=e*h.copySign(Math.floor(Math.abs(s)/e),s)+this.m_extent.xmin,l.x<0&&(m.x+=e)}const p=a?n.y-t.y:n.x-t.x,x=Math.abs(p);if(x/e>65536&&s.throwInternalErrorException(""),x>0){const n=Math.trunc(x/e)+2;r.length<n&&(r.length=n);let i=0;for(let n=0;;n++){const h=m.add(l.mul(n*e)),o=(a?h.y-t.y:h.x-t.x)/p;if(o>=1)break;o<=0||(s.geometryReleaseAssert(i<=r.length),r[i]=o,i++)}0!==i&&this.m_shape.splitSegment(o,r,i)}o=i}while(o!==i)}}splitSegments(e,t){let s=-1;const n=new h.Point2D,r=[];for(let h=this.m_shape.getFirstPath(this.m_geometry);h!==i.nullHandle;h=this.m_shape.getNextPath(h)){let a=this.m_shape.getFirstVertex(h),o=i.nullHandle;for(let i=0,m=this.m_shape.getPathSize(h);i<m;i++,a=o)if(this.progress_(),o=this.m_shape.getNextVertex(a),this.m_shape.queryXY(a,n),(e?n.y===t:n.x===t)&&(this.m_shape.queryXY(o,n),e?n.y===t:n.x===t)){if(this.isCurve(a))continue;-1===s&&(s=this.m_shape.createUserIndex()),1!==this.m_shape.getUserIndex(a,s)&&(r.push(a),this.m_shape.setUserIndex(a,s,1)),1!==this.m_shape.getUserIndex(o,s)&&(r.push(o),this.m_shape.setUserIndex(o,s,1))}}if(-1!==s&&this.m_shape.removeUserIndex(s),r.length<3)return;r.sort(((e,t)=>this.compareVertices(e,t)));const a=new h.Point2D,o=new h.Point2D,m=new h.Point2D;o.setNAN();let l=-1,p=[],x=[];const c=this.m_shape.createUserIndex(),u=this.m_shape.createUserIndex();for(let s=0,i=r.length;s<i;s++){const i=r[s];if(this.m_shape.queryXY(i,n),!n.isEqualPoint2D(o)){if(-1===l){l=s,o.setCoordsPoint2D(n);continue}for(let n=l;n<s;n++){const s=r[n],i=this.m_shape.getNextVertex(s),h=this.m_shape.getPrevVertex(s);let m=!1;this.m_shape.queryXY(i,a),o.compare(a)<0&&(e?a.y===t:a.x===t)&&(this.isCurve(s)||(p.push(s),m=!0,this.m_shape.setUserIndex(s,u,1))),this.m_shape.queryXY(h,a),o.compare(a)<0&&(e?a.y===t:a.x===t)&&(this.isCurve(h)||(m||p.push(s),this.m_shape.setUserIndex(s,c,1)))}for(let e=0,t=p.length;e<t;e++){const t=p[e],s=this.m_shape.getUserIndex(t,c),r=this.m_shape.getUserIndex(t,u);if(1===s){const e=this.m_shape.getPrevVertex(t);this.m_shape.queryXY(e,m);let s=0;if(!m.isEqualPoint2D(n)){const r=h.Point2D.distance(o,m);s=h.Point2D.distance(m,n)/r,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(e,[s],1);const i=this.m_shape.getPrevVertex(t);this.m_shape.setXY(i,n),x.push(i),this.m_shape.setUserIndex(i,c,1),this.m_shape.setUserIndex(i,u,-1)}}if(1===r){const e=this.m_shape.getNextVertex(t);this.m_shape.queryXY(e,m);let s=0;if(!m.isEqualPoint2D(n)){const e=h.Point2D.distance(o,m);s=h.Point2D.distance(o,n)/e,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(t,[s],1);const r=this.m_shape.getNextVertex(t);this.m_shape.setXY(r,n),x.push(r),this.m_shape.setUserIndex(r,c,-1),this.m_shape.setUserIndex(r,u,1)}}}const i=p;p=x,x=i,x.length=0,l=s,o.setCoordsPoint2D(n)}}this.m_shape.removeUserIndex(c),this.m_shape.removeUserIndex(u)}resolveOverlaps(e,t){const n=new h.Point2D,r=[];let a=-1;for(let s=0,h=this.m_verticesOnExtent.length;s<h;s++){this.progress_();const h=this.m_verticesOnExtent[s];if(h===i.nullHandle)continue;const o=this.m_shape.getNextVertex(h);if(this.m_shape.queryXY(h,n),(e?n.y===t:n.x===t)&&(this.m_shape.queryXY(o,n),e?n.y===t:n.x===t)){if(this.isCurve(h))continue;-1===a&&(a=this.m_shape.createUserIndex()),-2!==this.m_shape.getUserIndex(h,a)&&(r.push(h),this.m_shape.setUserIndex(h,a,-2)),-2!==this.m_shape.getUserIndex(o,a)&&(r.push(o),this.m_shape.setUserIndex(o,a,-2))}}if(0===r.length)return void(-1!==a&&this.m_shape.removeUserIndex(a));s.geometryReleaseAssert(-1!==a),r.sort(((e,t)=>this.compareVertices(e,t)));for(let e=0,t=r.length;e<t;e++){const t=r[e];this.m_shape.setUserIndex(t,a,e)}const o=new h.Point2D,m=new h.Point2D;m.setNAN();let l=-1;for(let s=0,h=r.length;s<h;s++){this.progress_();const h=r[s];if(h!==i.nullHandle&&(this.m_shape.queryXY(h,n),!n.isEqualPoint2D(m))){if(-1!==l)for(;;){let n=!1;const h=s;for(let p=l;p<h;p++){const h=r[p];if(h===i.nullHandle)continue;let l=i.nullHandle;const x=this.m_shape.getNextVertex(h);this.m_shape.queryXY(x,o),m.compare(o)<0&&(e?o.y===t:o.x===t)&&(this.isCurve(h)||(l=x));let c=i.nullHandle;const u=this.m_shape.getPrevVertex(h);if(this.m_shape.queryXY(u,o),m.compare(o)<0&&(e?o.y===t:o.x===t)&&(this.isCurve(u)||(c=u)),l===i.nullHandle||c===i.nullHandle){if(l!==i.nullHandle||c!==i.nullHandle){for(let x=p+1;x<s;x++){const s=r[x];if(s===i.nullHandle)continue;const p=this.m_shape.getNextVertex(s);let u=i.nullHandle;this.m_shape.queryXY(p,o),m.compare(o)<0&&(e?o.y===t:o.x===t)&&(this.isCurve(s)||(u=p));const _=this.m_shape.getPrevVertex(s);let y=i.nullHandle;if(this.m_shape.queryXY(_,o),m.compare(o)<0&&(e?o.y===t:o.x===t)&&(this.isCurve(_)||(y=_)),u!==i.nullHandle&&y!==i.nullHandle){this.beforeRemoveVertex(s,r,a),this.m_shape.removeVertex(s,!1),this.beforeRemoveVertex(u,r,a),this.m_shape.removeVertex(u,!1),n=!0;break}if(l!==i.nullHandle&&y!==i.nullHandle){this.removeOverlap(r,h,l,s,y,a),n=!0;break}if(c!==i.nullHandle&&u!==i.nullHandle){this.removeOverlap(r,s,u,h,c,a),n=!0;break}}if(n)break}}else this.beforeRemoveVertex(h,r,a),this.m_shape.removeVertex(h,!1),this.beforeRemoveVertex(l,r,a),this.m_shape.removeVertex(l,!1),n=!0}if(!n)break}l=s,m.setCoordsPoint2D(n)}}this.m_shape.removeUserIndex(a)}beforeRemoveVertex(e,t,n){let r=this.m_shape.getUserIndex(e,n);s.geometryReleaseAssert(r>=0),t[r]=i.nullHandle,r=this.m_shape.getUserIndex(e,this.m_verticesOnExtentIndex),s.geometryReleaseAssert(r>=0),this.m_verticesOnExtent[r]=i.nullHandle;const h=this.m_shape.getPathFromVertex(e);h!==i.nullHandle&&this.m_shape.getFirstVertex(h)===e&&(this.m_shape.setFirstVertex(h,i.nullHandle),this.m_shape.setLastVertex(h,i.nullHandle))}removeOverlap(e,t,s,n,r,i){this.m_shape.setNextVertex(t,n),this.m_shape.setPrevVertex(n,t),this.m_shape.setPrevVertex(s,r),this.m_shape.setNextVertex(r,s),this.beforeRemoveVertex(n,e,i),this.m_shape.removeVertexInternal(n,!1),this.beforeRemoveVertex(r,e,i),this.m_shape.removeVertexInternal(r,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(e){for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==i.nullHandle;t=this.m_shape.getNextPath(t)){const s=this.m_shape.getPathSize(t);if(s<3)continue;let n=this.m_shape.getFirstVertex(t);const r=new h.Point2D;this.m_shape.queryXY(n,r);let i=r.y===e&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const a=new h.Point2D;this.m_shape.queryXY(n,a);let o=a.y===e&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const m=new h.Point2D;for(let t=0,h=s-2;t<h;t++,n=this.m_shape.getNextVertex(n)){this.progress_(),this.m_shape.queryXY(n,m);const t=m.y===e;o&&i&&t&&(a.x-r.x)*(m.x-a.x)<=0?(this.m_shape.removeVertex(this.m_shape.getPrevVertex(n),!1),a.setCoordsPoint2D(m),o=t&&!this.isCurve(n)):(r.setCoordsPoint2D(a),i=o,a.setCoordsPoint2D(m),o=t&&!this.isCurve(n))}}}fixPaths(){for(let e=0,t=this.m_verticesOnExtent.length;e<t;e++){const t=this.m_verticesOnExtent[e];t!==i.nullHandle&&this.m_shape.setPathToVertex(t,i.nullHandle)}const e=this.m_shape.hasCurves();let t=0,n=0;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==i.nullHandle;){const s=this.m_shape.getFirstVertex(e);if(s===i.nullHandle||e!==this.m_shape.getPathFromVertex(s)){const t=e;e=this.m_shape.getNextPath(e),this.m_shape.setFirstVertex(t,i.nullHandle),this.m_shape.removePathOnly(t);continue}let r=s,h=0;do{this.m_shape.setPathToVertex(r,e),h++,r=this.m_shape.getNextVertex(r)}while(r!==s);this.m_shape.setRingAreaValid(e,!1),this.m_shape.setLastVertex(e,this.m_shape.getPrevVertex(s)),this.m_shape.setPathSize(e,h),n+=h,t++,e=this.m_shape.getNextPath(e)}for(let r=0,h=this.m_verticesOnExtent.length;r<h;r++){let h=this.m_verticesOnExtent[r];if(h===i.nullHandle)continue;let a=this.m_shape.getPathFromVertex(h);if(a!==i.nullHandle)continue;a=this.m_shape.insertPath(this.m_geometry,i.nullHandle);let o=!1,m=0;const l=h;do{this.m_shape.setPathToVertex(h,a),m++,e&&m<=2&&(o||=this.isCurve(h)),h=this.m_shape.getNextVertex(h)}while(h!==l);if(o?0===m:m<=2){let e=this.m_shape.getUserIndex(l,this.m_verticesOnExtentIndex);s.geometryReleaseAssert(e>=0),this.m_verticesOnExtent[e]=i.nullHandle;const t=this.m_shape.removeVertex(l,!1);2===m&&(e=this.m_shape.getUserIndex(t,this.m_verticesOnExtentIndex),e>=0&&(this.m_verticesOnExtent[e]=i.nullHandle),this.m_shape.removeVertex(t,!1));const n=a;a=this.m_shape.getNextPath(a),this.m_shape.setFirstVertex(n,i.nullHandle),this.m_shape.removePathOnly(n)}else this.m_shape.setClosedPath(a,!0),this.m_shape.setPathSize(a,m),this.m_shape.setFirstVertex(a,l),this.m_shape.setLastVertex(a,this.m_shape.getPrevVertex(l)),this.m_shape.setRingAreaValid(a,!1),n+=m,t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,n);let r=0;for(let e=this.m_shape.getFirstGeometry();e!==i.nullHandle;e=this.m_shape.getNextGeometry(e))r+=this.m_shape.getPointCount(e);this.m_shape.setTotalPointCount(r)}dbgCheckPathFirst(){}isCurve(e){return null!==this.m_shape.getSegment(e)}compareVertices(e,t){const s=new h.Point2D;this.m_shape.queryXY(e,s);const n=new h.Point2D;return this.m_shape.queryXY(t,n),s.compare(n)}clipPolesOut(e,t){return this.clipPolygonOrProjectedPolyline2(e,t)}}class l extends t.GeometryCursor{constructor(e,t,r,i){super(),this.m_progressTracker=i,this.m_index=-1,e||s.throwInvalidArgumentException(""),this.m_envelope=t,this.m_inputGeometryCursor=e,this.m_spatialRefImpl=r,this.m_tolerance=n.calculateToleranceFromGeometryForOp(r,t,!1).total()}next(){let e;return(e=this.m_inputGeometryCursor.next())?(s.throwIfMesh(e),this.m_index=this.m_inputGeometryCursor.getGeometryID(),a(e,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}e.OperatorClip=class{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n){return new l(e,t,s,n)}execute(e,t,s,n){return function(e,t,s,n){return o(e,t,s,Number.NaN,0,n)}(e,t,s,n)}},e.clip$1=a,e.clipPolesOut=function(e,t,s,n,i,h){const a=new m(t,h),o=new r.Envelope2D;return e.queryLooseEnvelope(o),t.containsEnvelope(o)?e:t.isIntersecting(o)?a.clipPolesOut(e,i):e.createInstance()}}));