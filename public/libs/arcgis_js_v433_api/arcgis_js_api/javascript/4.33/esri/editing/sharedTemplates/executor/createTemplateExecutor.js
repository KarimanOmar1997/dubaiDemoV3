// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../Graphic","../../../core/Error","../../../core/Logger","../../../core/MapUtils","../../../core/promiseUtils","../../../core/uuid","../../templateUtils","./support/createFeatureServiceEdit","./support/executorUtils","./support/getBuilder","../../../geometry/support/jsonUtils","../../../networks/support/networkFieldUtils","../../../networks/support/typeUtils"],(function(e,t,r,o,i,a,s,l,n,u,p,c,d,m,y){"use strict";const f=()=>i.getLogger("esri.editing.sharedTemplates.executor.createTemplateExecutor"),T="globalid";async function g(e){const t=await c.getBuilder(e.builderType);return r=>t.execute({...r,templatePart:e})}function h(e,t,o){const{associationGraphics:i,associationsTable:a,edits:s,utilityNetworkHelper:n,relationships:u}=o,p=n.findAgat(e.graphic,e.layer),c=n.findAgat(t.graphic,t.layer);if(!p||!c)return;const d=n.findRules(p).map((r=>r.fromNetworkSource?.sourceId!==p.networkSourceId||r.fromAssetGroup?.assetGroupCode!==p.assetGroup||null!==r.fromAssetType?.assetTypeCode&&r.fromAssetType?.assetTypeCode!==p.assetType||r.toNetworkSource.sourceId!==c.networkSourceId||r.toAssetGroup?.assetGroupCode!==c.assetGroup||null!==r.toAssetType&&r.toAssetType?.assetTypeCode!==c.assetType?r.toNetworkSource.sourceId!==p.networkSourceId||r.toAssetGroup?.assetGroupCode!==p.assetGroup||null!==r.toAssetType&&r.toAssetType?.assetTypeCode!==p.assetType||r.fromNetworkSource.sourceId!==c.networkSourceId||r.fromAssetGroup?.assetGroupCode!==c.assetGroup||null!==r.fromAssetType?.assetTypeCode&&r.fromAssetType?.assetTypeCode!==c.assetType?null:{rule:r,from:{agat:c,item:t},to:{agat:p,item:e}}:{rule:r,from:{agat:p,item:e},to:{agat:c,item:t}})).filter((e=>e?.rule.ruleType===y.RuleType.RTJunctionEdgeConnectivity||e?.rule.ruleType===y.RuleType.RTEdgeJunctionEdgeConnectivity||e?.rule.ruleType===y.RuleType.RTContainment?null:e)).filter((e=>null!==e));if(0===d.length)return;const f=m.getAssociationsTableFields(a),g=new Set;for(const e of d){const t={};t[f.fromNetworkSourceId]=e.rule.fromNetworkSource.sourceId,t[f.fromGlobalId]=e.from.item.graphic.attributes[e.from.item.layer.globalIdField??T],t[f.fromTerminalId]=null,e.rule.fromTerminal&&(t[f.fromTerminalId]=e.rule.fromTerminal.terminalId),t[f.toNetworkSourceId]=e.rule.toNetworkSource.sourceId,t[f.toGlobalId]=e.to.item.graphic.attributes[e.to.item.layer.globalIdField??T],t[f.toTerminalId]=null,e.rule.toTerminal&&(t[f.toTerminalId]=e.rule.toTerminal.terminalId),t[f.associationType]=e.rule.ruleType,t[f.percentAlong]=null,t[f.isContentVisible]=e.rule.ruleType===y.RuleType.RTContainment?1:0,t[f.status]=0,t[f.globalId]=l.generateBracedUUID();const o=`${t[f.fromNetworkSourceId]}-${t[f.fromGlobalId]}-${t[f.toNetworkSourceId]}-${t[f.toGlobalId]}-${t[f.associationType]}`;if(g.has(o))continue;g.add(o);const n=new r({attributes:t,sourceLayer:a});i.add(n),s.push({id:a.layerId,graphic:n,tag:"",layer:a}),u.push({sourceGraphic:e.to.item.graphic,sourceLayerId:e.to.item.layer.layerId,destinationGraphic:n,destinationLayerId:a.layerId,sourceField:e.to.item.layer.globalIdField??T,destinationField:f.toGlobalId??T}),u.push({sourceGraphic:e.from.item.graphic,sourceLayerId:e.from.item.layer.layerId,destinationGraphic:n,destinationLayerId:a.layerId,sourceField:e.from.item.layer.globalIdField??T,destinationField:f.fromGlobalId??T})}}t.createTemplateExecutor=async function(t){if(!n.isLoadedSharedTemplate(t))throw new o("template-executor:template-not-loaded","The template must be loaded before it can be executed.");if(n.isSharedFeatureTemplate(t))return function(e){return t=>{const r=[],o=[];u.createFeatureServiceEdit({geometry:t,template:e,edits:r,relationships:o});const i=p.calculateExtent(r);return{edits:p.groupEditsByLayer(r),relationships:o,primary:r[0]??null,featureExtent:i,rotationPoint:i?.center??null}}}(t);if(n.isSharedGroupTemplate(t))return async function(e){const{definition:t}=e,r=await Promise.all(t.allParts.map(g));return(o,i)=>{const l=[],n=[],u=new Set,c=()=>{if(t.createUtilityNetworkAssociations&&"completion"===i){const{utilityNetwork:e,utilityNetworkAssociationsTable:r}=t;e&&r?function(e){const{edits:t,utilityNetworkHelper:r}=e,o=new Map;for(const e of t)""!==e.tag&&r.layerIdToSourceIdLookup.has(e.id)&&a.getOrCreateMapValue(o,e.tag,(()=>[])).push(e);for(const t of o.values())if(!(t.length<2))for(let r=0;r<t.length;r++){const o=t[r];for(let i=r+1;i<t.length;i++)h(o,t[i],e)}}({associationGraphics:u,associationsTable:r,edits:l,relationships:n,utilityNetworkHelper:e}):f().warn("Unable to create utility network associations between group template features. The utility network or its associations table is unavailable.")}const e=p.calculateExtent(l);return{associationGraphics:u,edits:p.groupEditsByLayer(l),relationships:n,primary:l[0]??null,featureExtent:e,rotationPoint:e?.center??null}};if(null==o)return f().warn("No geometry provided to group template executor. Result will be empty."),c();const d=r.map((t=>t({edits:l,mode:i,parentTemplate:e,relationships:n,shape:o}))).filter(s.isPromiseLike);return 0===d.length?c():Promise.all(d).then((()=>c()))}}(t);if(n.isSharedPresetTemplate(t))return async function(t){const{createPresetServiceEdit:r}=await new Promise(((t,r)=>e(["./support/createPresetServiceEdit"],t,r)));return(e,i,a=0)=>{if(!d.isPoint(e))throw new o("template-executor:invalid-input-geometry","The input geometry for a preset template must be a point.");const s=[],l=[],n=r({geometry:e,template:t,edits:s,relationships:l,rotation:a,mode:i});return{edits:p.groupEditsByLayer(s),relationships:l,primary:s[0]??null,featureExtent:p.calculateExtent(s),rotationPoint:n}}}(t);throw new o("template-executor:unsupported-template-type","The template type is not supported.")},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));