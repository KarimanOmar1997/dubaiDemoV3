// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../core/arrayUtils","./Axis","./spatialReferenceUtils"],(function(n,t,e,i){"use strict";function r(n,t){const e=t[0]-n[0],i=t[1]-n[1];if(n.length>2&&t.length>2){const r=n[2]-t[2];return Math.sqrt(e*e+i*i+r*r)}return Math.sqrt(e*e+i*i)}function o(n,t,e){const i=n[0]+e*(t[0]-n[0]),r=n[1]+e*(t[1]-n[1]);return n.length>2&&t.length>2?[i,r,n[2]+e*(t[2]-n[2])]:[i,r]}function s(n,t,e,i){const[r,o]=t,[s,l]=e,[u,c]=i,f=u-s,a=c-l,g=f*f+a*a,h=(r-s)*f+(o-l)*a,p=Math.min(1,Math.max(0,h/g));return n[0]=s+f*p,n[1]=l+a*p,n}function l(n,t,e,i,r,o){let s=e,l=i,u=r-s,c=o-l;if(0!==u||0!==c){const e=((n-s)*u+(t-l)*c)/(u*u+c*c);e>1?(s=r,l=o):e>0&&(s+=u*e,l+=c*e)}return u=n-s,c=t-l,u*u+c*c}function u(n,t=e.Axis.X,i=e.Axis.Y){let r=0;const o=n.length;let s=n[0];for(let e=1;e<o;e++){const o=n[e];r+=(o[t]-s[t])*(o[i]+s[i]),s=o}if(c(n)){const e=n[0];r+=(e[t]-s[t])*(e[i]+s[i])}return r>=0}function c(n){const e=n.length;return e>0&&!t.equals(n[0],n[e-1])}function f(n){if("rings"in n)for(const t of n.rings)c(t)&&t.push(t[0].slice())}function a(n,t){const e=i.getInfo(t);if(!e)return;const r=e.valid[0],o=e.valid[1],s=o-r;for(const t of n){let n=1/0,e=-1/0;for(const i of t){const t=g(i[0],r,o);n=Math.min(n,t),e=Math.max(e,t),i[0]=t}const i=e-n;s-i<i&&t.forEach((n=>{n[0]<0&&(n[0]+=s)}))}}function g(n,t,e){const i=e-t;return n<t?e-(t-n)%i:n>e?t+(n-t)%i:n}n.closeRings=f,n.closeRingsAndFixWinding=function(n){"rings"in n&&(f(n),function(n){if(!("rings"in n))return!1;if(0===n.rings.length||u(n.rings[0]))return!1;for(const t of n.rings)t.reverse()}(n))},n.distanceFromPointToPolygon=function(n,t,e){let i,r,o,s,u=!1,c=1/0;for(e.reset();e.nextPath();)if(e.nextPoint())for(i=e.x,r=e.y;e.nextPoint();)o=e.x,s=e.y,r>t!=s>t&&n<(o-i)*(t-r)/(s-r)+i&&(u=!u),c=Math.min(c,l(n,t,i,r,o,s)),i=o,r=s;return 0===c?0:(u?1:-1)*Math.sqrt(c)},n.distanceToSegmentSquared=l,n.geometryToCoordinates=function(n){if(!n)return null;if(Array.isArray(n))return n;const t=n.hasZ,e=n.hasM;if("point"===n.type)return e&&t?[n.x,n.y,n.z,n.m]:t?[n.x,n.y,n.z]:e?[n.x,n.y,n.m]:[n.x,n.y];if("polygon"===n.type)return n.rings.slice();if("polyline"===n.type)return n.paths.slice();if("multipoint"===n.type)return n.points.slice();if("extent"===n.type){const t=n.clone().normalize();if(!t)return null;let e=!1,i=!1;return t.forEach((n=>{n.hasZ&&(e=!0),n.hasM&&(i=!0)})),t.map((n=>{const t=[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]];if(e&&n.hasZ){const e=.5*(n.zmax-n.zmin);for(let n=0;n<t.length;n++)t[n].push(e)}if(i&&n.hasM){const e=.5*(n.mmax-n.mmin);for(let n=0;n<t.length;n++)t[n].push(e)}return t}))}return null},n.getLength=r,n.getMidpoint=function(n,t){return o(n,t,.5)},n.getPathLength=function(n){const t=n.length;let e=0;for(let i=0;i<t-1;++i)e+=r(n[i],n[i+1]);return e},n.getPointOnPath=function(n,t){if(t<=0)return n[0];const e=n.length;let i=0;for(let s=0;s<e-1;++s){const e=r(n[s],n[s+1]);if(t-i<e){const r=(t-i)/e;return o(n[s],n[s+1],r)}i+=e}return n[e-1]},n.hasCompatibleTopology=function(n,t){if(n===t)return!0;if(n.type!==t.type)return!1;if("point"===n.type||"mesh"===n.type||"extent"===n.type)return!0;if("multipoint"===n.type)return n.points.length===t.points.length;const[e,i]="polyline"===n.type?[n.paths,t.paths]:[n.rings,t.rings];return e.length===i.length&&e.every(((n,t)=>n.length===i[t].length))},n.isClockwise=u,n.projectPointOnLine=function(n,t,e,i){return s(n,t,e[i],e[i+1])},n.projectPointOnLineSeg=s,n.unnormalizeGeometryOnDatelineCrossing=function(n){return"polygon"!==n.type&&"polyline"!==n.type||a("polygon"===n.type?n.rings:n.paths,n.spatialReference),n},n.unnormalizeVerticesOnDatelineCrossing=a,n.unnormalizedCoordinate=g,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})}));