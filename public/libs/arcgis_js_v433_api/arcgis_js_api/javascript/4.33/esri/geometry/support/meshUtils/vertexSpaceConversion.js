// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Logger","../../../core/mathUtils","../../../core/unitUtils","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/math/mat4","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../spatialReferenceEllipsoidUtils","../../projection/computeTranslationToOriginAndRotation","../../projection/projectPointToVector","../meshVertexSpaceUtils","../spatialReferenceUtils","../../../chunks/vec3","./projection"],(function(t,n,r,e,o,i,a,l,c,s,u,f,g,p,m,T,E){"use strict";const A=()=>n.getLogger("esri.geometry.support.meshUtils.vertexSpaceConversion");function R(t,n){return n?.useEllipsoid&&m.isEarth(t)?u.WGS84ECEFSpatialReference:u.getSphericalPCPF(t)}function P(t,n){const r=new Float64Array(t.position.length);T.transformMat4(r,t.position,n);const e=t.normal?new Float32Array(t.normal.length):null,o=t.tangent?new Float32Array(t.tangent.length):null;return e&&t.normal&&E.transformNormal(t.normal,e,n),o&&t.tangent&&E.transformTangent(t.tangent,o,n),{position:r,normal:e,tangent:o}}function S(t,n,r,e){const o=v(n,r,e);x(o)||a.scale(t,t,[o,o,o])}function v(t,n,r){const e=!!(r&O.SOURCE),o=!!(r&O.TARGET),i=n?.sourceUnit,a=n?.targetUnit;if(!i&&!a)return 1;let l=F(i,t);e||!i||x(l)||(A().warn("source unit conversion not supported"),l=1);let c=1/F(a,t);return o||!a||x(c)||(A().warn("target unit conversion not supported"),c=1),l*c}function x(t){return r.floatEqualUlp(t,1)}function F(t,n){if(null==t)return 1;const r=e.getMetersPerCartesianUnitForSR(n);return 1/e.convertUnit(r,"meters",t)}const h=l.create(),j=l.create(),y=i.create(),C=s.create(),U=l.create();var O;!function(t){t[t.NONE=0]="NONE",t[t.SOURCE=1]="SOURCE",t[t.TARGET=2]="TARGET",t[t.SOURCE_AND_TARGET=3]="SOURCE_AND_TARGET"}(O||(O={})),t.convertVertexSpace=function(t,n,r){const{vertexSpace:e,transform:i,vertexAttributes:s}=t,u=p.isRelativeVertexSpace(e)?i:null,g=v(t.spatialReference,r,O.SOURCE_AND_TARGET);if(p.vertexSpaceEquals(e,n)&&(!u||a.exactEquals(u.localMatrix,l.IDENTITY))&&x(g)){const{position:t,normal:n,tangent:e}=s,o=r?.allowBufferReuse;return{position:o?t:t.slice(),normal:o?n:n?.slice(),tangent:o?e:e?.slice()}}switch(t.vertexSpace.type){case"local":return"local"===n.type?function({vertexAttributes:t,spatialReference:n,transform:r},{origin:e},o,i){const l=R(n,i);if(!f.computeTranslationToOriginAndRotation(n,e,h,l))return E.logProjectionError(A(),n,l),null;if(r&&a.multiply(h,h,r.localMatrix),!f.computeTranslationToOriginAndRotation(n,o,j,l))return E.logProjectionError(A(),l,n),null;a.invert(j,j);const c=a.multiply(h,j,h);return S(c,n,i,O.SOURCE_AND_TARGET),P(t,c)}(t,t.vertexSpace,n.origin,r):function({spatialReference:t,vertexAttributes:n,transform:r},{origin:e},o,i){const l=R(t,i);if(!f.computeTranslationToOriginAndRotation(t,e,h,l))return E.logProjectionError(A(),t,l),null;r&&a.multiply(h,h,r.localMatrix),S(h,t,i,O.SOURCE);const s=new Float64Array(n.position.length),u=function(t,n,r,e,o){T.transformMat4(e,t,n);const i=new Float64Array(t.length);return E.projectFromPCPF(e,o,i,r)?i:(E.logProjectionError(A(),o,r),null)}(n.position,h,t,s,l);if(!u)return null;const g=function(t,n,r,e,o,i){if(null==o)return null;const a=new Float32Array(o.length);return E.transformNormal(o,a,i),E.projectNormalFromPCPF(a,t,n,r,e,a)?a:(E.logProjectionError(A(),e,n),null)}(u,t,s,l,n.normal,h);if(n.normal&&!g)return null;const p=function(t,n,r,e,o,i){if(null==o)return null;const a=new Float32Array(o.length);return E.transformTangent(o,a,i),E.projectTangentFromPCPF(a,t,n,r,e,a)?a:(E.logProjectionError(A(),e,n),null)}(u,t,s,l,n.tangent,h);if(n.tangent&&!p)return null;if(o){const t=c.negate(C,o);T.translate(u,u,t)}return{position:u,normal:g,tangent:p}}(t,t.vertexSpace,n.origin,r);case"georeferenced":return"local"===n.type?function({vertexAttributes:t,spatialReference:n,transform:r},{origin:e},i,l){const c=R(n,l);if(!f.computeTranslationToOriginAndRotation(n,i,h,c))return E.logProjectionError(A(),n,c),null;const s=1/v(n,l,O.TARGET);a.scale(h,h,[s,s,s]);const u=a.invert(j,h),{position:g,normal:p,tangent:m}=function(t,n,r){if(!n)return t;if(!r){const{position:r,normal:e,tangent:o}=t;return{position:T.translate(new Float64Array(r.length),r,n),tangent:o,normal:e}}const e=P(t,r.localMatrix);return T.translate(e.position,e.position,n),e}(t,e,r),S=new Float64Array(g.length),x=function(t,n,r,e,o){const i=E.projectToPCPF(t,n,e,o);if(!i)return E.logProjectionError(A(),n,o),null;const a=new Float64Array(i.length);return T.transformMat4(a,i,r),a}(g,n,u,S,c);if(!x)return null;const F=o.normalFromMat4(y,u),C=function(t,n,r,e,o,i,a){if(null==t)return null;const l=a??new Float32Array(t.length);return E.projectNormalToPCPF(t,n,r,e,o,l)?(T.transformMat3(l,l,i),l):(E.logProjectionError(A(),r,o),null)}(p,g,n,S,c,F,p!==t.normal?p:void 0);if(!C&&p)return null;const U=function(t,n,r,e,o,i,a){if(null==t)return null;const l=a??new Float32Array(t.length);return E.projectTangentToPCPF(t,n,r,e,o,l)?(T.transformMat3(l,l,i,4),l):(E.logProjectionError(A(),r,o),null)}(m,g,n,S,c,F,m!==t.tangent?m:void 0);return!U&&m?null:{position:x,normal:C,tangent:U}}(t,t.vertexSpace,n.origin,r):function({vertexAttributes:t,transform:n,spatialReference:r},{origin:e},o,i){const s=v(r,i,O.SOURCE_AND_TARGET),u=e||!x(s)?a.copy(h,n?.localMatrix??l.IDENTITY):null;u&&S(u,r,i,O.SOURCE_AND_TARGET);const{position:f,normal:g,tangent:p}=u?P(t,u):t,m=i?.allowBufferReuse,E=m?f:new Float64Array(f.length);let A=f;if(e&&(A=T.translate(E,A,e)),o){const t=c.negate(C,o);A=T.translate(E,A,t)}return{position:A!==t.position||m?A:A.slice(),normal:g!==t.normal||m?g:g?.slice(),tangent:p!==t.tangent||m?p:p?.slice()}}(t,t.vertexSpace,n.origin,r)}},t.getUnitToSpatialReferenceScaleConversion=F,t.projectPointToVertexSpace=function(t,n,{vertexSpace:r,spatialReference:e}){if("georeferenced"===r.type){const o=t;if(!g.projectPointToVector(n,o,e))return!1;const{origin:i}=r;return c.subtract(t,o,i),!0}const o=u.getSphericalPCPF(e),i=t;if(!g.projectPointToVector(n,i,o))return!1;const{origin:l}=r,s=U;if(!f.computeTranslationToOriginAndRotation(e,l,s,o))return!1;const p=a.invert(U,s);return null!=p&&(c.transformMat4(t,i,p),!0)},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));