// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/maybe","../PixelBlock","../rasterFormats/pixelRangeUtils","../../../renderers/support/stretchRendererUtils"],(function(t,n,e,s,i){"use strict";const a=[.299,.587,.114];function o(t){if(null==t)return!1;const{max:n,min:e,size:s}=t;return(n-e)/s===1&&e>=-.5&&.5===Math.abs(e%1)&&n<=255.5}function r(t,n=256){n=Math.min(n,256);const{size:e,counts:s}=t,i=new Float64Array(e);i[0]=s[0]/n;for(let t=1;t<e;t++)i[t]=i[t-1]+s[t]/n;const a=new Uint8Array(n),r=n/i[i.length-1];if(e<=n){const s=o(t)?Math.max(0,Math.round(t.min+.5)):0;for(let t=s;t<n;t++)a[t]=t>=e+s?255:Math.min(255,Math.trunc(i[t-s]*r))}else{const t=i.map((t=>Math.min(255,Math.trunc(t*r))));for(let s=0;s<n;s++)a[s]=t[Math.round(e/n)];a[n-1]=255}return a}function l(t,n){const e=Math.min(Math.max(t,-100),100),s=Math.min(Math.max(n??0,-100),100),i=new Uint8Array(256);for(let t=0;t<256;t++){let n=0;e>0&&e<100?n=(200*t-25500+510*s)/(2*(100-e))+128:e<=0&&e>-100?n=(200*t-25500+510*s)*(100+e)/2e4+128:100===e?(n=200*t-25500+256*(100-e)+510*s,n=n>0?255:0):-100===e&&(n=128),i[t]=n>255?255:n<0?0:n}return i}function u(t){if(t<=0||t>=255)return 1;const n=t+(150===t?0:t<150?45*Math.cos(.01047*t):17*Math.sin(.021*t)),e=Math.log(t/255),s=Math.log(n/255);if(0===s)return 1;const i=e/s;return isNaN(i)?1:Math.min(9.9,Math.max(.01,i))}function c(t){if(!t?.pixels?.length)return null;const{pixels:n,mask:e,bandMasks:s,pixelType:i}=t,a=t.width*t.height,o=n.length,r=[],l=[],u=256;let c,m;for(let f=0;f<o;f++){let o=new Uint32Array(u);const h=n[f],g=s?.[f]??e;if("u8"===i){if(c=255,m=0,g){for(let t=0;t<a;t++)if(g[t]){const n=h[t];c=n<c?n:c,m=n>m?n:m,o[n]++}}else for(let t=0;t<a;t++){const n=h[t];c=n<c?n:c,m=n>m?n:m,o[n]++}o=o.slice(c,m+1)}else{let n=!1;t.statistics||(t.updateStatistics(),n=!0);const e=t.statistics;c=e[f].minValue,m=e[f].maxValue;const s=(m-c)/u;if(0===s){!e||t.validPixelCount||n||t.updateStatistics();const s=(t.validPixelCount||t.width*t.height)/u;for(let t=0;t<u;t++)o[t]=Math.round(s*(t+1))-Math.round(s*t)}else{const t=new Uint32Array(257);for(let n=0;n<a;n++)g&&!g[n]||t[Math.floor((h[n]-c)/s)]++;for(let n=0;n<255;n++)o[n]=t[n];o[255]=t[255]+t[256]}}const p="u8"===i?c-.5:c,d="u8"===i?m+.5:m;r.push({min:p,max:d,size:o.length,counts:o});let x=0,M=0,y=0;for(let t=0;t<o.length;t++)x+=o[t],M+=t*o[t];const O=M/x;for(let t=0;t<o.length;t++)y+=o[t]*(t-O)**2;const b=Math.sqrt(y/(x-1)),v=(d-p)/o.length,w=(O+("u8"===i?0:.5))*v+c,C=b*v;l.push({min:c,max:m,avg:w,stddev:C})}return{statistics:l,histograms:r}}function m(t,n){const e=new Float32Array(t);for(let s=0;s<t;s++)n[s]>1?n[s]>2?e[s]=6.5+(n[s]-2)**2.5:e[s]=6.5+100*(2-n[s])**4:e[s]=1;return e}t.computeGammaCorrection=m,t.computeGammaValues=function(t,n,e){const s=[];for(let i=0;i<n.length;i++){let o=0,r=0,l=0;"min"in n[i]?({min:o,max:r,avg:l}=n[i]):[o,r,l]=n[i];let c=l??0;"u8"!==t&&(c=255*(c-o)/(r-o)),e&&(c*=a[i]),s.push(u(c))}return s},t.computeStatisticsHistograms=function(t){const{pixels:n,mask:e,pixelType:s,bandMasks:i}=t,a=n.map(((t,n)=>function(t,n,e){let s=1/0,i=-1/0,a=0,o=0,r=0,l=0;const u=t.length,c=new Map,m=[];for(let e=0;e<u;e++){const u=t[e];if(!n||n[e]){m.push(u);const t=(c.get(u)??0)+1;c.set(u,t),t>l&&(l=t,r=u),s=u<s?u:s,i=u>i?u:i,a+=u,o++}}if(0===o)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const f=a/o;let h=0;for(let e=0;e<u;e++)n&&!n[e]||(h+=(t[e]-f)**2);const g=n?n.filter((t=>t)).length:u,p=g<=1?0:Math.sqrt(h/(g-1));m.sort(((t,n)=>t-n));const d=o>>>1,x={min:s,max:i,avg:f,stddev:p,mode:r,median:o%2?m[Math.floor(d)]:(m[d-1]+m[d])/2};if(["u8","s8","u4","u2","u1"].includes(e)){const e=i-s+1,a=new Uint32Array(e);for(let e=0;e<u;e++)n&&!n[e]||a[t[e]-s]++;return{statistics:x,histogram:{min:s-.5,max:i+.5,size:e,counts:a}}}const M=new Uint32Array(256),y=(i-s)/256;if(0===y)return{statistics:x,histogram:{min:s,max:i,size:1,counts:new Uint32Array(1).fill(o)}};const O=new Uint32Array(257);for(let e=0;e<u;e++)n&&!n[e]||O[Math.floor((t[e]-s)/y)]++;for(let t=0;t<255;t++)M[t]=O[t];return M[255]=O[255]+O[256],{statistics:x,histogram:{min:s,max:i,size:256,counts:M}}}(t,i?.[n]??e,s)));return{statistics:a.map((({statistics:t})=>t)),histograms:a.map((({histogram:t})=>t))}},t.createContrastBrightnessLUT=l,t.createHistogramEqualizationLUT=r,t.createStretchLUT=function(t){const{minCutOff:n,maxCutOff:e,gamma:s,pixelType:i,rounding:a}=t;if(!["u8","u16","s8","s16"].includes(i))return null;const o=n.length,r="s8"===i?-127:"s16"===i?-32767:0,u=["u16","s16"].includes(i)?65536:256,c=[],f=[],{minOutput:h=0,maxOutput:g=255}=t,p=g-h;for(let t=0;t<o;t++)f[t]=e[t]-n[t],c[t]=0===f[t]?0:p/f[t];const d=[];if(s&&s.length>=o){const t=m(o,s);for(let i=0;i<o;i++){const o=[];for(let l=0;l<u;l++){if(0===f[i]){o[l]=h;continue}const u=l+r,c=(u-n[i])/f[i];let m=1;if(s[i]>1&&(m-=(1/p)**(c*t[i])),u<e[i]&&u>n[i]){const t=m*p*c**(1/s[i])+h;o[l]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}else u>=e[i]?o[l]=g:o[l]=h}d[i]=o}}else for(let t=0;t<o;t++){const s=[];for(let i=0;i<u;i++){const o=i+r;if(o<=n[t])s[i]=h;else if(o>=e[t])s[i]=g;else{const e=(o-n[t])*c[t]+h;s[i]="floor"===a?Math.floor(e):"round"===a?Math.round(e):e}}d[t]=s}if(null!=t.contrastOffset){const n=l(t.contrastOffset,t.brightnessOffset);for(let t=0;t<o;t++){const e=d[t];for(let t=0;t<u;t++)e[t]=n[e[t]]}}return{lut:d,offset:r}},t.estimateStatisticsFromHistograms=function(t){const n=[];for(let e=0;e<t.length;e++){const{min:s,max:i,size:a,counts:o}=t[e];let r=0,l=0;for(let t=0;t<a;t++)r+=o[t],l+=t*o[t];const u=l/r;let c=0;for(let t=0;t<a;t++)c+=o[t]*(t-u)**2;const m=(i-s)/a,f=(u+.5)*m+s,h=Math.sqrt(c/(r-1))*m;n.push({min:s,max:i,avg:f,stddev:h})}return n},t.estimateStatisticsHistograms=c,t.getStretchCutoff=function(t,e){const{pixelBlock:a,bandIds:o,returnHistogramLut:l,rasterInfo:u}=e;let m=null,f=null,h=t.stretchType;if("number"==typeof h&&(h=i.stretchTypeFunctionEnum[h]),t.dra)if("minMax"===h&&a?.statistics)m=a.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=c(a);m=null!=t?t.statistics:null,f=null!=t?t.histograms:null}else m=t.statistics?.length?t.statistics:u.statistics,f="histograms"in t?t.histograms:void 0,f||(f=u.histograms);"percentClip"!==h&&"histogramEqualization"!==h||f?.length||(h="minMax");const g=m?.length||f?.length||u.bandCount,p=[],d=[];m&&!Array.isArray(m[0])&&(m=m.map((t=>[t.min,t.max,t.avg,t.stddev])));const[x,M]=s.getPixelValueRange(u.pixelType);if(!m?.length){m=[];for(let t=0;t<g;t++)m.push([x,M,1,1]);"standardDeviation"===h&&(h="minMax")}switch(h){case"none":for(let t=0;t<g;t++)p[t]=x,d[t]=M;break;case"minMax":for(let t=0;t<g;t++){const n=m[t];p[t]=n[0],d[t]=n[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:n=2}=t;for(let t=0;t<g;t++){const e=m[t];p[t]=e[2]-n*e[3],d[t]=e[2]+n*e[3],p[t]<e[0]&&(p[t]=e[0]),d[t]>e[1]&&(d[t]=e[1])}}break;case"histogramEqualization":n.assertIsSome(f);for(let t=0;t<g;t++)p[t]=f[t].min,d[t]=f[t].max;break;case"percentClip":n.assertIsSome(f);for(let n=0;n<f.length;n++){const e=f[n],s=new Uint32Array(e.size),i=[...e.counts];i.length>=20&&(i[0]=i[1]=i[2]=i[i.length-1]=i[i.length-2]=0);let a=0;const o=(e.max-e.min)/e.size,r=-.5===e.min&&1===o?.5:0;for(let t=0;t<e.size;t++)a+=i[t],s[t]=a;let l=(t.minPercent||0)*a/100;p[n]=e.min+r;for(let t=0;t<e.size;t++)if(s[t]>l){p[n]=e.min+o*(t+r);break}l=(1-(t.maxPercent||0)/100)*a,d[n]=e.max+r;for(let t=e.size-2;t>=0;t--)if(s[t]<l){d[n]=e.min+o*(t+2-r);break}if(d[n]<p[n]){const t=p[n];p[n]=d[n],d[n]=t}}break;default:for(let t=0;t<g;t++){const n=m[t];p[t]=n[0],d[t]=n[1]}}let y,O,b;return"histogramEqualization"===h?(n.assertIsSome(f),O=f[0].size||256,y=0,l&&(b=f.map((t=>r(t))))):(O=t.max||255,y=t.min||0),function(t,n){if(null==n||0===n.length)return t;const e=Math.max.apply(null,n),{minCutOff:s,maxCutOff:i,minOutput:a,maxOutput:o,histogramLut:r}=t;return s.length===n.length||s.length<=e?t:{minCutOff:n.map((t=>s[t])),maxCutOff:n.map((t=>i[t])),histogramLut:r?n.map((t=>r[t])):null,minOutput:a,maxOutput:o}}({minCutOff:p,maxCutOff:d,maxOutput:O,minOutput:y,histogramLut:b},o)},t.isStandardU8Histogram=o,t.stretch=function(t,n){if(!t?.pixels?.length)return t;const{mask:s,bandMasks:i,width:a,height:o,pixels:r}=t,{minCutOff:l,maxCutOff:u,minOutput:c,maxOutput:f,gamma:h}=n,g=a*o,p=n.outputPixelType||"u8",d=t.pixels.map((()=>e.createEmptyBand(p,g))),x=d.length,M=f-c,y=[],O=[];for(let t=0;t<x;t++)O[t]=u[t]-l[t],y[t]=0===O[t]?0:M/O[t];const b=p.startsWith("u")||p.startsWith("s"),v=h&&h.length>=x,w=!!n.isRenderer;if(v){const t=m(x,h);for(let n=0;n<x;n++){const e=i?.[n]??s;for(let s=0;s<g;s++)if(null==e||e[s]){if(0===O[n]){d[n][s]=c;continue}const e=r[n][s],i=(e-l[n])/O[n];let a=1;if(h[n]>1&&(a-=(1/M)**(i*t[n])),e<u[n]&&e>l[n]){const t=a*M*i**(1/h[n])+c;d[n][s]=w?Math.floor(t):b?Math.round(t):t}else e>=u[n]?d[n][s]=f:d[n][s]=c}}}else for(let t=0;t<x;t++){const n=i?.[t]??s;for(let e=0;e<g;e++)if(null==n||n[e]){const n=r[t][e];if(n<u[t]&&n>l[t]){const s=(n-l[t])*y[t]+c;d[t][e]=w?Math.floor(s):b?Math.round(s):s}else n>=u[t]?d[t][e]=f:d[t][e]=c}}const C=new e({width:a,height:o,mask:s,bandMasks:i,pixels:d,pixelType:p});return C.updateStatistics(),C},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));