// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["require","../chunks/tslib.es6","../Graphic","../request","../core/Error","../core/Loadable","../core/Logger","../core/MultiOriginJSONSupport","../core/promiseUtils","../core/urlUtils","../core/accessorSupport/decorators/property","../core/has","../core/RandomLCG","../core/accessorSupport/decorators/subclass","../geometry/Extent","../geometry/SpatialReference","../geometry/support/jsonUtils","../layers/mixins/EditBusLayer","../layers/support/arcgisLayerUrl","./support/TopologyValidationJobInfo","./support/utils","../versionManagement/support/versionManagementUtils"],(function(e,t,r,o,s,a,i,n,l,d,u,c,p,y,h,m,f,g,v,w,S,_){"use strict";const I=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"}));let b=class extends(n.MultiOriginJSONMixin(a)){static fromPortalItem(e){return S.networkFromPortalItem(e)}constructor(e){super(e),this.id=null,this.title=null,this.layerUrl=null,this.dataElement=null,this.fullExtent=null,this.spatialReference=null,this.type=null,this.sourceJSON=null,this.gdbVersion=null,this.historicMoment=null,this._sourceIdByLayerId=new Map,this._layerIdBySourceId=new Map,this._applyEditsHandler=e=>{const{serviceUrl:t,gdbVersion:r,result:o}=e,s=t===this.featureServiceUrl,a=g.versionMatches(t,r,this.gdbVersion);s&&a&&o.then((e=>{_.isVersionInEditSession(t,r)&&(this.historicMoment=e.historicMoment)}))},this._updateMomentHandler=e=>{const{serviceUrl:t,gdbVersion:r,moment:o}=e,s=t===this.featureServiceUrl,a=g.versionMatches(t,r,this.gdbVersion);s&&a&&(this.historicMoment=o)},this.when().then((()=>{this.addHandles([g.onApplyEditsEvent(this._applyEditsHandler),g.onUpdateMomentEvent(this._updateMomentHandler)])}),(()=>{}))}initialize(){this.when().catch((e=>{l.isAbortError(e)||i.getLogger(this).error("#load()",`Failed to load layer (title: '${this.title??"no title"}', id: '${this.id??"no id"}')`,{error:e})}))}get datasetName(){return this.dataElement?.name??null}get owner(){return this.dataElement?.userIdentity??null}get schemaGeneration(){return this.dataElement?.schemaGeneration??null}get parsedUrl(){return d.urlToObject(this.layerUrl)}get featureServiceUrl(){return v.parse(this.parsedUrl.path).url.path}get networkServiceUrl(){return this.featureServiceUrl.replace(/\/FeatureServer/i,"/UtilityNetworkServer")}get layerId(){return v.parse(this.parsedUrl.path).sublayer}get networkSystemLayers(){return null}async load(e){return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl,this.layerId.toString(),e)),this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl,e)),this}getLayerIdBySourceId(e){if(!this.dataElement)return null;const t=this._layerIdBySourceId.get(e);if(null!=t)return t;const r=this.dataElement.domainNetworks,o=this._traverseNetworkSources(r,this._layerIdBySourceId,"sourceId","layerId",e);return o>=0?o:null}getSourceIdByLayerId(e){if(!this.dataElement)return null;const t=this._sourceIdByLayerId.get(e);if(null!=t)return t;const r=this.dataElement.domainNetworks,o=this._traverseNetworkSources(r,this._sourceIdByLayerId,"layerId","sourceId",e);return o>=0?o:null}getObjectIdsFromElements(e){const t=[],r=new Map;for(const t of e){const e=this.getLayerIdBySourceId(t.networkSourceId);if(null==e)continue;let o=r.get(e);void 0===o&&(o=[]),o.push(t.objectId),r.set(e,o)}const o=this.featureServiceUrl;return r.forEach(((e,r)=>t.push({layerUrl:`${o}/${r}`,objectIds:e}))),t}async queryNamedTraceConfigurations(t,r){const[{queryNamedTraceConfigurations:o},{default:s}]=await Promise.all([new Promise(((t,r)=>e(["../rest/networks/queryNamedTraceConfigurations"],t,r))),new Promise(((t,r)=>e(["../rest/networks/support/QueryNamedTraceConfigurationsParameters"],(e=>t(I(e))),r)))]),a=this.networkServiceUrl,i=s.from(t);return(await o(a,i,{...r}))?.namedTraceConfigurations}async validateTopology(t,r){if(!t.validateArea)throw new s("network:undefined-validateArea","the network must have validateArea defined in the validate network topology parameters.");const[{validateNetworkTopology:o},{default:a}]=await Promise.all([new Promise(((t,r)=>e(["../rest/networks/validateNetworkTopology"],t,r))),new Promise(((t,r)=>e(["../rest/networks/support/ValidateNetworkTopologyParameters"],(e=>t(I(e))),r)))]),i=a.from(t);_.isVersionInEditSession(this.featureServiceUrl,this.gdbVersion||null)?(i.sessionID=_.currentSessionId,await _.isSafeToEditVersion(this.featureServiceUrl,this.gdbVersion,!0)):i.sessionID=null,i.gdbVersion=this.gdbVersion;const n=this.networkServiceUrl,l=this.featureServiceUrl,d=g.emitApplyEditsEvent(l,null,this.gdbVersion,!0),u=await o(n,i,{...r});if(u?.serviceEdits){const e=[];for(const t of u.serviceEdits){const{editedFeatures:r}=t,o=r?.spatialReference?new m(r.spatialReference):null;e.push({layerId:t.layerId,editedFeatures:{adds:r?.adds?.map((e=>E(e,o)))||[],updates:r?.updates?.map((e=>({original:E(e[0],o),current:E(e[1],o)})))||[],deletes:r?.deletes?.map((e=>E(e,o)))||[],spatialReference:o}})}d.resolve({edits:null,addedFeatures:[],updatedFeatures:[],deletedFeatures:[],addedAttachments:[],updatedAttachments:[],deletedAttachments:[],editedFeatures:e,exceededTransferLimit:!1,historicMoment:u.moment})}return u}async submitTopologyValidationJob(t,r){let a=null;if(!t.validateArea)throw new s("network:undefined-validateArea","the network must have validateArea defined in the validate network topology parameters.");if(!this.gdbVersion){const e=this.layerUrl.replace(/\/FeatureServer/i,"/VersionManagementServer").replace(/\/\d*$/,"");a=(await o(e,{responseType:"json",query:{f:"json"}})).data.defaultVersionName}const[{submitValidateNetworkTopologyJob:i},{default:n}]=await Promise.all([new Promise(((t,r)=>e(["../rest/networks/validateNetworkTopology"],t,r))),new Promise(((t,r)=>e(["../rest/networks/support/ValidateNetworkTopologyParameters"],(e=>t(I(e))),r)))]),l=n.from(t);_.isVersionInEditSession(this.featureServiceUrl,this.gdbVersion||null)?(l.sessionID=_.currentSessionId,await _.isSafeToEditVersion(this.featureServiceUrl,this.gdbVersion,!0)):l.sessionID=null,l.gdbVersion=this.gdbVersion||a;const d=this.networkServiceUrl,u=this.featureServiceUrl?g.emitApplyEditsEvent(this.featureServiceUrl,null,this.gdbVersion,!0):void 0,c=await i(d,l,{...r});return new w({statusUrl:c,editsResolver:u})}getSourceTypeById(e){if(!this.dataElement)return null;for(const t of this.dataElement.domainNetworks)for(const r of[t.edgeSources??[],t.junctionSources??[]])for(const o of r)if(o.sourceId===e)return r===t.edgeSources?"edge":"junction";return null}_traverseNetworkSources(e,t,r,o,s){for(const a of e)for(const e of[a.edgeSources??[],a.junctionSources??[]])for(const a of e)if(a[r]===s)return t.set(s,a[o]),a[o];return-1}async _fetchLayerMetaData(e,t){const r=await o(e,{responseType:"json",query:{f:"json"},...t});this.sourceJSON=r.data,this.read(r.data,{origin:"service"})}async _fetchDataElement(e,t,r){if(this.dataElement)return;const s=await o(`${e}/queryDataElements`,{responseType:"json",query:{layers:JSON.stringify([t]),f:"json"},...r}).then((e=>e.data.layerDataElements?.[0]));s&&this.read(s,{origin:"service"})}};function E(e,t){return new r({attributes:e.attributes,geometry:f.fromJSON({...e.geometry,spatialReference:t})})}return t.__decorate([u.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:!0}},read:!1}})],b.prototype,"id",void 0),t.__decorate([u.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:{source:"name"}}},read:!1}})],b.prototype,"title",void 0),t.__decorate([u.property({type:String,nonNullable:!0,json:{origins:{"web-map":{read:{source:"url"},write:{target:"url",isRequired:!0}}},read:!1}})],b.prototype,"layerUrl",void 0),t.__decorate([u.property({type:Object,json:{origins:{service:{read:!0}},read:!1}})],b.prototype,"dataElement",void 0),t.__decorate([u.property({type:h,json:{origins:{service:{read:{source:"extent"}}},read:!1}})],b.prototype,"fullExtent",void 0),t.__decorate([u.property({type:m,json:{origins:{service:{read:{source:"extent.spatialReference"}}},read:!1}})],b.prototype,"spatialReference",void 0),t.__decorate([u.property({type:["utility","trace"],readOnly:!0,json:{read:!1,write:!1}})],b.prototype,"type",void 0),t.__decorate([u.property({readOnly:!0})],b.prototype,"datasetName",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"owner",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"schemaGeneration",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"parsedUrl",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"featureServiceUrl",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"networkServiceUrl",null),t.__decorate([u.property({readOnly:!0})],b.prototype,"layerId",null),t.__decorate([u.property()],b.prototype,"sourceJSON",void 0),t.__decorate([u.property({readOnly:!0})],b.prototype,"networkSystemLayers",null),t.__decorate([u.property()],b.prototype,"gdbVersion",void 0),t.__decorate([u.property({type:Date})],b.prototype,"historicMoment",void 0),b=t.__decorate([y.subclass("esri.networks.Network")],b),b}));