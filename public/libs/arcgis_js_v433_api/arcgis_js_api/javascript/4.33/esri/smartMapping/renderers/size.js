// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../core/colorUtils","../../core/Error","../../core/screenUtils","../../core/accessorSupport/ensureType","../../intl/messages","../../renderers/ClassBreaksRenderer","../../renderers/support/AuthoringInfo","../../renderers/support/AuthoringInfoSizeStop","../../renderers/support/AuthoringInfoVisualVariable","../../renderers/support/utils","../../renderers/visualVariables/SizeVariable","../../renderers/visualVariables/support/castSizeVariable","../../renderers/visualVariables/support/SizeStop","../../renderers/visualVariables/support/SizeVariableLegendOptions","../../renderers/visualVariables/support/sizeVariableUtils","../heuristics/ageUnit","../heuristics/outline","../heuristics/referenceSize","../heuristics/sizeRange","./type","./support/referenceSizeUtils","./support/regenerateUtils","./support/spikeUtils","./support/utils","../statistics/support/ageUtils","../support/binningUtils","../support/utils","../support/adapters/support/layerUtils","../symbology/size","../../symbols/support/utils"],(function(e,i,a,r,n,s,l,t,o,u,m,p,d,c,y,f,b,z,v,h,g,w,S,V,T,x,k,E,O,F,I){"use strict";const B=2**53-1,R=[5,112.5];async function C(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new a("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new a("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&k.verifyBinningParams(e,"size-visual-variable");const i={...e},r=e.forBinning?O.binningCapableLayerTypes:O.featureCapableLayerTypes,n=O.createLayerAdapter(i.layer,r,e.forBinning);if(!n)throw new a("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(r).join(", "));"height"===i.axis&&(i.sizeOptimizationEnabled=!1);const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new a("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(i.worldScale){if("polyline"===l||"polygon"===l)throw new a("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!i.view||"3d"!==i.view.type)throw new a("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new a("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===i.theme&&!e.forBinning&&"polygon"!==l&&"point"!==l)throw new a("size-visual-variable:invalid-parameters","Spike is only supported for point and polygon layers");const t=await E.getFieldsList({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),o=T.verifyBasicFieldValidity(n,t,"size-visual-variable:invalid-parameters");if(o)throw o;return"spike"!==i.theme||i.spikeOptions?.symbolStyle||(i.spikeOptions??={},i.spikeOptions.symbolStyle=V.defaultSpikeSymbolStyle),await q(i),{...i,layer:n}}async function L(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k.verifyBinningParams(e,"size-continuous-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=e.forBinning?O.binningCapableLayerTypes:O.featureCapableLayerTypes,n=O.createLayerAdapter(i.layer,r,e.forBinning);if(!n)throw new a("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(r).join(", "));const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="reference-size"!==i.theme&&"spike"!==i.theme&&"polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new a("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new a("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new a("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===i.theme&&!e.forBinning&&"polygon"!==l&&"point"!==l)throw new a("size-continuous-renderer:invalid-parameters","Spike is only supported for point and polygon layers");const o=await E.getFieldsList({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),u=T.verifyBasicFieldValidity(n,o,"size-continuous-renderer:invalid-parameters");if(u)throw u;return"spike"!==i.theme||i.spikeOptions?.symbolStyle||(i.spikeOptions??={},i.spikeOptions.symbolStyle=V.defaultSpikeSymbolStyle),await q(i),{...i,layer:n}}async function q(e){const i=e.layer;if(("polygon"===i.geometryType||e.forBinning)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await v({layer:i,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function A(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new a("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new a("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k.verifyBinningParams(e,"size-class-breaks-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0,i.classificationMethod??="equal-interval",i.normalizationType=E.getNormalizationType(i);const r=e.forBinning?O.binningCapableLayerTypes:O.featureCapableLayerTypes,n=O.createLayerAdapter(i.layer,r,e.forBinning);if(!n)throw new a("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(r).join(", "));if(!(null!=i.minValue&&null!=i.maxValue||null==i.minValue&&null==i.maxValue))throw new a("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new a("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new a("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await E.getFieldsList({field:i.field,normalizationField:i.normalizationField}),u=T.verifyBasicFieldValidity(n,o,"size-class-breaks-renderer:invalid-parameters");if(u)throw u;return{...i,layer:n}}function D(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}function P(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric"),r=i;return r.worldScale=a,a&&(r.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,r}async function U(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new a("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const i={...e};i.symbolType??="2d",i.defaultSymbolEnabled??=!0;const r=O.createLayerAdapter(i.layer,O.featureCapableLayerTypes);if(!r)throw new a("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(O.featureCapableLayerTypes).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await r.load(n);const s=r.geometryType,l=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,"mesh"===s)throw new a("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new a("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=x.verifyDates(r,i.startTime,i.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(i.unit&&!x.supportedAgeUnits.includes(i.unit))throw new a("size-age-renderer:invalid-unit",`Supported units are: ${x.supportedAgeUnits.join(", ")}`);return{...i,layer:r}}async function G(e){let i=e.sizeScheme,a=null,r=null;const n=await T.getBasemapInfo(e.basemap,e.view);if(a=null!=n.basemapId?n.basemapId:null,r=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:F.cloneScheme(i),basemapId:a,basemapTheme:r};const s=F.getSchemes({basemapTheme:r,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,a=s.basemapId,r=s.basemapTheme),{scheme:i,basemapId:a,basemapTheme:r}}function M(e,i){switch(i){case"point":case"multipoint":{const i=e;return[d.castSizeFromStringOrNumber(i.minSize),d.castSizeFromStringOrNumber(i.maxSize)]}case"polyline":{const i=e;return[d.castSizeFromStringOrNumber(i.minWidth),d.castSizeFromStringOrNumber(i.maxWidth)]}case"polygon":{const i=e;return[d.castSizeFromStringOrNumber(i.marker.minSize),d.castSizeFromStringOrNumber(i.marker.maxSize)]}}}function W(e,i){e.transformationType===f.TransformationType.ClampedLinear&&"below"===i&&e.flipSizes()}function j(e,i,a,r){return"spike"===r?[a?.minHeight??R[0],a?.maxHeight??R[1]]:"reference-size"===r&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function N(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,a=0,r=0,n=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,u=0!==s?o/s:0,m=l>r&&l<n&&t<2*n&&u<.5,p=l>a&&l<i&&t<2*i&&u<.5;return{minDataValue:m?r:p?a:l,maxDataValue:m?n:p?i:s+2*o,defaultValuesUsed:!1}}const{theme:a,field:r}=i,n=i.layer,s=r&&"function"!=typeof r?n.getField(r):null,l=E.isAnyDateField(s);return T.getDataRange(e,a,l,"above"===a||"below"===a)}function $(e,i){if(("spike"===i||"reference-size"===i)&&null!=e.minDataValue&&null!=e.maxDataValue&&null!=e.minSize&&null!=e.maxSize&&"number"==typeof e.minSize&&"number"==typeof e.maxSize)return[new c({value:e.minDataValue,size:e.minSize}),new c({value:e.maxDataValue,size:e.maxSize})];throw new a("get-size-stops-for-theme","Invalid size variable or theme")}async function H(e,i,a,r,n){const t=await s.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),o=n.layer,u=n.field,m=o.geometryType,p=n.defaultSymbolEnabled,d=F.cloneScheme(e.sizeScheme),c="polygon"===m,y=c?d.marker:d,f=c?d.background:null,b=c?"point":m,z=i?.opacity,v=e.isGrid,h=n.theme,g="reference-size"===h,S="spike"===h,x=g||S?[]:e.visualVariables.map((e=>e.clone()));i?.visualVariables?.length&&x.push(...i.visualVariables.map((e=>e.clone())));const k=g?w.createReferenceSizeSymbol({type:n.referenceSizeOptions?.symbolStyle||"circle",color:y.color,primitiveOverrides:w.createPrimitiveOverrides({view:n.view,field:u,normalizationField:r,sizeStops:$(e.visualVariables[0],h),sizeByScaleEnabled:v||!!n.sizeOptimizationEnabled})}):S?V.createSpikeSymbol({color:y.color,strokeColor:y.outline.color,baseWidth:n.spikeOptions?.baseWidth,strokeWidth:n.spikeOptions?.strokeWidth,defaultHeight:n.spikeOptions?.defaultHeight,primitiveOverrides:V.createPrimitiveOverrides({field:u,normalizationField:r,sizeStops:$(e.visualVariables[0],h)}),symbolStyle:n.spikeOptions?.symbolStyle}):T.createSymbol(b,{type:n.symbolType,color:y.color,size:T.getSymbolSizeFromScheme(y,b),outline:T.getSymbolOutlineFromScheme(y,b,z)});return{renderer:new l({backgroundFillSymbol:!v&&f?T.createSymbol(m,{type:n.symbolType,color:f.color,outline:T.getSymbolOutlineFromScheme(f,m,z)}):null,classBreakInfos:[{minValue:-9007199254740991,maxValue:B,symbol:k}],defaultLabel:p?t.other:null,defaultSymbol:!p||g||S?null:T.createSymbol(b,{type:n.symbolType,color:y.noDataColor,size:T.getSymbolSizeFromScheme(y,b,!0),outline:T.getSymbolOutlineFromScheme(y,b,z)}),field:u,normalizationField:r,normalizationType:a,valueExpression:n.valueExpression,valueExpressionTitle:n.valueExpressionTitle,visualVariables:x,authoringInfo:e.authoringInfo?.clone()}),visualVariables:e.visualVariables.map((e=>e.clone())),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,isGrid:v,sizeScheme:F.cloneScheme(e.sizeScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function J(e){const i=await C(e),{view:r,field:s,valueExpression:l,minValue:m,maxValue:d,layer:c,normalizationField:f,signal:b,statistics:z,filter:v}=i,g=f?"field":void 0,[w,S]=await Promise.all([z??T.getSummaryStatistics({layer:c,field:s,valueExpression:l,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:g,normalizationField:f,filter:v,minValue:m,maxValue:d,view:r,signal:b}),i.sizeOptimizationEnabled?h({view:r,layer:c,signal:b,filter:v}).catch(T.errorCallback):null]);return async function(e,i,r,s){const{theme:l,field:m,normalizationField:d,minValue:c,maxValue:f,axis:b}=e,z=e.layer.geometryType,v=await G({basemap:e.basemap,geometryType:z,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=v.scheme;if(!h)throw new a("size-visual-variable:insufficient-info","Unable to find size scheme");const g=await async function(e,i,a,r,n,s){return j(e,i,a,r)||M(n,s)}(r,s,e.spikeOptions,l,h,z),{minDataValue:w,maxDataValue:S,defaultValuesUsed:V}=N(i,e),x=[],k="height"===b,E=k?b:void 0,O=g[0];let I=g[1];if(k&&"number"==typeof O&&"number"==typeof I){const e=T.getSizeRangeForAxis({minSize:O,maxSize:I},E);x.push(new p({axis:"width-and-depth",minSize:e.minSize})),I=e.maxSize}const B=new p({field:m??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:d,axis:E,minSize:O,maxSize:I,minDataValue:w,maxDataValue:S,legendOptions:n.ensureClass(y,e.legendOptions)});W(B,l),x.unshift(B);const R=new u("reference-size"===l?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:$(B,l).map((({label:e,size:i,value:a})=>new o({label:e,size:i,value:a}))),theme:l,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=c?c:i.min,maxSliderValue:null!=f?f:i.max}:"spike"===l?{type:"size",field:e.field,normalizationField:e.normalizationField,spikeSymbolStyle:e.spikeOptions?.symbolStyle,sizeStops:$(B,l).map((({label:e,size:i,value:a})=>new o({label:e,size:i,value:a}))),theme:l,minSliderValue:null!=c?c:i.min,maxSliderValue:null!=f?f:i.max}:{type:"size",theme:l,minSliderValue:null!=c?c:i.min,maxSliderValue:null!=f?f:i.max}),C=new t({visualVariables:[R]});return{basemapId:v.basemapId,basemapTheme:v.basemapTheme,visualVariables:x,statistics:i,isGrid:s?.isGrid,defaultValuesUsed:V,sizeScheme:F.cloneScheme(h),authoringInfo:C}}(i,w,S,i.referenceSizeResult)}async function K(e){const{view:i,filter:r,renderer:n,signal:s,creatorParameters:l}=await async function(e){const i="regenerate-size-visual-variables";S.processRegenerateParams(e,i);const r=await S.getRendererToUpdate(e),n=S.getStyleType(r);if(!n||!["size-continuous","univariate-color-size","color-size","relationship-size","type-size"].includes(n))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const s=S.getAuthoringInfoVisualVariable(r,"size");if(!s)throw new a(`${i}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const l=s.theme,t="reference-size"===l,o="spike"===l,u=r.visualVariables?.find(S.isSizeVV);if(!u&&!t&&!o)throw new a(`${i}:invalid-parameters`,"Renderer does not have a size visual variable");let m=s.field,p=s.normalizationField,d=null,c=null;m||(u?.field?(m=u.field,p=u.normalizationField):r.field?(m=r.field,p=r.normalizationField):(d=u?.valueExpression??r.valueExpression,c=u?.valueExpressionTitle??r.valueExpressionTitle));const{layer:y,forBinning:f,filter:b,view:z,signal:v}=e,h=S.hasScaleDependentSizeVV(r),g=await C({layer:y,field:m,valueExpression:d,valueExpressionTitle:c,normalizationField:p,theme:l,sizeOptimizationEnabled:h,forBinning:f,filter:b,view:z,signal:v});return{...e,creatorParameters:g,renderer:r}}(e),{field:t,normalizationField:u,valueExpression:m,theme:d,layer:c,sizeOptimizationEnabled:y,spikeOptions:f,referenceSizeResult:b,valueExpressionTitle:z}=l,v=u?"field":void 0,[g,w]=await Promise.all([T.getSummaryStatistics({layer:c,field:t,valueExpression:m,normalizationField:u,normalizationType:v,filter:r,view:i,signal:s}),y?h({view:i,layer:c,signal:s,filter:r}).catch(T.errorCallback):null]),V=j(w,b,f,d),{minDataValue:x,maxDataValue:k}=N(g,{theme:d,layer:c,field:t}),E=n.visualVariables?.find(S.isSizeVV),O=(E?.stops?null:E)??new p({field:t??void 0,valueExpression:m,valueExpressionTitle:z,valueUnit:"unknown",normalizationField:u});V&&(O.minSize=V[0],O.maxSize=V[1]),O.minDataValue=x,O.maxDataValue=k,W(O,d);const F=S.getAuthoringInfoVisualVariable(n,"size");F.minSliderValue=g.min,F.maxSliderValue=g.max;const I="reference-size"===d;return(I||"spike"===d)&&(F.sizeStops=$(O,d).map((({label:e,size:i,value:a})=>new o({label:e,size:i,value:a}))),I&&(F.referenceSizeScale=b?.isGrid||y?i?.scale:void 0)),{visualVariables:"reference-size"===d||"spike"===d?[]:[O],isGrid:!!b?.isGrid,authoringInfo:n.authoringInfo?.clone(),statistics:g}}async function Q(e){const{layer:r,referenceSizeOptions:n,renderer:s,sizeScheme:l,sizeStops:u,typeScheme:m,view:p,isGrid:d}=await async function(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new a("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:i,forBinning:r}=e,n=e.forBinning?O.binningCapableLayerTypes:O.featureCapableLayerTypes,s=O.createLayerAdapter(e.layer,n,e.forBinning);if(!s)throw new a("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(n).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new a("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new a("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some((e=>"reference-size"===e.theme)))throw new a("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const u=e.isGrid??(await v({view:i,layer:l,forBinning:r}))?.isGrid;return{...e,isGrid:u,renderer:t,layer:s}}(e),c=s.clone();c.authoringInfo??=new t;const y=c.authoringInfo.visualVariables.find((e=>"reference-size"===e.theme)),f=e.field??y?.field,b=e.normalizationField??y?.normalizationField;if(!f)throw new a("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const z=w.createPrimitiveOverrides({view:p,field:f,normalizationField:b,sizeStops:u,sizeByScaleEnabled:d||!!e.sizeOptimizationEnabled}),h=n?.symbolStyle||y?.referenceSizeSymbolStyle||"circle";if("class-breaks"===c.type){const e="polygon"===("geometryType"in r?r.geometryType:null)&&l&&"marker"in l?l.marker:null;c.classBreakInfos.forEach((i=>{const a=e?.color??I.getColorFromSymbol(i.symbol,1);"cim"===i.symbol.type?w.updateReferenceSizeSymbol(i.symbol,{type:h,color:a,primitiveOverrides:z}):a&&(i.symbol=w.createReferenceSizeSymbol({type:h,color:a,primitiveOverrides:z}))}))}else if("unique-value"===c.type){const e=c.uniqueValueGroups,a="polygon"===("geometryType"in r?r.geometryType:null)&&m&&"colors"in m?m.colors:null,n=a?i.createUniqueColors(a,c.uniqueValueInfos?.length??0):null;let s=0;if(e){for(const i of e)for(const e of i.classes??[]){const i=n?n[s]:I.getColorFromSymbol(e.symbol,1);"cim"===e.symbol?.type?w.updateReferenceSizeSymbol(e.symbol,{type:h,color:i,primitiveOverrides:z}):i&&(e.symbol=w.createReferenceSizeSymbol({type:h,color:i,primitiveOverrides:z})),s++}c.uniqueValueGroups=e}}return y&&(y.field=f,y.normalizationField=b,y.sizeStops=u.map((({label:e,size:i,value:a})=>new o({label:e,size:i,value:a}))),y.referenceSizeScale=d||e.sizeOptimizationEnabled?p.scale:void 0,y.referenceSizeSymbolStyle=h),c}async function X(e){const{layer:r,renderer:n,sizeScheme:s,sizeStops:l,typeScheme:u,spikeOptions:m}=await async function(e){if(!e||!e.layer||!e.sizeStops)throw new a("update-renderer-with-spike:missing-parameters","'layer' and 'sizeStops' parameters are required");const i=e.forBinning?O.binningCapableLayerTypes:O.featureCapableLayerTypes,r=O.createLayerAdapter(e.layer,i,e.forBinning);if(!r)throw new a("update-renderer-with-spike:invalid-parameters","'layer' must be one of these types: "+O.getLayerTypeLabels(i).join(", "));await r.load();const n=r.layer;let s=e.renderer;if(!s)if(e.forBinning){if(!("featureReduction"in n&&n.featureReduction&&"renderer"in n.featureReduction&&n.featureReduction.renderer)||"class-breaks"!==n.featureReduction.renderer.type&&"unique-value"!==n.featureReduction.renderer.type)throw new a("update-renderer-with-spike:invalid-parameters","Feature reduction renderer is not supported");s=n.featureReduction.renderer}else{if(!("renderer"in n)||!n.renderer||"class-breaks"!==n.renderer.type&&"unique-value"!==n.renderer.type)throw new a("update-renderer-with-spike:invalid-parameters","Renderer is not supported");s=n.renderer}const l=s.authoringInfo,t=l?.visualVariables.find((e=>"spike"===e.theme));if(!t)throw new a("update-renderer-with-spike:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'spike'");const o=e.spikeOptions??{};return o.symbolStyle??=t?.spikeSymbolStyle?void 0:V.defaultSpikeSymbolStyle,{...e,renderer:s,layer:r,spikeOptions:o}}(e),p=n.clone();p.authoringInfo??=new t;const d=p.authoringInfo.visualVariables.find((e=>"spike"===e.theme)),c=e.field??d?.field,y=e.normalizationField??d?.normalizationField;if(!c)throw new a("update-renderer-with-spike:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const f=V.createPrimitiveOverrides({field:c,normalizationField:y,sizeStops:l}),b="geometryType"in r?r.geometryType:null,z={primitiveOverrides:f,...m},v=m?.symbolStyle,h=v&&v.includes("outline")&&(v.includes("solid-fill")||v.includes("gradient-fill"));if("class-breaks"===p.type){if(s||h){const i=b?await G({geometryType:b,sizeScheme:s,view:e.view}):null,a=i?.scheme,r="polygon"===b&&a&&"marker"in a?a.marker:a;if(s){const e=r&&"color"in r?r?.color:void 0;z.color=e}if(h){const e=r&&"outline"in r?r.outline.color:void 0;z.strokeColor=e}}p.classBreakInfos.forEach((e=>{if("cim"===e.symbol.type)V.updateSpikeSymbol(e.symbol,z);else{const i=z.color??I.getColorFromSymbol(e.symbol,1)??void 0;i&&(e.symbol=V.createSpikeSymbol({...z,color:i}))}}))}else if("unique-value"===p.type){const a=p.uniqueValueGroups,r=p.uniqueValueInfos?.length??0;let n=null;if(u||h){const a=b&&r?await g.getTypeSchemeData({numColors:r,geometryType:b,typeScheme:u,view:e.view}):null,s=a?.scheme;if(u){const e=s&&"colors"in s?s.colors:null;n=e?i.createUniqueColors(e,r):null}if(h){const e=s&&"outline"in s?s.outline.color:void 0;z.strokeColor=e}}let s=0;if(a){for(const e of a)for(const i of e.classes??[]){if("cim"===i.symbol?.type)V.updateSpikeSymbol(i.symbol,{...z,color:n?.[s]});else{const e=n?.[s]??I.getColorFromSymbol(i.symbol,1)??void 0;e&&(i.symbol=V.createSpikeSymbol({...z,color:e}))}s++}p.uniqueValueGroups=a}}return d&&(d.field=c,d.normalizationField=y,d.sizeStops=l.map((({label:e,size:i,value:a})=>new o({label:e,size:i,value:a}))),v&&(d.spikeSymbolStyle=v)),p}e.createAgeRenderer=async function(e){const i=await U(e),{defaultSymbolEnabled:a,view:r,startTime:n,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:u,filter:m,layer:p}=i,[d,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await b({view:r,layer:p,startTime:n,endTime:s,minValue:t,maxValue:o,signal:u,filter:m}),i.outlineOptimizationEnabled?z({layer:p,view:r,filter:m,signal:u}).catch(T.errorCallback):null]),{unit:y,statistics:f}=d,{valueExpression:v,title:h}=await T.getTitleAndExpressionForAgeRenderer(i,y),g=await J(P({layer:p,basemap:i.basemap,valueExpression:v,symbolType:l,statistics:f,legendOptions:{title:h},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:m,signal:u})),w={layer:p,valueExpression:v,defaultSymbolEnabled:a,symbolType:l},S=await H(g,c,null,null,w),V=S.renderer.authoringInfo?.visualVariables;return V?.forEach((e=>T.updateAgeRendererAuthoringInfoVV(e,n,s,y))),{...S,unit:y}},e.createClassBreaksRenderer=async function(e){const i=await A(e);return async function(e,i){const a=await s.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),n=e.layer,o=e.defaultSymbolEnabled,u=n.geometryType,p="polygon"===u,d=e.symbolType?.includes("3d-volumetric"),c=await G({basemap:e.basemap,geometryType:u,sizeScheme:e.sizeScheme,worldScale:d,view:e.view}),y=c.scheme,{result:f,outlineResult:b}=i,z=f?.classBreakInfos??[],v=e.classificationMethod,h=e.normalizationType,g=p?y.marker:y,w=p?y.background:null,S=p?"point":u,V=M(g,S),x=d?T.getSizeRangeForAxis({minSize:V[0],maxSize:V[1]},"height"):null,k=function(e,i){const a=r.toPt(e.minSize),n=(r.toPt(e.maxSize)-a)/(i>=4?i-1:i),s=[];for(let e=0;e<i;e++)s.push(a+n*e);return s}({minSize:V[0],maxSize:x?x.maxSize:V[1]},z.length),E=b?.opacity,O=new l({backgroundFillSymbol:w&&T.createSymbol(u,{type:e.symbolType,color:w.color,outline:T.getSymbolOutlineFromScheme(w,u,E)}),classBreakInfos:z.map(((i,a)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:T.createSymbol(S,{type:e.symbolType,color:g.color,size:k[a],widthAndDepth:x?.minSize,outline:T.getSymbolOutlineFromScheme(g,S,E)}),label:i.label}))),defaultLabel:o?a.other:null,defaultSymbol:o?T.createSymbol(S,{type:e.symbolType,color:g.noDataColor,size:T.getSymbolSizeFromScheme(g,S,!0),widthAndDepth:x?.minSize,outline:T.getSymbolOutlineFromScheme(g,S,E)}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:h,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===h?f?.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new t({type:"class-breaks-size",classificationMethod:v,standardDeviationInterval:e.standardDeviationInterval})});return"standard-deviation"!==v&&m.setLabelsForClassBreaks({classBreakInfos:O.classBreakInfos,classificationMethod:v,normalizationType:h,round:!0}),b?.visualVariables?.length&&(O.visualVariables=b.visualVariables.map((e=>e.clone()))),{renderer:O,sizeScheme:F.cloneScheme(y),classBreaksResult:f,defaultValuesUsed:!!i.defaultValuesUsed,basemapId:c.basemapId,basemapTheme:c.basemapTheme}}(i,await T.getClassBreaks(D(i),i.outlineOptimizationEnabled))},e.createContinuousRenderer=async function(e){const i=await L(e),a={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[r,n]=await Promise.all([J(P(i)),i.outlineOptimizationEnabled?z(a).catch(T.errorCallback):null]),s=i.normalizationField;return H(r,n,s?"field":void 0,s,i)},e.createVisualVariables=J,e.getSizeStopsForTheme=$,e.regenerateAgeRenderer=async function(e){const{renderer:i,creatorParameters:r}=await async function(e){const i="regenerate-size-age-renderer";await S.processRegenerateParams(e,i);const r=await S.getRendererToUpdate(e);if("size-age"!==S.getStyleType(r))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n}=r,s=n?.visualVariables.find((e=>"size"===e.type)),l=s.startTime,t=s.endTime,o=s.units,u=s.theme,{layer:m,filter:p,view:d,signal:c}=e,y=S.hasOutlineVV(r),f=S.hasScaleDependentSizeVV(r),b=await U({layer:m,startTime:l,endTime:t,unit:o,theme:u,outlineOptimizationEnabled:y,sizeOptimizationEnabled:f,filter:p,view:d,signal:c});return{...e,creatorParameters:b,renderer:r}}(e),{layer:n,outlineOptimizationEnabled:s,sizeOptimizationEnabled:l,startTime:t,endTime:o,theme:u,view:m,signal:p,filter:d}=r,[c,y]=await Promise.all([b({view:m,layer:n,startTime:t,endTime:o,signal:p,filter:d}),s?z({layer:n,view:m,filter:d,signal:p}).catch(T.errorCallback):null]),{unit:f,statistics:v}=c,{valueExpression:h,title:g}=await T.getTitleAndExpressionForAgeRenderer(r,f),w=await J(P({layer:n,valueExpression:h,statistics:v,legendOptions:{title:g},sizeOptimizationEnabled:l,theme:u,view:m,filter:d,signal:p}));S.spliceVisualVariables(i,w.visualVariables,S.findSizeVVIndex),S.spliceVisualVariables(i,y?.visualVariables,S.findOutlineVVIndex),i.authoringInfo=w.authoringInfo.clone();const V=i.authoringInfo?.visualVariables;return V?.forEach((e=>T.updateAgeRendererAuthoringInfoVV(e,t,o,f))),{renderer:i}},e.regenerateClassBreaksRenderer=async function(e){const{renderer:i,creatorParameters:r}=await async function(e){const i="regenerate-size-class-breaks-renderer";await S.processRegenerateParams(e,i);const r=await S.getRendererToUpdate(e);if("size-class-breaks"!==S.getStyleType(r))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:u,valueExpressionTitle:m}=r,{classificationMethod:p,standardDeviationInterval:d}=n,c=r.classBreakInfos.length,{layer:y,forBinning:f,filter:b,view:z,signal:v}=e,h=S.hasOutlineVV(r),g=await A({layer:y,field:s,valueExpression:u,valueExpressionTitle:m,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:p,standardDeviationInterval:d,numClasses:c,outlineOptimizationEnabled:h,forBinning:f,filter:b,view:z,signal:v});return{...e,creatorParameters:g,renderer:r}}(e),{outlineOptimizationEnabled:n,normalizationType:s,classificationMethod:l}=r,{result:t,outlineResult:o}=await T.getClassBreaks(D(r),n),u=t.classBreakInfos;if(r.numClasses!==u.length)throw new a("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return i.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),i.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&m.setLabelsForClassBreaks({classBreakInfos:i.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),S.spliceVisualVariables(i,o?.visualVariables,S.findOutlineVVIndex),{renderer:i}},e.regenerateContinuousRenderer=async function(e){const{renderer:i,view:r,signal:n,filter:s,creatorParameters:l,forBinning:t}=await async function(e){const i="regenerate-size-continuous-renderer";S.processRegenerateParams(e,i);const r=await S.getRendererToUpdate(e),n=S.getStyleType(r);if(!n||!["size-continuous","univariate-color-size"].includes(n))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:s,field:l,normalizationField:t,valueExpression:o,valueExpressionTitle:u}=r,m=s?.visualVariables.find((e=>"size"===e.type)),p=m.theme,{layer:d,forBinning:c,filter:y,view:f,signal:b}=e,z=S.hasOutlineVV(r),v=S.hasScaleDependentSizeVV(r),h=await L({layer:d,field:l,valueExpression:o,valueExpressionTitle:u,normalizationField:t,theme:p,outlineOptimizationEnabled:z,sizeOptimizationEnabled:v,forBinning:c,filter:y,view:f,signal:b});return{...e,creatorParameters:h,renderer:r}}(e),{layer:o,outlineOptimizationEnabled:u,theme:m,referenceSizeResult:p}=l,[d,c]=await Promise.all([K({...e,referenceSizeResult:p}),u?z({layer:o,view:r,filter:s,signal:n}).catch(T.errorCallback):null]),y="reference-size"===m,f="spike"===m;S.spliceVisualVariables(i,d.visualVariables,S.findSizeVVIndex),S.spliceVisualVariables(i,c?.visualVariables,S.findOutlineVVIndex),S.updateAuthoringInfoVisualVariable(i,d.authoringInfo,"size");const b=d.statistics;if(!y&&!f)return{renderer:i,statistics:b};if(f)return{renderer:await X({layer:o,renderer:i,forBinning:t,sizeStops:S.getAuthoringInfoVisualVariable(i,"size","spike")?.sizeStops}),statistics:b};const v=d.isGrid;return{renderer:await Q({layer:o,renderer:i,view:r,forBinning:t,sizeStops:S.getAuthoringInfoVisualVariable(i,"size","reference-size")?.sizeStops,isGrid:v}),isGrid:v,statistics:b}},e.regenerateVisualVariables=K,e.updateRendererWithReferenceSize=Q,e.updateRendererWithSpike=X,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));