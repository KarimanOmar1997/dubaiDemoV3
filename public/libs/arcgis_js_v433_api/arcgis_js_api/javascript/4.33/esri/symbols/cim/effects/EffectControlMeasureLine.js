// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../geometry/GeometryCursor","../../../geometry/geometryCursorCollectUtils","../../../geometry/support/coordsUtils","../CIMCursor","../enums"],(function(t,s,e,i,h,r){"use strict";class o{static{this.instance=null}static local(){return null===o.instance&&(o.instance=new o),o.instance}execute(t,s,e,i,h){return new c(t,s,e)}}class c{constructor(t,s,e){this._defaultPointSize=20,this._inputGeometries=t,this._geomUnitsPerPoint=e,this._rule=s.rule??r.GeometricEffectControlMeasureLineRule.FullGeometry,this._defaultSize=this._defaultPointSize*e}next(){let t;for(;t=this._inputGeometries.next();){const i=this._processGeom(e.collectMultipath(t));if(i?.length)return s.GeometryCursor.fromJSONCIM({paths:i})}return null}_clone(t){return[t[0],t[1]]}_mid(t,s){return[(t[0]+s[0])/2,(t[1]+s[1])/2]}_mix(t,s,e,i){return[t[0]*s+e[0]*i,t[1]*s+e[1]*i]}_add(t,s){return[t[0]+s[0],t[1]+s[1]]}_add2(t,s,e){return[t[0]+s,t[1]+e]}_sub(t,s){return[t[0]-s[0],t[1]-s[1]]}_dist(t,s){return Math.sqrt((t[0]-s[0])*(t[0]-s[0])+(t[1]-s[1])*(t[1]-s[1]))}_norm(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}_normalize(t,s=1){const e=s/this._norm(t);t[0]*=e,t[1]*=e}_leftPerpendicular(t){const s=-t[1],e=t[0];t[0]=s,t[1]=e}_leftPerp(t){return[-t[1],t[0]]}_rightPerpendicular(t){const s=t[1],e=-t[0];t[0]=s,t[1]=e}_rightPerp(t){return[t[1],-t[0]]}_dotProduct(t,s){return t[0]*s[0]+t[1]*s[1]}_crossProduct(t,s){return t[0]*s[1]-t[1]*s[0]}_rotateDirect(t,s,e){const i=t[0]*s-t[1]*e,h=t[0]*e+t[1]*s;t[0]=i,t[1]=h}_makeCtrlPt(t){const s=[t[0],t[1]];return h.setId(s,1),s}_addAngledTicks(t,s,e,i){const h=this._sub(e,s);this._normalize(h);const r=this._crossProduct(h,this._sub(i,s));let o;o=r>0?this._rightPerp(h):this._leftPerp(h);const c=Math.abs(r)/2,u=[];u.push([s[0]+(o[0]-h[0])*c,s[1]+(o[1]-h[1])*c]),u.push(s),u.push(e),u.push([e[0]+(o[0]+h[0])*c,e[1]+(o[1]+h[1])*c]),t.push(u)}_addBezier2(t,s,e,i,h){if(0===h--)return void t.push(i);const r=this._mid(s,e),o=this._mid(e,i),c=this._mid(r,o);this._addBezier2(t,s,r,c,h),this._addBezier2(t,c,o,i,h)}_addBezier3(t,s,e,i,h,r){if(0===r--)return void t.push(h);const o=this._mid(s,e),c=this._mid(e,i),u=this._mid(i,h),_=this._mid(o,c),n=this._mid(c,u),a=this._mid(_,n);this._addBezier3(t,s,o,_,a,r),this._addBezier3(t,a,n,u,h,r)}_add90DegArc(t,s,e,i,h){const r=h??this._crossProduct(this._sub(e,s),this._sub(i,s))>0,o=this._mid(s,e),c=this._sub(o,s);r?this._leftPerpendicular(c):this._rightPerpendicular(c),o[0]+=c[0],o[1]+=c[1],this._addBezier3(t,s,this._mix(s,.33333,o,.66667),this._mix(e,.33333,o,.66667),e,4)}_addArrow(t,s,e){const i=s[0],h=s[1],r=s[s.length-1],o=this._sub(i,h),c=this._norm(o);this._normalize(o);const u=Math.abs(this._crossProduct(o,this._sub(r,h)));let _=this._dotProduct(o,this._sub(r,h));_<.05*c?_=.05*c:_>.95*c&&(_=.95*c);const n=.5*u,a=this._leftPerp(o),l=[h[0]+o[0]*_,h[1]+o[1]*_],p=s.length-1,d=[];d.push(e?[-a[0],-a[1]]:a);let f=[-o[0],-o[1]];for(let t=1;t<p-1;t++){const e=this._sub(s[t+1],s[t]);this._normalize(e);const i=this._dotProduct(e,f),h=this._crossProduct(e,f),r=Math.sqrt((1+i)/2),o=this._sub(e,f);this._normalize(o),o[0]/=r,o[1]/=r,d.push(h<0?[-o[0],-o[1]]:o),f=e}d.push(this._rightPerp(f));for(let e=d.length-1;e>0;e--)t.push([s[e][0]+d[e][0]*n,s[e][1]+d[e][1]*n]);t.push([l[0]+d[0][0]*n,l[1]+d[0][1]*n]),t.push([l[0]+d[0][0]*u,l[1]+d[0][1]*u]),t.push(i),t.push([l[0]-d[0][0]*u,l[1]-d[0][1]*u]),t.push([l[0]-d[0][0]*n,l[1]-d[0][1]*n]);for(let e=1;e<d.length;e++)t.push([s[e][0]-d[e][0]*n,s[e][1]-d[e][1]*n])}_addDash(t,s,e){const i=this._norm(e)/7;this._normalize(e);let h=[];for(let r=0;r<=7;r++)h.push([s[0]+e[0]*r*i,s[1]+e[1]*r*i]),1&r&&(t.push(h),h=[])}_cp2(t,s,e){return t.length>=2?t[1]:this._add2(t[0],s*this._defaultSize,e*this._defaultSize)}_cp3(t,s,e,i){if(t.length>=3)return t[2];const h=this._mix(t[0],1-e,s,e),r=this._sub(s,t[0]);return this._normalize(r),this._rightPerpendicular(r),[h[0]+r[0]*i*this._defaultSize,h[1]+r[1]*i*this._defaultSize]}_arrowPath(t){if(t.length>2)return t;const s=t[0],e=this._cp2(t,-4,0),i=this._sub(s,e);this._normalize(i);const h=this._rightPerp(i);return[s,e,[s[0]+(h[0]-i[0])*this._defaultSize,s[1]+(h[1]-i[1])*this._defaultSize]]}_arrowLastSeg(t){const s=t[0],e=this._cp2(t,-4,0);let i;if(t.length>=3)i=t[t.length-1];else{const t=this._sub(s,e);this._normalize(t);const h=this._rightPerp(t);i=[s[0]+(h[0]-t[0])*this._defaultSize,s[1]+(h[1]-t[1])*this._defaultSize]}return[e,i]}_processGeom(t){if(!t)return null;const s=[];for(const e of t){const t=e.length>1&&i.getPathLength(e)<this._defaultSize;if(!e||0===e.length||t)continue;const o=e.length;let c=e[0];switch(this._rule){case r.GeometricEffectControlMeasureLineRule.PerpendicularFromFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=[];h.push(i),h.push(this._mid(c,t)),s.push(h);break}case r.GeometricEffectControlMeasureLineRule.ReversedFirstSegment:{const t=this._cp2(e,0,-1);s.push([t,c]);break}case r.GeometricEffectControlMeasureLineRule.PerpendicularToSecondSegment:{if(e.length<3)return[];const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=[];h.push(this._mid(t,i)),h.push(c),s.push(h);break}case r.GeometricEffectControlMeasureLineRule.SecondSegmentWithTicks:{if(e.length<3)return[];const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);let r;r=this._crossProduct(h,this._sub(c,t))>0?this._rightPerp(h):this._leftPerp(h);const o=[];o.push([t[0]+(r[0]-h[0])/3,t[1]+(r[1]-h[1])/3]),o.push(t),o.push(i),o.push([i[0]+(r[0]+h[0])/3,i[1]+(r[1]+h[1])/3]),s.push(o);break}case r.GeometricEffectControlMeasureLineRule.DoublePerpendicular:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,3),h=this._mid(c,t),r=this._sub(h,i);this._normalize(r);const o=this._crossProduct(r,this._sub(c,i));this._leftPerpendicular(r);const u=[];u.push(c),u.push([i[0]+r[0]*o,i[1]+r[1]*o]),s.push(u);const _=[];_.push([i[0]-r[0]*o,i[1]-r[1]*o]),_.push(t),s.push(_);break}case r.GeometricEffectControlMeasureLineRule.OppositeToFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,3),h=this._mid(c,t),r=this._sub(h,i);this._normalize(r);const o=this._crossProduct(r,this._sub(c,i));this._leftPerpendicular(r);const u=[];u.push([i[0]+r[0]*o,i[1]+r[1]*o]),u.push([i[0]-r[0]*o,i[1]-r[1]*o]),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.TriplePerpendicular:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=this._mid(c,t),r=this._sub(h,i);this._normalize(r);const o=this._crossProduct(r,this._sub(c,i));this._leftPerpendicular(r);const u=[];u.push([i[0]+r[0]*o*.8,i[1]+r[1]*o*.8]),u.push([h[0]+.8*(c[0]-h[0]),h[1]+.8*(c[1]-h[1])]),s.push(u),s.push([i,h]);const _=[];_.push([i[0]-r[0]*o*.8,i[1]-r[1]*o*.8]),_.push([h[0]+.8*(t[0]-h[0]),h[1]+.8*(t[1]-h[1])]),s.push(_);break}case r.GeometricEffectControlMeasureLineRule.HalfCircleFirstSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,4),h=this._mid(c,t);let r=this._sub(t,c);const o=Math.cos(Math.PI/18),u=Math.sin(Math.PI/18),_=Math.sqrt((1+o)/2),n=Math.sqrt((1-o)/2),a=[];let l;this._crossProduct(r,this._sub(i,c))>0?(a.push(c),r=this._sub(c,h),l=t):(a.push(t),r=this._sub(t,h),l=c),this._rotateDirect(r,_,n),r[0]/=_,r[1]/=_;for(let t=1;t<=18;t++)a.push(this._add(h,r)),this._rotateDirect(r,o,u);a.push(l),s.push(a);break}case r.GeometricEffectControlMeasureLineRule.HalfCircleSecondSegment:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,1,-1);let h=this._sub(c,t);this._normalize(h);const r=this._crossProduct(h,this._sub(i,t))/2;this._leftPerpendicular(h);const o=[t[0]+h[0]*r,t[1]+h[1]*r];h=this._sub(t,o);const u=Math.cos(Math.PI/18);let _=Math.sin(Math.PI/18);r>0&&(_=-_);const n=[t];for(let t=1;t<=18;t++)this._rotateDirect(h,u,_),n.push(this._add(o,h));s.push(n);break}case r.GeometricEffectControlMeasureLineRule.HalfCircleExtended:{const t=this._cp2(e,0,-2),i=this._cp3(e,t,1,-1);let h;if(o>=4)h=e[3];else{const s=this._sub(c,t);h=this._add(i,s)}const r=this._dist(t,i)/2/.75,u=this._sub(t,c);this._normalize(u,r);const _=this._sub(i,h);this._normalize(_,r);const n=[h,i];s.push(n);const a=[this._clone(i)];this._addBezier3(a,i,this._add(i,_),this._add(t,u),t,4),a.push(c),s.push(a);break}case r.GeometricEffectControlMeasureLineRule.OpenCircle:{const t=this._cp2(e,-2,0),i=this._sub(t,c),h=Math.cos(Math.PI/18),r=-Math.sin(Math.PI/18),o=[t];for(let t=1;t<=33;t++)this._rotateDirect(i,h,r),o.push(this._add(c,i));s.push(o);break}case r.GeometricEffectControlMeasureLineRule.CoverageEdgesWithTicks:{const t=this._cp2(e,0,-1);let i,h;if(o>=3)i=e[2];else{const s=this._sub(t,c),e=this._leftPerp(s);i=[c[0]+e[0]-.25*s[0],c[1]+e[1]-.25*s[1]]}if(o>=4)h=e[3];else{const s=this._mid(c,t),e=this._sub(c,t);this._normalize(e),this._leftPerpendicular(e);const r=this._crossProduct(e,this._sub(i,s));this._rightPerpendicular(e),h=[i[0]+e[0]*r*2,i[1]+e[1]*r*2]}const r=this._sub(t,c);let u,_;u=this._crossProduct(r,this._sub(i,c))>0?this._rightPerp(r):this._leftPerp(r),_=[],_.push(i),_.push(c),_.push([c[0]+(u[0]-r[0])/3,c[1]+(u[1]-r[1])/3]),s.push(_),u=this._crossProduct(r,this._sub(h,t))>0?this._rightPerp(r):this._leftPerp(r),_=[],_.push([t[0]+(u[0]+r[0])/3,t[1]+(u[1]+r[1])/3]),_.push(t),_.push(h),s.push(_);break}case r.GeometricEffectControlMeasureLineRule.GapExtentWithDoubleTicks:{const t=this._cp2(e,0,2),i=this._cp3(e,t,0,1);let h;if(o>=4)h=e[3];else{const s=this._sub(t,c);h=this._add(i,s)}this._addAngledTicks(s,c,t,this._mid(i,h)),this._addAngledTicks(s,i,h,this._mid(c,t));break}case r.GeometricEffectControlMeasureLineRule.GapExtentMidline:{const t=this._cp2(e,2,0),i=this._cp3(e,t,0,1);let h;if(o>=4)h=e[3];else{const s=this._sub(t,c);h=this._add(i,s)}const r=[];r.push(this._mid(c,i)),r.push(this._mid(t,h)),s.push(r);break}case r.GeometricEffectControlMeasureLineRule.Chevron:{const t=this._cp2(e,-1,-1);let i;if(o>=3)i=e[2];else{const s=this._sub(t,c);this._leftPerpendicular(s),i=this._add(c,s)}s.push([t,this._makeCtrlPt(c),i]);break}case r.GeometricEffectControlMeasureLineRule.PerpendicularWithArc:{const t=this._cp2(e,0,-2),i=this._cp3(e,t,.5,-1),h=this._sub(t,c),r=this._norm(h);h[0]/=r,h[1]/=r;const u=this._crossProduct(h,this._sub(i,c));let _=this._dotProduct(h,this._sub(i,c));_<.05*r?_=.05*r:_>.95*r&&(_=.95*r);const n=[c[0]+h[0]*_,c[1]+h[1]*_];let a=this._leftPerp(h),l=[];if(l.push([n[0]-a[0]*u,n[1]-a[1]*u]),l.push([n[0]+a[0]*u,n[1]+a[1]*u]),s.push(l),o>=4){const t=e[3];let i=this._dotProduct(h,this._sub(t,c));i<.1*r?i=.1*r:i>.9*r&&(i=.9*r);const o=[c[0]+h[0]*i,c[1]+h[1]*i],u=this._crossProduct(h,this._sub(t,c)),_=[];_.push([o[0]-a[0]*u,o[1]-a[1]*u]),_.push([o[0]+a[0]*u,o[1]+a[1]*u]),s.push(_)}const p=[t[0]+a[0]*u,t[1]+a[1]*u];a=this._sub(t,p);const d=Math.cos(Math.PI/18);let f=Math.sin(Math.PI/18);u<0&&(f=-f),l=[c,t];for(let t=1;t<=9;t++)this._rotateDirect(a,d,f),l.push(this._add(p,a));s.push(l);break}case r.GeometricEffectControlMeasureLineRule.ClosedHalfCircle:{const t=this._cp2(e,2,0),i=this._mid(c,t),h=this._sub(t,i),r=Math.cos(Math.PI/18),o=Math.sin(Math.PI/18),u=[c,t];for(let t=1;t<=18;t++)this._rotateDirect(h,r,o),u.push(this._add(i,h));s.push(u);break}case r.GeometricEffectControlMeasureLineRule.TripleParallelExtended:{const t=this._cp2(e,0,-2),i=this._cp3(e,t,1,-2),r=this._mid(c,t),o=this._sub(i,t);this._normalize(o);const u=Math.abs(this._crossProduct(o,this._sub(r,t)))/2,_=this._dist(t,i),n=[t,c];n.push([c[0]+o[0]*_*.5,c[1]+o[1]*_*.5]),s.push(n);const a=[];a.push([r[0]-o[0]*u,r[1]-o[1]*u]),a.push([r[0]+o[0]*_*.375,r[1]+o[1]*_*.375]),h.setId(a[a.length-1],1),a.push([r[0]+o[0]*_*.75,r[1]+o[1]*_*.75]),s.push(a);const l=[t,i];s.push(l);break}case r.GeometricEffectControlMeasureLineRule.ParallelWithTicks:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(i,t);this._normalize(h);const r=this._crossProduct(h,this._sub(i,c));this._leftPerpendicular(h),this._addAngledTicks(s,c,t,i),this._addAngledTicks(s,this._mix(c,1,h,r),this._mix(t,1,h,r),this._mid(c,t));break}case r.GeometricEffectControlMeasureLineRule.Parallel:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,c);this._normalize(h);const r=this._leftPerp(h),o=this._crossProduct(h,this._sub(i,c));let u=[c,t];s.push(u),u=[],u.push([c[0]+r[0]*o,c[1]+r[1]*o]),u.push([t[0]+r[0]*o,t[1]+r[1]*o]),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.PerpendicularToFirstSegment:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._mid(c,t),r=this._sub(t,c);this._normalize(r);const o=this._crossProduct(r,this._sub(i,c));this._leftPerpendicular(r);const u=[];u.push([h[0]-r[0]*o*.25,h[1]-r[1]*o*.25]),u.push([h[0]+r[0]*o*1.25,h[1]+r[1]*o*1.25]),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.ParallelOffset:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,c);this._normalize(h);const r=this._crossProduct(h,this._sub(i,c));this._leftPerpendicular(h);const o=[];o.push([c[0]-h[0]*r,c[1]-h[1]*r]),o.push([t[0]-h[0]*r,t[1]-h[1]*r]),s.push(o);const u=[];u.push([c[0]+h[0]*r,c[1]+h[1]*r]),u.push([t[0]+h[0]*r,t[1]+h[1]*r]),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.OffsetOpposite:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,c);this._normalize(h);const r=this._crossProduct(h,this._sub(i,c));this._leftPerpendicular(h);const o=[];o.push([c[0]-h[0]*r,c[1]-h[1]*r]),o.push([t[0]-h[0]*r,t[1]-h[1]*r]),s.push(o);break}case r.GeometricEffectControlMeasureLineRule.OffsetSame:{const t=this._cp2(e,3,0),i=this._cp3(e,t,.5,-1),h=this._sub(t,c);this._normalize(h);const r=this._crossProduct(h,this._sub(i,c));this._leftPerpendicular(h);const o=[];o.push([c[0]+h[0]*r,c[1]+h[1]*r]),o.push([t[0]+h[0]*r,t[1]+h[1]*r]),s.push(o);break}case r.GeometricEffectControlMeasureLineRule.CircleWithArc:{let t=this._cp2(e,3,0);const i=this._cp3(e,t,.5,-1);let r,u;if(o>=4)r=e[3],u=this._crossProduct(this._sub(r,t),this._sub(i,t))>0;else{r=t,u=this._crossProduct(this._sub(r,c),this._sub(i,c))>0;const s=24*this._geomUnitsPerPoint,e=this._sub(r,c);this._normalize(e,s);const h=Math.sqrt(2)/2;this._rotateDirect(e,h,u?h:-h),t=this._add(c,e)}const _=this._sub(t,c),n=Math.cos(Math.PI/18),a=Math.sin(Math.PI/18),l=[t];for(let t=1;t<=36;t++)this._rotateDirect(_,n,a),l.push(this._add(c,_));this._add90DegArc(l,t,r,i,u),h.setId(l[l.length-8],1),s.push(l);break}case r.GeometricEffectControlMeasureLineRule.DoubleJog:{let t,i=this._cp2(e,-3,1),h=this._cp3(e,i,-1,-.5);if(o>=4)t=e[3];else{const s=c;c=i,t=h;const e=this._dist(c,s),r=this._dist(t,s);let o=30*this._geomUnitsPerPoint;.5*e<o&&(o=.5*e),.5*r<o&&(o=.5*r),i=this._mix(c,o/e,s,(e-o)/e),h=this._mix(t,o/r,s,(r-o)/r)}const r=this._mid(c,i),u=this._mid(t,h),_=this._dist(c,i),n=this._dist(h,t);let a=Math.min(_,n)/8;a=Math.min(a,24*this._geomUnitsPerPoint);const l=Math.cos(Math.PI/4);let p=this._sub(c,i);this._normalize(p,a),this._crossProduct(p,this._sub(t,i))>0?this._rotateDirect(p,l,-l):this._rotateDirect(p,l,l);let d=[];d.push(i),d.push(this._add(r,p)),d.push(this._sub(r,p)),d.push(c),s.push(d),p=this._sub(t,h),this._normalize(p,a),this._crossProduct(p,this._sub(c,h))<0?this._rotateDirect(p,l,l):this._rotateDirect(p,l,-l),d=[],d.push(h),d.push(this._add(u,p)),d.push(this._sub(u,p)),d.push(t),s.push(d);break}case r.GeometricEffectControlMeasureLineRule.PerpendicularOffset:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);this._crossProduct(h,this._sub(c,t))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const r=[h[0]/8,h[1]/8],o=this._sub(this._mid(t,i),r);s.push([o,c]);break}case r.GeometricEffectControlMeasureLineRule.LineExcludingLastSegment:{const t=this._arrowPath(e),i=[];let h=t.length-2;for(;h--;)i.push(t[h]);s.push(i);break}case r.GeometricEffectControlMeasureLineRule.MultivertexArrow:{const t=this._arrowPath(e),i=[];this._addArrow(i,t,!1),s.push(i);break}case r.GeometricEffectControlMeasureLineRule.CrossedArrow:{const t=this._arrowPath(e),i=[];this._addArrow(i,t,!0),s.push(i);break}case r.GeometricEffectControlMeasureLineRule.ChevronArrow:{const[t,i]=this._arrowLastSeg(e),h=10*this._geomUnitsPerPoint,r=this._sub(c,t),o=this._norm(r);this._normalize(r);const u=this._crossProduct(r,this._sub(i,t));let _=this._dotProduct(r,this._sub(i,t));_<.05*o?_=.05*o:_>.95*o-h&&(_=.95*o-h);const n=[t[0]+r[0]*_,t[1]+r[1]*_],a=this._leftPerp(r),l=[];l.push([n[0]+a[0]*u+r[0]*h,n[1]+a[1]*u+r[1]*h]),l.push(c),l.push([n[0]-a[0]*u+r[0]*h,n[1]-a[1]*u+r[1]*h]),s.push(l);break}case r.GeometricEffectControlMeasureLineRule.ChevronArrowOffset:{const[t,i]=this._arrowLastSeg(e),h=this._sub(c,t),r=this._norm(h);this._normalize(h);const o=this._crossProduct(h,this._sub(i,t));let u=this._dotProduct(h,this._sub(i,t));u<.05*r?u=.05*r:u>.95*r&&(u=.95*r);const _=[t[0]+h[0]*u,t[1]+h[1]*u];this._leftPerpendicular(h);const n=[];n.push([_[0]+h[0]*o*.5,_[1]+h[1]*o*.5]),n.push(this._mid(_,c)),n.push([_[0]-h[0]*o*.5,_[1]-h[1]*o*.5]),s.push(n);break}case r.GeometricEffectControlMeasureLineRule.PartialFirstSegment:{const[t,i]=this._arrowLastSeg(e),h=this._sub(c,t),r=this._norm(h);this._normalize(h);let o=this._dotProduct(h,this._sub(i,t));o<.05*r?o=.05*r:o>.95*r&&(o=.95*r);const u=[t[0]+h[0]*o,t[1]+h[1]*o];s.push([t,u]);break}case r.GeometricEffectControlMeasureLineRule.Arch:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,1),h=this._sub(c,t),r=this._mix(i,1,h,.55),o=this._mix(i,1,h,-.55),u=[c];this._addBezier2(u,c,r,i,4),this._addBezier2(u,i,o,t,4),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.CurvedParallelTicks:{const t=this._cp2(e,-4,1),i=this._cp3(e,t,.882353,-1.94),h=this._sub(i,t);this._crossProduct(h,this._sub(c,t))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const r=[h[0]/8,h[1]/8],o=this._sub(this._mid(t,i),r),u=this._sub(this._mix(t,.75,i,.25),r),_=this._sub(this._mix(t,.25,i,.75),r),n=[t];this._addBezier2(n,t,u,o,3),this._addBezier2(n,o,_,i,3),s.push(n);for(let t=0;t<8;t++){const e=n[2*t+1],i=[this._clone(e)];i.push(this._add(e,[h[0]/4,h[1]/4])),s.push(i)}break}case r.GeometricEffectControlMeasureLineRule.Arc90Degrees:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,1),h=[t];this._add90DegArc(h,t,c,i),s.push(h);break}case r.GeometricEffectControlMeasureLineRule.TipWithPerpendicularAndTicks:{const[t,i]=this._arrowLastSeg(e),h=10*this._geomUnitsPerPoint,r=this._sub(c,t),o=this._norm(r);this._normalize(r);let u=this._crossProduct(r,this._sub(i,t)),_=this._dotProduct(r,this._sub(i,t));_<.05*o?_=.05*o:_>.95*o-h&&(_=.95*o-h);const n=this._leftPerp(r),a=[c[0]-r[0]*h,c[1]-r[1]*h],l=.5*Math.max(o-_-h,h);u=Math.abs(u);const p=[];p.push([a[0]+n[0]*(u+l)-r[0]*l,a[1]+n[1]*(u+l)-r[1]*l]),p.push([a[0]+n[0]*u,a[1]+n[1]*u]),p.push([a[0]-n[0]*u,a[1]-n[1]*u]),p.push([a[0]-n[0]*(u+l)-r[0]*l,a[1]-n[1]*(u+l)-r[1]*l]),s.push(p),s.push([a,c]);break}case r.GeometricEffectControlMeasureLineRule.ConcentricCircles:{const t=this._cp2(e,1,0),i=this._cp3(e,t,2,0),r=Math.cos(Math.PI/18),u=Math.sin(Math.PI/18);let _=this._dist(t,c),n=[_,0],a=[];for(let t=0;t<=36;t++)a.push(this._add(c,n)),this._rotateDirect(n,r,u);if(s.push(a),o>=4){a=[];const t=e[3];_=this._dist(t,c),n=[_,0];for(let t=0;t<=36;t++)a.push(this._add(c,n)),0===t&&(a.push(this._add(c,n)),h.setId(a[1],1)),this._rotateDirect(n,r,u);s.push(a)}a=[],_=this._dist(i,c),n=[_,0];for(let t=0;t<=36;t++)a.push(this._add(c,n)),this._rotateDirect(n,r,u);s.push(a);break}case r.GeometricEffectControlMeasureLineRule.DoubleJogArrow:{c=this._arrowPath(e)[0];const[t,i]=this._arrowLastSeg(e),h=this._sub(c,t),r=this._norm(h);this._normalize(h);const o=Math.abs(this._crossProduct(h,this._sub(i,c)));let u=Math.abs(this._dotProduct(h,this._sub(i,c)));u<.05*r?u=.05*r:u>.95*r&&(u=.95*r);const _=Math.max(o,u),n=this._leftPerp(h);let a=[];const l=[c[0]-h[0]*u*.5+n[0]*o*.5,c[1]-h[1]*u*.5+n[1]*o*.5];a.push([l[0],l[1]]),l[0]+=h[0]*_*.5+n[0]*_*.4,l[1]+=h[1]*_*.5+n[1]*_*.4,a.push([l[0],l[1]]),l[0]-=n[0]*_*.25,l[1]-=n[1]*_*.25,a.push([l[0],l[1]]),l[0]+=h[0]*_*.5+n[0]*_*.4,l[1]+=h[1]*_*.5+n[1]*_*.4,a.push([l[0],l[1]]),s.push(a),a=[],l[0]=c[0]-h[0]*u*.5-n[0]*o*.5,l[1]=c[1]-h[1]*u*.5-n[1]*o*.5,a.push([l[0],l[1]]),l[0]+=h[0]*_*.5-n[0]*_*.4,l[1]+=h[1]*_*.5-n[1]*_*.4,a.push([l[0],l[1]]),l[0]+=n[0]*_*.25,l[1]+=n[1]*_*.25,a.push([l[0],l[1]]),l[0]+=h[0]*_*.5-n[0]*_*.4,l[1]+=h[1]*_*.5-n[1]*_*.4,a.push([l[0],l[1]]),s.push(a);break}case r.GeometricEffectControlMeasureLineRule.LinkedChevrons:{const t=this._cp2(e,-5,0),i=this._cp3(e,t,-.2,1),h=this._sub(c,t);this._normalize(h);const r=this._leftPerp(h),o=Math.abs(this._crossProduct(h,this._sub(i,t)));s.push([t,c]);const u=[];u.push([c[0]-h[0]*o+r[0]*o,c[1]-h[1]*o+r[1]*o]),u.push(c),u.push([c[0]-h[0]*o-r[0]*o,c[1]-h[1]*o-r[1]*o]),s.push(u),this._addDash(s,t,[-h[0]*o+r[0]*o,-h[1]*o+r[1]*o]),this._addDash(s,t,[-h[0]*o-r[0]*o,-h[1]*o-r[1]*o]);break}case r.GeometricEffectControlMeasureLineRule.SegmentThenHalfCircle:{const t=this._cp2(e,2,0),i=this._cp3(e,t,1.5,0);let h;h=o>=4?e[3]:this._cp3(e,t,1.25,-.5);const r=this._sub(t,c);this._normalize(r);const u=.5*this._dist(t,i),_=this._crossProduct(r,this._sub(h,c))>0,n=Math.cos(Math.PI/18);let a=Math.sin(Math.PI/18);_&&(a=-a);const l=[c,t];r[0]*=u,r[1]*=u;const p=this._add(t,r);r[0]=-r[0],r[1]=-r[1];for(let t=1;t<=18;t++)this._rotateDirect(r,n,a),l.push(this._add(p,r));s.push(l);break}case r.GeometricEffectControlMeasureLineRule.LineWithStraightTicks:{const t=this._cp2(e,-2,1),i=this._cp3(e,t,-1,-.5),h=this._sub(i,t);this._normalize(h);const r=this._dotProduct(h,this._sub(t,c)),o=this._dotProduct(h,this._sub(i,c));let u=[c];u.push([c[0]+h[0]*r,c[1]+h[1]*r]),u.push(t),s.push(u),u=[c],u.push([c[0]+h[0]*o,c[1]+h[1]*o]),u.push(i),s.push(u);break}case r.GeometricEffectControlMeasureLineRule.DoubleCurve:{const t=this._cp2(e,-5,-1),i=this._cp3(e,t,2,0),r=Math.atan2(1,5),o=Math.cos(r),u=Math.sin(r),_=this._sub(t,c),n=this._dist(c,t);this._normalize(_),this._rotateDirect(_,o,-u);const a=[c];a.push([c[0]+_[0]*n*.5,c[1]+_[1]*n*.5]),h.setId(a[1],1),a.push([c[0]+_[0]*n*.8,c[1]+_[1]*n*.8]),this._addBezier2(a,a[2],[c[0]+_[0]*n,c[1]+_[1]*n],t,3);const l=this._sub(i,t),p=this._dist(t,i);this._normalize(l),this._rotateDirect(l,o,-u),this._addBezier2(a,t,[i[0]-l[0]*p,i[1]-l[1]*p],[i[0]-l[0]*p*.8,i[1]-l[1]*p*.8],3),a.push(i),s.push(a);break}case r.GeometricEffectControlMeasureLineRule.ParallelWithTicksByWidth:{const t=this._cp2(e,0,-1),i=this._cp3(e,t,.5,3),h=this._sub(t,c);this._normalize(h);const r=this._crossProduct(h,this._sub(i,c));this._leftPerpendicular(h),r>0?(this._addAngledTicks(s,c,[c[0]+h[0]*r,c[1]+h[1]*r],t),this._addAngledTicks(s,t,[t[0]+h[0]*r,t[1]+h[1]*r],c)):(this._addAngledTicks(s,[c[0]+h[0]*r,c[1]+h[1]*r],c,t),this._addAngledTicks(s,[t[0]+h[0]*r,t[1]+h[1]*r],c,t));break}case r.GeometricEffectControlMeasureLineRule.EnclosingRoundedRectangle:{const t=this._cp2(e,3,-2),s=[Math.min(c[0],t[0]),Math.max(c[1],t[1])],i=[Math.max(c[0],t[0]),Math.min(c[1],t[1])],h=i[0]-s[0],r=s[1]-i[1],o=Math.min(h,r)/10,u=[];u.push([s[0]+o+.75*(h-2*o),s[1]]),u.push([i[0]-o,s[1]]),this._add90DegArc(u,[i[0]-o,s[1]],[i[0],s[1]-o],[i[0],s[1]]),u.push([i[0],i[1]+o]),this._add90DegArc(u,[i[0],i[1]+o],[i[0]-o,i[1]],i),u.push([s[0]+o,i[1]]),this._add90DegArc(u,[s[0]+o,i[1]],[s[0],i[1]+o],[s[0],i[1]]),u.push([s[0],s[1]-o]),this._add90DegArc(u,[s[0],s[1]-o],[s[0]+o,s[1]],s),u.push([s[0]+o+.75*(h-2*o),s[1]]);break}case r.GeometricEffectControlMeasureLineRule.FullGeometry:default:s.push(e)}}return s}}t.EffectControlMeasureLine=o,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));