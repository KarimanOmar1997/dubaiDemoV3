// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Error","../../../core/Logger","../../../geometry/GeometryCursor","../../../geometry/SpatialReference","../../../geometry/support/coordsUtils","../../../geometry/support/jsonUtils","../../../geometry/support/PolylineBuilder","../../../geometry/support/TileClipper","../CIMCursor","../../../views/2d/engine/webgl/mesh/templates/segmentUtils"],(function(t,e,s,o,n,i,r,l,a,h,y){"use strict";const c=()=>s.getLogger("esri.symbols.cim.effects.EffectTaperedPolygon");class x{static{this.instance=null}static local(){return null===x.instance&&(x.instance=new x),x.instance}execute(t,e,s,o,n){return new _(t,e,s,o,n)}}class _ extends h.PathEffectCursor{constructor(t,e,s,o,n){super(t,!1,!0),this._slopeS=0,this._slopeC=1,this._lastTangent1=new a.Point(NaN,NaN),this._lastWidth=0,this._tileKey=null,this._halfFromWidth=Math.abs(void 0!==e.fromWidth?e.fromWidth:0)*s*.5,this._halfToWidth=Math.abs(void 0!==e.toWidth?e.toWidth:1)*s*.5,this._originalLength=(void 0!==e.length?e.length:0)*s,this._length=0,this._tileKey=o,this._geometryEngine=n}processPath(t){if(t.totalSize<=0)return null;if(this._halfFromWidth<=0&&this._halfToWidth<=0){const e=o.GeometryCursor.createEmptyOptimizedCIM("esriGeometryPolygon",!1,!1,t.yFactor);for(t.seekPathEnd();t.prevPoint();)e.pushXY(t.x,t.y);for(t.seekPathStart();t.nextPoint();)e.pushXY(t.x,t.y);return e}const s=[];t.seekPathStart();let a=0,h=0;for(;t.nextPoint();)s.push([t.x-a,t.y-h]),a=t.x,h=t.y;let x=this._geometryEngine?.simplify(n.WebMercator,{paths:[s]});x||null!=this._tileKey||(x={paths:[s]});const _=r.isPolygon(x)?x.rings:r.isPolyline(x)?x.paths:null;if(!_)return c().error(new e("mapview-bad-resource","Unable to process geometry")),null;const d=new l,p=new l;let f=0;for(const t of _){a=t[0][0],h=t[0][1];for(let e=1;e<t.length;e++){const s=a+t[e][0],o=h+t[e][1];f+=Math.sqrt((s-a)*(s-a)+(o-h)*(o-h)),a=s,h=o}}if(0===this._originalLength||this._originalLength>f){this._length=f;const t=(this._halfToWidth-this._halfFromWidth)/this._length;if(Math.abs(t)<1){const e=t*t;this._slopeC=Math.sqrt(1/(1+e)),this._slopeS=Math.sqrt(e/(1+e)),t<0&&(this._slopeS=-this._slopeS)}else this._slopeC=this._slopeS=.7071}else this._length=this._originalLength,this._slopeC=1,this._slopeS=0;let g=0;const u=[];for(const t of _){const e=y.SegmentCursor.create(t),s=y.SegmentCursor.create(t);this._setFromOffset(s,d,p);let o=s.next(),n=e;for(;o&&n;)g=this._setOffset(n,o,g,d,p),n=e.next(),o=s.next();n=e,n&&this._setToOffset(n,g,d,p);const i=d.getGeometry(),r=p.getGeometry(),l=[];for(const t of i)l.push(...t);for(let t=r.length-1;t>=0;t--){const e=r[t];for(let t=e.length-1;t>=0;t--)l.push(e[t])}u.push(l)}const m={rings:u};i.closeRingsAndFixWinding(m);let S=this._geometryEngine?.simplify(n.WebMercator,m);if(!S){if(null!=this._tileKey)return null;S=m}return o.GeometryCursor.fromJSONCIM(S)}_setFromOffset(t,e,s){const o=this._halfFromWidth,n=new a.Point(t.xEnd-t.xStart,t.yEnd-t.yStart);n.normalize(),n.scale(o),e.beginPath([t.xStart-n.y,t.yStart+n.x]),s.beginPath([t.xStart+n.y,t.yStart-n.x])}_setToOffset(t,e,s,o){let n;n=(e+=Math.sqrt((t.xEnd-t.xStart)*(t.xEnd-t.xStart)+(t.yEnd-t.yStart)*(t.yEnd-t.yStart)))>=this._length?this._halfToWidth:this._halfFromWidth+(this._halfToWidth-this._halfFromWidth)*e/this._length;const i=new a.Point(t.xEnd-t.xStart,t.yEnd-t.yStart);i.normalize(),i.scale(n),s.lineTo([t.xEnd-i.y,t.yEnd+i.x]),o.lineTo([t.xEnd+i.y,t.yEnd-i.x])}_setOffset(t,s,o,n,i){const r=Math.sqrt((t.xEnd-t.xStart)*(t.xEnd-t.xStart)+(t.yEnd-t.yStart)*(t.yEnd-t.yStart));let l;l=o+r>=this._length?this._halfToWidth:this._halfFromWidth+(this._halfToWidth-this._halfFromWidth)*(o+r)/this._length,o+=r;const h=new a.Point(t.xEnd,t.yEnd),y=new a.Point(t.xEnd-t.xStart,t.yEnd-t.yStart);y.normalize();const x=new a.Point(s.xEnd-s.xStart,s.yEnd-s.yStart);x.normalize();const _=y.x*x.y-y.y*x.x;let d;d=0===Math.abs(_)?new a.Point(x.x,x.y):new a.Point((x.x-y.x)/_,(x.y-y.y)/_);const p=n.getPointCount(),f=i.getPointCount();y.leftPerpendicular(),x.leftPerpendicular();const g=y.x*x.x+y.y*x.y;if(g>.99){const t=new a.Point((y.x+x.x)*l/2,(y.y+x.y)*l/2),e=t.clone();e.rotate(this._slopeC,this._slopeS),n.lineTo([h.x+e.x,h.y+e.y]);const s=t.clone();s.rotateReverse(this._slopeC,this._slopeS),i.lineTo([h.x-s.x,h.y-s.y])}else{if(_<0){const t=d.clone().scale(-l);t.rotateReverse(this._slopeC,this._slopeS);const s=i.getXY(f-1);s||c().error(new e("mapview-bad-resource","Unable to process geometry, index out of scope"));const o=a.Point.add(h,t),n=a.Point.sub(o,a.Point.fromArray(s));if(y.x*n.y-y.y*n.x>0){const t=new a.Point(-y.x*l,-y.y*l);t.rotateReverse(this._slopeC,this._slopeS);const e=new a.Point(-x.x*l,-x.y*l);e.rotateReverse(this._slopeC,this._slopeS),i.lineTo([h.x+t.x,h.y+t.y]),i.lineTo([h.x,h.y]),i.lineTo([h.x+e.x,h.y+e.y])}else i.lineTo([h.x+t.x,h.y+t.y])}else{const t=d.clone().scale(l);t.rotate(this._slopeC,this._slopeS);const s=n.getXY(p-1);s||c().error(new e("mapview-bad-resource","Unable to process geometry, index out of scope"));const o=a.Point.add(h,t),i=a.Point.sub(o,a.Point.fromArray(s));if(y.x*i.y-y.y*i.x>0){const t=y.clone().scale(l);t.rotate(this._slopeC,this._slopeS);const e=x.clone().scale(l);e.rotate(this._slopeC,this._slopeS),n.lineTo([h.x+t.x,h.y+t.y]),n.lineTo([h.x,h.y]),n.lineTo([h.x+e.x,h.y+e.y])}else n.lineTo([h.x+t.x,h.y+t.y])}const s=Math.acos(g);let o=1;if(l>.25){const t=2*Math.acos(1-.25/l);t<s&&(o=Math.round(s/t))}const r=Math.cos(s/o),u=Math.sin(s/o),m=y.clone();if(_<0){m.rotate(this._slopeC,this._slopeS);const s=n.getXY(p-1);s||c().error(new e("mapview-bad-resource","Unable to process geometry, index out of scope"));const o=a.Point.add(h,m.clone().scale(this._lastWidth)),i=a.Point.sub(o,a.Point.fromArray(s)),r=y.x*i.y-y.y*i.x;if(!isNaN(this._lastTangent1.x)&&!isNaN(this._lastTangent1.y)&&r>0){const e=new a.Point(t.xStart,t.yStart),s=this._lastTangent1.clone().scale(this._lastWidth);s.rotate(this._slopeC,this._slopeS);const o=y.clone().scale(this._lastWidth);o.rotate(this._slopeC,this._slopeS),n.lineTo([e.x+s.x,e.y+s.y]),n.lineTo([e.x,e.y]),n.lineTo([e.x+o.x,e.y+o.y])}}else{m.scale(-1).rotateReverse(this._slopeC,this._slopeS);const s=i.getXY(f-1);s||c().error(new e("mapview-bad-resource","Unable to process geometry, index out of scope"));const o=a.Point.add(h,m.clone().scale(this._lastWidth)),n=a.Point.sub(o,a.Point.fromArray(s)),r=y.x*n.y-y.y*n.x;if(!isNaN(this._lastTangent1.x)&&!isNaN(this._lastTangent1.y)&&r>0){const e=new a.Point(t.xStart,t.yStart),s=this._lastTangent1.clone().scale(-this._lastWidth);s.rotateReverse(this._slopeC,this._slopeS);const o=y.clone().scale(-this._lastWidth);o.rotateReverse(this._slopeC,this._slopeS),i.lineTo([e.x+s.x,e.y+s.y]),i.lineTo([e.x,e.y]),i.lineTo([e.x+o.x,e.y+o.y])}}m.scale(l);for(let t=0;t<=o;t++)_<0?(n.lineTo([h.x+m.x,h.y+m.y]),m.rotateReverse(r,u)):(i.lineTo([h.x+m.x,h.y+m.y]),m.rotate(r,u))}return this._lastTangent1.setCoords(y.x,y.y),this._lastWidth=l,o}}t.EffectTaperedPolygon=x,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));