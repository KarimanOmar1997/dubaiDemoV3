// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/promiseUtils","../utils","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/Texture","../../../../webgl/TextureDescriptor","../../../../webgl/VertexArrayObject","../../../../webgl/VertexElementDescriptor"],(function(t,e,a,r,s,i,o,n,l){"use strict";class c{constructor(t){this._params=t,this.animated=!1}isCompatible(t){if(!(t instanceof c))return!1;if(!a.timeExtentsEqual(this._params.timeExtent,t._params.timeExtent))return!1;let e=!0;return e=e&&this._params.loadImagery===t._params.loadImagery,e=e&&this._params.color.kind===t._params.color.kind,e=e&&this._params.opacity.kind===t._params.opacity.kind,e}async load(t,a){const{extent:r,size:s}=t;e.throwIfAborted(a);const i=await this._params.loadImagery(r,s[0],s[1],this._params.timeExtent,a);return new _(i,{color:this._params.color,opacity:this._params.opacity})}render(t,e,r){const{context:i}=t,{program:o}=r;i.setFaceCullingEnabled(!1),i.setBlendingEnabled(!0),i.setBlendFunction(s.BlendFactor.ONE,s.BlendFactor.ONE_MINUS_SRC_ALPHA),i.useProgram(o),o.setUniformMatrix3fv("u_dvsMat3",e.dvsMat3),i.bindTexture(r.texture,0),o.setUniform1i("u_texture",0),o.setUniform1f("u_Min",r.min),o.setUniform1f("u_Max",r.max),a.setUniforms(o,"color","vec4",this._params.color),a.setUniforms(o,"opacity","float",this._params.opacity),i.bindVAO(r.vertexArray),i.drawArrays(s.PrimitiveType.TRIANGLE_STRIP,0,4)}}const m=new Map;m.set("a_position",0),m.set("a_texcoord",1);const p=new Map([["geometry",[new l.VertexElementDescriptor("a_position",2,s.DataType.UNSIGNED_SHORT,0,8),new l.VertexElementDescriptor("a_texcoord",2,s.DataType.UNSIGNED_SHORT,4,8)]]]),h={vsPath:"raster/flow/imagery",fsPath:"raster/flow/imagery",attributes:m};class _{constructor(t,e){this._flowData=t,this._values=e}attach(t){const{context:e}=t,{width:a,height:l}=this._flowData,c=r.BufferObject.createVertex(e,s.Usage.STATIC_DRAW,new Uint16Array([0,0,0,1,a,0,1,1,0,l,0,0,a,l,1,0])),_=new Map([["geometry",c]]),d=new n.VertexArrayObject(e,m,p,_),u=[];"ramp"===this._values.color.kind&&u.push("vvColor"),"ramp"===this._values.opacity.kind&&u.push("vvOpacity");const f=t.getProgram(h,u);let x=1e6,w=-1e6;for(let t=0;t<l;t++)for(let e=0;e<a;e++)if(0!==this._flowData.mask[t*a+e]){const r=this._flowData.data[2*(t*a+e)],s=this._flowData.data[2*(t*a+e)+1],i=Math.sqrt(r*r+s*s);x=Math.min(x,i),w=Math.max(w,i)}const y=new Uint8Array(4*a*l);for(let t=0;t<l;t++)for(let e=0;e<a;e++)if(0!==this._flowData.mask[t*a+e]){const r=this._flowData.data[2*(t*a+e)],s=this._flowData.data[2*(t*a+e)+1],i=(Math.sqrt(r*r+s*s)-x)/(w-x);y[4*(t*a+e)]=255*i,y[4*(t*a+e)+1]=0,y[4*(t*a+e)+2]=0,y[4*(t*a+e)+3]=255}else y[4*(t*a+e)]=0,y[4*(t*a+e)+1]=0,y[4*(t*a+e)+2]=0,y[4*(t*a+e)+3]=0;const g=new o.TextureDescriptor;g.internalFormat=s.PixelFormat.RGBA,g.wrapMode=s.TextureWrapMode.CLAMP_TO_EDGE,g.flipped=!0,g.width=a,g.height=l;const D=new i.Texture(e,g,y);this.vertexArray=d,this.program=f,this.texture=D,this.min=x,this.max=w,this._flowData=null}detach(){this.vertexArray.dispose(),this.texture.dispose()}get ready(){return this.program.compiled}}t.Imagery=c,t.ImageryResources=_,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));