// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../geometry/support/TileClipper","./constants","./GeometryUtils","./TextShaping","./decluttering/config","./style/StyleDefinition"],(function(e,t,i,n,o,l,s){"use strict";const a=.5;class h{constructor(e,t,i,o,l,s=.5,a=n.cInfinity){this.anchor=e,this.labelAngle=t,this.glyphAngle=i,this.page=o,this.alternateVerticalGlyph=l,this.minzoom=s,this.maxzoom=a}}class c{constructor(e,t,i,n,o,l,s,a,h,c,r,y){this.tl=e,this.tr=t,this.bl=i,this.br=n,this.mosaicRect=o,this.labelAngle=l,this.minAngle=s,this.maxAngle=a,this.anchor=h,this.minzoom=c,this.maxzoom=r,this.page=y}}class r{constructor(e){this.shapes=e}}e.Anchor=class{constructor(e,t,i=0,n=-1,o=.5){this.x=e,this.y=t,this.angle=i,this.segment=n,this.minzoom=o}},e.PlacedSymbol=c,e.Placement=r,e.PlacementEngine=class{getIconPlacement(e,i,o){const a=new t.Point(e.x,e.y),h=o.rotationAlignment===s.RotationAlignment.MAP,c=o.keepUpright;let y=o.rotate*n.cDegToRad;h&&(y+=e.angle);const m=new r([]);return o.allowOverlap&&o.ignorePlacement||!l.declutterTiles||(m.iconColliders=[]),this._addIconPlacement(m,a,i,o,y),h&&c&&this._addIconPlacement(m,a,i,o,y+n.cPi),m}_addIconPlacement(e,i,o,h,r){const y=o.rasterizationScale,m=o.width/y,g=o.height/y,d=h.offset;let x=d[0],p=d[1];switch(h.anchor){case s.SymbolAnchor.CENTER:x-=m/2,p-=g/2;break;case s.SymbolAnchor.LEFT:p-=g/2;break;case s.SymbolAnchor.RIGHT:x-=m,p-=g/2;break;case s.SymbolAnchor.TOP:x-=m/2;break;case s.SymbolAnchor.BOTTOM:x-=m/2,p-=g;break;case s.SymbolAnchor.TOP_LEFT:break;case s.SymbolAnchor.BOTTOM_LEFT:p-=g;break;case s.SymbolAnchor.TOP_RIGHT:x-=m;break;case s.SymbolAnchor.BOTTOM_RIGHT:x-=m,p-=g}const P=o.rect,T=2/y,w=x-T,f=p-T,b=w+P.width/y,I=f+P.height/y,u=new t.Point(w,f),A=new t.Point(b,I),S=new t.Point(w,I),O=new t.Point(b,f);if(0!==r){const e=Math.cos(r),t=Math.sin(r);u.rotate(e,t),A.rotate(e,t),S.rotate(e,t),O.rotate(e,t)}const G=new c(u,O,S,A,P,r,0,256,i,a,n.cInfinity,0);if(e.shapes.push(G),(!h.allowOverlap||!h.ignorePlacement)&&l.declutterTiles){const t=h.size,o=h.padding,l={xTile:i.x,yTile:i.y,dxPixels:x*t-o,dyPixels:p*t-o,hard:!h.optional,partIndex:0,width:m*t+2*o,height:g*t+2*o,angle:r,minLod:a,maxLod:n.cInfinity};e.iconColliders.push(l)}}getTextPlacement(e,l,y,m){const g=new t.Point(e.x,e.y),d=m.rotate*n.cDegToRad,x=m.rotationAlignment===s.RotationAlignment.MAP,p=m.keepUpright,P=m.padding;let T=a;const w=x?e.angle:0,f=e.segment>=0&&x,b=m.allowOverlap&&m.ignorePlacement?null:[],I=[],u=!f;let A=Number.POSITIVE_INFINITY,S=Number.NEGATIVE_INFINITY,O=A,G=S;const M=(f||x)&&p,_=m.size/o.sdfGlyphSize;let k=!1;for(const e of l)if(e.vertical){k=!0;break}let z,E=0,N=0;if(!f&&k){const e=o.TextShaping.getTextBox(l,m.lineHeight*o.sdfGlyphSize);switch(m.anchor){case s.SymbolAnchor.LEFT:E=e.height/2,N=-e.width/2;break;case s.SymbolAnchor.RIGHT:E=-e.height/2,N=e.width/2;break;case s.SymbolAnchor.TOP:E=e.height/2,N=e.width/2;break;case s.SymbolAnchor.BOTTOM:E=-e.height/2,N=-e.width/2;break;case s.SymbolAnchor.TOP_LEFT:E=e.height;break;case s.SymbolAnchor.BOTTOM_LEFT:N=-e.width;break;case s.SymbolAnchor.TOP_RIGHT:N=e.width;break;case s.SymbolAnchor.BOTTOM_RIGHT:E=-e.height}}E+=m.offset[0]*o.sdfGlyphSize,N+=m.offset[1]*o.sdfGlyphSize;for(const s of l){const l=s.glyphMosaicItem;if(!l||l.rect.isEmpty)continue;const r=l.rect,L=l.metrics,R=l.page;if(b&&u){if(void 0!==z&&z!==s.y){let t,i,o,l;k?(t=-G+E,i=A+N,o=G-O,l=S-A):(t=A+E,i=O+N,o=S-A,l=G-O);const s={xTile:e.x,yTile:e.y,dxPixels:t*_-P,dyPixels:i*_-P,hard:!m.optional,partIndex:1,width:o*_+2*P,height:l*_+2*P,angle:d,minLod:a,maxLod:n.cInfinity};b.push(s),A=Number.POSITIVE_INFINITY,S=Number.NEGATIVE_INFINITY,O=A,G=S}z=s.y}const v=[];if(f){const t=.5*l.metrics.width,n=(s.x+L.left-4+t)*_*i.tilePixelRatio;if(T=this._placeGlyph(e,T,n,y,e.segment,1,s.vertical,R,v),p&&(T=this._placeGlyph(e,T,n,y,e.segment,-1,s.vertical,R,v)),T>=2)break}else v.push(new h(g,w,w,R,!1)),x&&p&&v.push(new h(g,w+n.cPi,w+n.cPi,R,!1));const F=s.x+L.left,B=s.y-o.sdfGlyphBaseline-L.top,H=F+L.width,V=B+L.height;let C,Y,q,D,U,j,J,K;if(!f&&k)if(s.vertical){const e=(F+H)/2-L.height/2,i=(B+V)/2+L.width/2;C=new t.Point(-i-4+E,e-4+N),Y=new t.Point(C.x+r.width,C.y+r.height),q=new t.Point(C.x,Y.y),D=new t.Point(Y.x,C.y)}else C=new t.Point(4-B+E,F-4+N),Y=new t.Point(C.x-r.height,C.y+r.width),q=new t.Point(Y.x,C.y),D=new t.Point(C.x,Y.y);else C=new t.Point(F-4+E,B-4+N),Y=new t.Point(C.x+r.width,C.y+r.height),q=new t.Point(C.x,Y.y),D=new t.Point(Y.x,C.y);for(const i of v){let n,o,l,a;if(i.alternateVerticalGlyph){if(!U){const e=(F+H)/2+E,i=(B+V)/2+N;U=new t.Point(e-L.height/2-4,i+L.width/2+4),j=new t.Point(U.x+r.height,U.y-r.width),J=new t.Point(j.x,U.y),K=new t.Point(U.x,j.y)}n=U,o=J,l=K,a=j}else n=C,o=q,l=D,a=Y;const h=B,y=V,g=i.glyphAngle+d;if(0!==g){const e=Math.cos(g),t=Math.sin(g);n=n.clone(),o=o?.clone(),l=l?.clone(),a=a?.clone(),n.rotate(e,t),a?.rotate(e,t),o?.rotate(e,t),l?.rotate(e,t)}let x=0,p=256;if(f&&k?s.vertical?i.alternateVerticalGlyph?(x=32,p=96):(x=224,p=32):(x=224,p=96):(x=192,p=64),I.push(new c(n,l,o,a,r,i.labelAngle,x,p,i.anchor,i.minzoom,i.maxzoom,i.page)),b&&(!M||this._legible(i.labelAngle)))if(u)F<A&&(A=F),h<O&&(O=h),H>S&&(S=H),y>G&&(G=y);else if(i.minzoom<2){const t={xTile:e.x,yTile:e.y,dxPixels:(F+E)*_-P,dyPixels:(h+E)*_-P,hard:!m.optional,partIndex:1,width:(H-F)*_+2*P,height:(y-h)*_+2*P,angle:g,minLod:i.minzoom,maxLod:i.maxzoom};b.push(t)}}}if(T>=2)return null;if(b&&u){let t,i,o,l;k?(t=-G+E,i=A+N,o=G-O,l=S-A):(t=A+E,i=O+N,o=S-A,l=G-O);const s={xTile:e.x,yTile:e.y,dxPixels:t*_-P,dyPixels:i*_-P,hard:!m.optional,partIndex:1,width:o*_+2*P,height:l*_+2*P,angle:d,minLod:a,maxLod:n.cInfinity};b.push(s)}const L=new r(I);return b&&b.length>0&&(L.textColliders=b),L}_legible(e){const t=n.radToByte(e);return t<65||t>=193}_placeGlyph(e,i,o,l,s,a,c,r,y){let m=a;const g=m<0?n.positiveMod(e.angle+n.cPi,n.c2pi):e.angle;let d=0;o<0&&(m*=-1,o*=-1,d=n.cPi),m>0&&++s;let x=new t.Point(e.x,e.y),p=l[s],P=n.cInfinity;if(l.length<=s)return P;for(;;){const e=p.x-x.x,t=p.y-x.y,a=Math.sqrt(e*e+t*t),T=Math.max(o/a,i),w=e/a,f=t/a,b=n.positiveMod(Math.atan2(f,w)+d,n.c2pi);if(y.push(new h(x,g,b,r,!1,T,P)),c&&y.push(new h(x,g,b,r,!0,T,P)),T<=i)return T;x=p.clone();do{if(s+=m,l.length<=s||s<0)return T;p=l[s]}while(x.isEqual(p));let I=p.x-x.x,u=p.y-x.y;const A=Math.sqrt(I*I+u*u);I*=a/A,u*=a/A,x.x-=I,x.y-=u,P=T}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));