// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../../core/BidiEngine","../../../../../core/maybe","../../../../../core/string","../../../../../geometry/support/TileClipper","../constants","../enums","../GeometryUtils","../Placement","../TextShaping","./BaseBucket","../style/StyleDefinition","../style/StyleLayer"],(function(e,t,n,i,o,s,a,r,l,h,c,x){"use strict";function y(e,t){return e.iconMosaicItem&&t.iconMosaicItem?e.iconMosaicItem.page===t.iconMosaicItem.page?0:e.iconMosaicItem.page-t.iconMosaicItem.page:e.iconMosaicItem&&!t.iconMosaicItem?1:!e.iconMosaicItem&&t.iconMosaicItem?-1:0}class d extends h{constructor(e,t,n,i,o,a,r,l,h){super(t,n,h.getSpriteItems()),this.type=s.BucketType.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=e,this._iconVertexBuffer=i,this._iconIndexBuffer=o,this._textVertexBuffer=a,this._textIndexBuffer=r,this._placementEngine=l,this._workerTileHandler=h}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}static{this._bidiEngine=new e}getResources(e,t,i){const o=this.layer,s=this.zoom;e&&e.setExtent(this.layerExtent);const a=o.getLayoutProperty("icon-image"),r=o.getLayoutProperty("text-field");let l=o.getLayoutProperty("text-transform"),h=o.getLayoutProperty("text-font");const x=[];let y,g,f,m;a&&!a.isDataDriven&&(y=a.getValue(s)),r&&!r.isDataDriven&&(g=r.getValue(s)),l&&l.isDataDriven||(f=o.getLayoutValue("text-transform",s),l=null),h&&h.isDataDriven||(m=o.getLayoutValue("text-font",s),h=null);for(const u of this._features){const p=u.getGeometry(e);if(!p||0===p.length)continue;let _,P;a&&(_=a.isDataDriven?a.getValue(s,u):this._replaceKeys(y,u.values),_&&t(_));let b=!1;if(r&&(P=r.isDataDriven?r.getValue(s,u):this._replaceKeys(g,u.values),P)){switch(P=P.replaceAll("\\n","\n"),l&&(f=l.getValue(s,u)),f){case c.TextTransform.LOWERCASE:P=P.toLowerCase();break;case c.TextTransform.UPPERCASE:P=P.toUpperCase()}if(d._bidiEngine.hasBidiChar(P)){let e;e="rtl"===d._bidiEngine.checkContextual(P)?"IDNNN":"ICNNN",P=d._bidiEngine.bidiTransform(P,e,"VLYSN"),b=!0}if(P.length>0){h&&(m=h.getValue(s,u));for(const e of m){let t=i[e];t||(t=i[e]=new Set);for(const e of P){const n=e.codePointAt(0);null!=n&&t.add(n)}}}}if(!_&&!P)continue;const M=o.getLayoutValue("symbol-sort-key",s,u),A={feature:u,sprite:_,label:P,rtl:b,geometry:p,hash:(P?n.numericHash(P):0)^(_?n.numericHash(_):0),priority:M,textFont:m};x.push(A)}this._symbolFeatures=x}processFeatures(e){e&&e.setExtent(this.layerExtent);const n=this.layer,s=this.zoom,h=n.getLayoutValue("symbol-placement",s),g=h!==c.SymbolPlacement.POINT,f=n.getLayoutValue("symbol-spacing",s)*o.tilePixelRatio,m=n.getLayoutProperty("icon-image"),u=n.getLayoutProperty("text-field"),p=m?new x.IconLayout(n,s,g):null,_=u?new x.TextLayout(n,s,g):null,P=this._workerTileHandler;let b;m&&(b=P.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const M=[];let A=1;_?.size&&(A=_.size/l.sdfGlyphSize);const I=_?_.maxAngle*a.cDegToRad:0,T=_?_.size*o.tilePixelRatio:0;for(const e of this._symbolFeatures){let n,a;p&&b&&e.sprite&&(n=b[e.sprite],n&&n.sdf&&(this._isIconSDF=!0)),n&&p.update(s,e.feature);let x=0;const y=e.label;if(y){t.assertIsSome(_),_.update(s,e.feature);const n=g&&_.rotationAlignment===c.RotationAlignment.MAP?_.keepUpright:_.writingMode&&_.writingMode.includes(c.TextWritingMode.VERTICAL);let i=.5;switch(_.anchor){case c.SymbolAnchor.TOP_LEFT:case c.SymbolAnchor.LEFT:case c.SymbolAnchor.BOTTOM_LEFT:i=0;break;case c.SymbolAnchor.TOP_RIGHT:case c.SymbolAnchor.RIGHT:case c.SymbolAnchor.BOTTOM_RIGHT:i=1}let r=.5;switch(_.anchor){case c.SymbolAnchor.TOP_LEFT:case c.SymbolAnchor.TOP:case c.SymbolAnchor.TOP_RIGHT:r=0;break;case c.SymbolAnchor.BOTTOM_LEFT:case c.SymbolAnchor.BOTTOM:case c.SymbolAnchor.BOTTOM_RIGHT:r=1}let h=.5;switch(_.justify){case c.TextJustification.AUTO:h=i;break;case c.TextJustification.LEFT:h=0;break;case c.TextJustification.RIGHT:h=1}const d=_.letterSpacing*l.sdfGlyphSize,f=g?0:_.maxWidth*l.sdfGlyphSize,m=_.lineHeight*l.sdfGlyphSize,u=e.textFont.map((e=>P.getGlyphItems(e)));if(a=new l.TextShaping(u,f,m,d,i,r,h).getShaping(y,e.rtl,n),a&&a.length>0){let e=1e30,t=-1e30;for(const n of a)e=Math.min(e,n.x),t=Math.max(t,n.x);x=(t-e+2*l.sdfGlyphSize)*A*o.tilePixelRatio}}for(let t of e.geometry){const s=[];if(h===c.SymbolPlacement.LINE){if(a?.length&&_?.size){const e=_.size*o.tilePixelRatio*(2+Math.min(2,4*Math.abs(_.offset[1])));t=d._smoothVertices(t,e)}d._pushAnchors(s,t,f,x)}else h===c.SymbolPlacement.LINE_CENTER?d._pushCenterAnchor(s,t):e.feature.type===i.GeometryType.Polygon?d._pushCentroid(s,t):s.push(new r.Anchor(t[0].x,t[0].y));for(const i of s){if(i.x<0||i.x>o.tileCoordSize||i.y<0||i.y>o.tileCoordSize)continue;if(g&&x>0&&_?.rotationAlignment===c.RotationAlignment.MAP&&!d._honorsTextMaxAngle(t,i,x,I,T))continue;const s={shaping:a,line:t,iconMosaicItem:n,anchor:i,symbolFeature:e,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};M.push(s),this._processFeature(s,p,_)}}}M.sort(y),this._addPlacedGlyphs(),this._symbolInstances=M}serialize(){let e=14;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=d._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer),i=new Float32Array(t.buffer),[o,s,a]=this._sourceTileKey.split("/");let r=0;t[r++]=this.type,t[r++]=this.layerUIDs.length;for(let e=0;e<this.layerUIDs.length;e++)t[r++]=this.layerUIDs[e];t[r++]=this._isIconSDF?1:0,t[r++]=parseFloat(o),t[r++]=parseFloat(s),t[r++]=parseFloat(a),t[r++]=this.markerPageMap.size;for(const[e,[n,i]]of this.markerPageMap)t[r++]=e,t[r++]=n,t[r++]=i;t[r++]=this.glyphsPageMap.size;for(const[e,[n,i]]of this.glyphsPageMap)t[r++]=e,t[r++]=n,t[r++]=i;t[r++]=this._iconVertexBuffer.index/4,t[r++]=this._textVertexBuffer.index/4,r=d.serializeSymbols(t,n,i,r,this._symbolInstances),t[r++]=this._iconVertexBuffer.array.length;for(let e=0;e<this._iconVertexBuffer.array.length;e++)n[r++]=this._iconVertexBuffer.array[e];t[r++]=this._iconIndexBuffer.array.length;for(let e=0;e<this._iconIndexBuffer.array.length;e++)t[r++]=this._iconIndexBuffer.array[e];t[r++]=this._textVertexBuffer.array.length;for(let e=0;e<this._textVertexBuffer.array.length;e++)n[r++]=this._textVertexBuffer.array[e];t[r++]=this._textIndexBuffer.array.length;for(let e=0;e<this._textIndexBuffer.array.length;e++)t[r++]=this._textIndexBuffer.array[e];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const n of e||[]){t+=5,t+=1;for(const e of n.textColliders)t+=10;for(const e of n.iconColliders)t+=10;t+=1,t+=2*n.textVertexRanges.length,t+=1,t+=2*n.iconVertexRanges.length}return t}static serializeSymbols(e,t,n,i,o){o=o||[],t[i++]=o.length;for(const e of o){t[i++]=e.anchor.x,t[i++]=e.anchor.y,t[i++]=e.symbolFeature.hash,t[i++]=e.symbolFeature.priority,t[i++]=e.symbolFeature.feature.featureIndex,t[i++]=e.textColliders.length+e.iconColliders.length;for(const o of e.textColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;for(const o of e.iconColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;t[i++]=e.textVertexRanges.length;for(const[n,o]of e.textVertexRanges)t[i++]=n,t[i++]=o;t[i++]=e.iconVertexRanges.length;for(const[n,o]of e.iconVertexRanges)t[i++]=n,t[i++]=o}return i}_replaceKeys(e,t){return e.replaceAll(/{([^{}]+)}/g,((e,n)=>n in t?t[n]:""))}_processFeature(e,t,n){const{line:i,iconMosaicItem:o,shaping:s,anchor:r}=e,l=this.zoom,h=this.layer,x=!!o;let y=!0;x&&(y=t?.optional||!o);const d=s&&s.length>0,g=!d||n?.optional;let f,m;if(x&&(f=this._placementEngine.getIconPlacement(r,o,t)),(f||y)&&(d&&(m=this._placementEngine.getTextPlacement(r,s,i,n)),m||g)){if(f&&m||(g||y?g||m?y||f||(m=null):f=null:(f=null,m=null)),m){const t=h.hasDataDrivenText?h.textMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._storePlacedGlyphs(e,m.shapes,l,n.rotationAlignment,t),m.textColliders){e.textColliders=m.textColliders;for(const e of m.textColliders){e.minLod=Math.max(l+a.log2(e.minLod),0),e.maxLod=Math.min(l+a.log2(e.maxLod),25);const t=e.angle;if(t){const n=Math.cos(t),i=Math.sin(t),o=e.dxPixels*n-e.dyPixels*i,s=e.dxPixels*i+e.dyPixels*n,a=(e.dxPixels+e.width)*n-e.dyPixels*i,r=(e.dxPixels+e.width)*i+e.dyPixels*n,l=e.dxPixels*n-(e.dyPixels+e.height)*i,h=e.dxPixels*i+(e.dyPixels+e.height)*n,c=(e.dxPixels+e.width)*n-(e.dyPixels+e.height)*i,x=(e.dxPixels+e.width)*i+(e.dyPixels+e.height)*n,y=Math.min(o,a,l,c),d=Math.max(o,a,l,c),g=Math.min(s,r,h,x),f=Math.max(s,r,h,x);e.dxPixels=y,e.dyPixels=g,e.width=d-y,e.height=f-g}}}}if(f){const n=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._addPlacedIcons(e,f.shapes,l,o.page,t.rotationAlignment===c.RotationAlignment.VIEWPORT,n),f.iconColliders){e.iconColliders=f.iconColliders;for(const e of f.iconColliders){e.minLod=Math.max(l+a.log2(e.minLod),0),e.maxLod=Math.min(l+a.log2(e.maxLod),25);const t=e.angle;if(t){const n=Math.cos(t),i=Math.sin(t),o=e.dxPixels*n-e.dyPixels*i,s=e.dxPixels*i+e.dyPixels*n,a=(e.dxPixels+e.width)*n-e.dyPixels*i,r=(e.dxPixels+e.width)*i+e.dyPixels*n,l=e.dxPixels*n-(e.dyPixels+e.height)*i,h=e.dxPixels*i+(e.dyPixels+e.height)*n,c=(e.dxPixels+e.width)*n-(e.dyPixels+e.height)*i,x=(e.dxPixels+e.width)*i+(e.dyPixels+e.height)*n,y=Math.min(o,a,l,c),d=Math.max(o,a,l,c),g=Math.min(s,r,h,x),f=Math.max(s,r,h,x);e.dxPixels=y,e.dyPixels=g,e.width=d-y,e.height=f-g}}}}}}_addPlacedIcons(e,t,n,i,o,s){const r=Math.max(n-1,0),l=this._iconVertexBuffer,h=this._iconIndexBuffer,c=this._markerMap;for(const x of t){const t=o?0:Math.max(n+a.log2(x.minzoom),r),y=o?25:Math.min(n+a.log2(x.maxzoom),25);if(y<=t)continue;const d=x.tl,g=x.tr,f=x.bl,m=x.br,u=x.mosaicRect,p=x.labelAngle,_=x.minAngle,P=x.maxAngle,b=x.anchor,M=l.index,A=u.x,I=u.y,T=A+u.width,S=I+u.height,L=l.index;l.add(b.x,b.y,d.x,d.y,A,I,p,_,P,t,y,s),l.add(b.x,b.y,g.x,g.y,T,I,p,_,P,t,y,s),l.add(b.x,b.y,f.x,f.y,A,S,p,_,P,t,y,s),l.add(b.x,b.y,m.x,m.y,T,S,p,_,P,t,y,s),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===L?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([L,4]),h.add(M,M+1,M+2),h.add(M+1,M+2,M+3),c.has(i)?c.get(i)[1]+=6:c.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,n=this._glyphMap;for(const[i,o]of this._glyphBufferDataStorage)for(const s of o){const o=e.index,a=s.symbolInstance,r=s.ddAttributes,l=e.index;e.add(s.glyphAnchor[0],s.glyphAnchor[1],s.tl[0],s.tl[1],s.xmin,s.ymin,s.labelAngle,s.minAngle,s.maxAngle,s.minLod,s.maxLod,r),e.add(s.glyphAnchor[0],s.glyphAnchor[1],s.tr[0],s.tr[1],s.xmax,s.ymin,s.labelAngle,s.minAngle,s.maxAngle,s.minLod,s.maxLod,r),e.add(s.glyphAnchor[0],s.glyphAnchor[1],s.bl[0],s.bl[1],s.xmin,s.ymax,s.labelAngle,s.minAngle,s.maxAngle,s.minLod,s.maxLod,r),e.add(s.glyphAnchor[0],s.glyphAnchor[1],s.br[0],s.br[1],s.xmax,s.ymax,s.labelAngle,s.minAngle,s.maxAngle,s.minLod,s.maxLod,r),a.textVertexRanges.length>0&&a.textVertexRanges[0][0]+a.textVertexRanges[0][1]===l?a.textVertexRanges[0][1]+=4:a.textVertexRanges.push([l,4]),t.add(o,o+1,o+2),t.add(o+1,o+2,o+3),n.has(i)?n.get(i)[1]+=6:n.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,n,i,o){const s=Math.max(n-1,0),r=i===c.RotationAlignment.VIEWPORT;let l,h,x,y,d,g,f,m,u,p,_;for(const i of t)l=r?0:Math.max(n+a.log2(i.minzoom),s),h=r?25:Math.min(n+a.log2(i.maxzoom),25),h<=l||(x=i.tl,y=i.tr,d=i.bl,g=i.br,f=i.labelAngle,m=i.minAngle,u=i.maxAngle,p=i.anchor,_=i.mosaicRect,this._glyphBufferDataStorage.has(i.page)||this._glyphBufferDataStorage.set(i.page,[]),this._glyphBufferDataStorage.get(i.page).push({glyphAnchor:[p.x,p.y],tl:[x.x,x.y],tr:[y.x,y.y],bl:[d.x,d.y],br:[g.x,g.y],xmin:_.x,ymin:_.y,xmax:_.x+_.width,ymax:_.y+_.height,labelAngle:f,minAngle:m,maxAngle:u,minLod:l,maxLod:h,placementLod:s,symbolInstance:e,ddAttributes:o}))}static _pushAnchors(e,t,n,o){n+=o;let s=0;const l=t.length-1;for(let e=0;e<l;e++)s+=i.Point.distance(t[e],t[e+1]);let h=o||n;if(h*=.5,s<=h)return;const c=h/s;let x=0,y=-(n=s/Math.max(Math.round(s/n),1))/2;const d=t.length-1;for(let i=0;i<d;i++){const o=t[i],s=t[i+1],l=s.x-o.x,h=s.y-o.y,d=Math.sqrt(l*l+h*h);let g;for(;y+n<x+d;){y+=n;const t=(y-x)/d,f=a.interpolate(o.x,s.x,t),m=a.interpolate(o.y,s.y,t);void 0===g&&(g=Math.atan2(h,l)),e.push(new r.Anchor(f,m,g,i,c))}x+=d}}static _pushCenterAnchor(e,t){let n=0;const o=t.length-1;for(let e=0;e<o;e++)n+=i.Point.distance(t[e],t[e+1]);const s=n/2;let l=0;const h=t.length-1;for(let n=0;n<h;n++){const i=t[n],o=t[n+1],h=o.x-i.x,c=o.y-i.y,x=Math.sqrt(h*h+c*c);if(s<l+x){const t=(s-l)/x,y=a.interpolate(i.x,o.x,t),d=a.interpolate(i.y,o.y,t),g=Math.atan2(c,h);return void e.push(new r.Anchor(y,d,g,n,0))}l+=x}}static _deviation(e,t,n){const i=(t.x-e.x)*(n.x-t.x)+(t.y-e.y)*(n.y-t.y),o=(t.x-e.x)*(n.y-t.y)-(t.y-e.y)*(n.x-t.x);return Math.atan2(o,i)}static _honorsTextMaxAngle(e,t,n,o,s){let a=0;const r=n/2;let l=new i.Point(t.x,t.y),h=t.segment+1;for(;a>-r;){if(--h,h<0)return!1;a-=i.Point.distance(e[h],l),l=e[h]}a+=i.Point.distance(e[h],e[h+1]);const c=[];let x=0;const y=e.length;for(;a<r;){const t=e[h];let n,r=h;do{if(++r,r===y)return!1;n=e[r]}while(n.isEqual(t));let l,d=r;do{if(++d,d===y)return!1;l=e[d]}while(l.isEqual(n));const g=this._deviation(t,n,l);for(c.push({deviation:g,distToAnchor:a}),x+=g;a-c[0].distToAnchor>s;)x-=c.shift().deviation;if(Math.abs(x)>o)return!1;a+=i.Point.distance(n,l),h=r}return!0}static _smoothVertices(e,t){if(t<=0)return e;let n=e.length;if(n<3)return e;const o=[];let s=0,a=0;o.push(0);for(let t=1;t<n;t++){const n=i.Point.distance(e[t],e[t-1]);n>0&&(s+=n,o.push(s),a++,a!==t&&(e[a]=e[t]))}if(n=a+1,n<3)return e;t=Math.min(t,.2*s);const r=e[0].x,l=e[0].y,h=e[n-1].x,c=e[n-1].y,x=i.Point.sub(e[0],e[1]);x.normalize(),e[0].x+=t*x.x,e[0].y+=t*x.y,x.assignSub(e[n-1],e[n-2]),x.normalize(),e[n-1].x+=t*x.x,e[n-1].y+=t*x.y,o[0]-=t,o[n-1]+=t;const y=[];y.push(new i.Point(r,l));const d=1e-6,g=.5*t;for(let s=1;s<n-1;s++){let a=0,r=0,l=0;for(let n=s-1;n>=0;n--){const i=g+o[n+1]-o[s];if(i<0)break;const h=o[n+1]-o[n],c=o[s]-o[n]<g?1:i/h;if(c<d)break;const x=c*c,y=c*i-.5*x*h,f=c*h/t,m=e[n+1],u=e[n].x-m.x,p=e[n].y-m.y;a+=f/y*(m.x*c*i+.5*x*(i*u-h*m.x)-x*c*h*u/3),r+=f/y*(m.y*c*i+.5*x*(i*p-h*m.y)-x*c*h*p/3),l+=f}for(let i=s+1;i<n;i++){const n=g-o[i-1]+o[s];if(n<0)break;const h=o[i]-o[i-1],c=o[i]-o[s]<g?1:n/h;if(c<d)break;const x=c*c,y=c*n-.5*x*h,f=c*h/t,m=e[i-1],u=e[i].x-m.x,p=e[i].y-m.y;a+=f/y*(m.x*c*n+.5*x*(n*u-h*m.x)-x*c*h*u/3),r+=f/y*(m.y*c*n+.5*x*(n*p-h*m.y)-x*c*h*p/3),l+=f}y.push(new i.Point(a/l,r/l))}return y.push(new i.Point(h,c)),e[0].x=r,e[0].y=l,e[n-1].x=h,e[n-1].y=c,y}static _pushCentroid(e,t){const n=o.tileCoordSize,i=o.tileCoordSize,s=t.length-1;let a=0,l=0,h=0,c=t[0].x,x=t[0].y;c>n&&(c=n),c<0&&(c=0),x>i&&(x=i),x<0&&(x=0);for(let e=1;e<s;e++){let o=t[e].x,s=t[e].y,r=t[e+1].x,y=t[e+1].y;o>n&&(o=n),o<0&&(o=0),s>i&&(s=i),s<0&&(s=0),r>n&&(r=n),r<0&&(r=0),y>i&&(y=i),y<0&&(y=0);const d=(o-c)*(y-x)-(r-c)*(s-x);a+=d*(c+o+r),l+=d*(x+s+y),h+=d}a/=3*h,l/=3*h,isNaN(a)||isNaN(l)||e.push(new r.Anchor(a,l))}}return d}));