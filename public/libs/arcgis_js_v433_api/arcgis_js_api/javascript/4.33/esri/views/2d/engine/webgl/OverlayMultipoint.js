// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../core/events","../../../../core/Handles","../../../../core/maybe","../../../../core/reactiveUtils","../../../../core/screenUtils","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../geometry/Point","../../../../geometry/Polygon","../../../../geometry/projectionUtils","../DisplayObject","../../../layers/support/Geometry","../../../webgl/enums","../../../webgl/Texture","../../../webgl/TextureDescriptor"],(function(t,e,i,r,n,s,o,a,h,l,c,u,d,p){"use strict";class x extends l.DisplayObject{constructor(i){super(),this.element=i,this._handles=new e,this.isWrapAround=!1,this.perspectiveTransform=s.create(),this.wrapAroundShift=0,this.clipGeometry=null,this._handles.add(r.when((()=>this.element),(()=>{const e=this.element;this.ready(),e&&this._handles.add(t.on(e,"play",(()=>this.requestRender())))}),r.initial))}getMesh(t){throw new Error("Method not implemented.")}destroy(){this._handles.destroy(),this.texture=i.disposeMaybe(this.texture)}get textureSize(){if(!this.texture)return[1,1];const t=this.texture.descriptor;return[t.width,t.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(t){const e=this.element;if(null==e)return;const{context:i}=t,{videoWidth:r,videoHeight:n}=e;if(0!==r&&0!==n){if(this.texture)e.paused||this.texture.setData(e);else{const t=new p.TextureDescriptor;t.wrapMode=u.TextureWrapMode.CLAMP_TO_EDGE,t.preMultiplyAlpha=!0,t.width=r,t.height=n,this.texture=new d.Texture(i,t,e)}e.paused||(this.texture.generateMipmap(),this.requestRender()),super.beforeRender(t)}}_createTransforms(){return null}updateDrawCoords(t,e,i,r){const n=this.element,s=this._getFrameInfo();if(!n||!s)return;const{spatialReference:o}=i;this._initializeData(t,s,o);const{controlPoints:l,horizon:u}=s,d=Math.sqrt(l.length),p=d,{x,y:m}=t,f=this._vertices,y=l[0],g=l[d-1],P=l[(p-1)*d],w=l[(p-1)*d+d-1],_=h.project(u?u[0].mapPoint:y.mapPoint,o),v=h.project(u?u[1].mapPoint:g.mapPoint,o),M=h.project(P.mapPoint,o),A=h.project(w.mapPoint,o);this.clipGeometry=u?new c({geometry:a.fromJSON({rings:[[[M.x,M.y],[A.x,A.y],[v.x,v.y],[_.x,_.y],[M.x,M.y]]],spatialReference:o})}):null;for(let t=0;t<l.length;t++){const e=l[t],{sourcePoint:i,mapPoint:r}=e;if(null==i||null==r)continue;const n=h.project(r,o);f[2*t+0]=n.x-x,f[2*t+1]=n.y-m}let b=e;if(r){const t=Math.min(_.x,v.x,M.x,A.x),e=Math.max(_.x,v.x,M.x,A.x),{worldWidth:i,xBounds:n}=r,[s,o]=n;t<s&&e>s?b=i:e>o&&t<o&&(b=-i)}this.wrapAroundShift=b,this.isWrapAround=0!==b}draw(t,e){this.visible&&(this.isReady&&this._vertices&&this._indices&&this._texCoords?(this.stage||console.warn("OverlayMultipoint: stage is null"),e.render(t,{transform:{dvs:this.dvsMat3},config:{perspective:this.perspectiveTransform,texSize:this.textureSize,wrapAroundShift:this.wrapAroundShift,isWrapAround:this.isWrapAround,opacity:this.opacity,texture:{texture:this.texture,unit:0}},position:this._vertices,tex:this._texCoords,index:this._indices})):this.requestRender())}_initializeData(t,e,i){if(null!=this._vertices&&null!=this._indices)return;const{controlPoints:r}=e,n=Math.sqrt(r.length),s=n,o=new Float32Array(2*r.length),a=new Uint16Array(2*r.length);for(let e=0;e<r.length;e++){const n=r[e],{sourcePoint:s,mapPoint:l}=n;if(null==s||null==l)continue;const c=h.project(l,i);o[2*e+0]=c.x-t.x,o[2*e+1]=c.y-t.y,a[2*e+0]=s.x,a[2*e+1]=s.y}const l=new Uint16Array(s*n+(s-2)*(n+2));let c=0;for(let t=0;t<s;t++){for(let e=0;e<n;e++)l[c++]=t*n+e,l[c++]=(t+1)*n+e;t<s-2&&(l[c++]=(t+1)*n+(n-1),l[c++]=(t+1)*n)}this._vertices=o,this._texCoords=a,this._indices=l}_getFrameInfo(){if(!this.groundControlPoints)return null;const t=this._getFrameControlPoints(),e=this.frameHorizonPoints;let i=null;if(e){const t=e.startX,r=e.startY,s=e.endX,a=e.endY;i=[{sourcePoint:n.createScreenPoint(t,r),mapPoint:new o(e.startLongitude,e.startLatitude)},{sourcePoint:n.createScreenPoint(s,a),mapPoint:new o(e.endLongitude,e.endLatitude)}]}return{controlPoints:t,horizon:i}}_getFrameControlPoints(){const t=this.groundControlPoints,e=t?.length;if(!e)return[];const i=new Array(e),r=Math.max(...t.map((({x:t})=>t))),s=this.element.videoWidth/r;for(let r=0;r<e;r++){const{x:e,y:a,lat:h,lon:l}=t[r];i[r]={sourcePoint:n.createScreenPoint(e*s,-a*s),mapPoint:new o(l,h)}}return i}}return x}));