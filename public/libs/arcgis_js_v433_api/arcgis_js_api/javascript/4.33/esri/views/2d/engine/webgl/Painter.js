// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../core/has","../../../../core/maybe","../brushes","../vectorTiles/shaders/VTLMaterialManager","./BitBlitRenderer","./definitions","./enums","./MaterialManager","./TextureManager","./TextureUploadManager","./WorldExtentClipRenderer","./effects/BlendEffect","./effects/FeatureEffect","./effects/HighlightEffect","./effects/HittestEffect","./effects/post-processing/EffectManager","./meshing/SimpleMesh","./painter/RenderPass","./shaderGraph/techniques/TechniqueProgramCache","../../../webgl/enums","../../../webgl/FramebufferObject","../../../webgl/Renderbuffer","../../../webgl/RenderbufferDescriptor","../../../webgl/TextureDescriptor"],(function(e,t,r,s,i,n,a,o,l,h,c,d,f,u,p,b,_,S,E,g,M,B,m,F){"use strict";function w(e,t,r,s){return e!==a.WGLDrawPhase.LABEL_ALPHA&&e!==a.WGLDrawPhase.LABEL&&e!==a.WGLDrawPhase.HIGHLIGHT&&(1!==s||null!=t&&"normal"!==t||null!=r&&r.length>0)}return class{constructor(e,t){this.context=e,this._currentPipelineStateNeedsUpdate=!1,this._blitRenderer=new i.BitBlitRenderer,this._worldExtentRenderer=new c.WorldExtentRenderer,this._brushCache=new Map,this._lastWidth=null,this._lastHeight=null,this._vtlMaterialManager=new s,this._blendEffect=new d.BlendEffect,this._stencilBuf=null,this._prevBeforeLayerFBOStack=[],this._fboPool=[],this.effects={highlight:new u,hittest:new p.HittestEffect,insideEffect:new f.FeatureEffect("inside"),outsideEffect:new f.FeatureEffect("outside")},this._programCache=new E.TechniqueProgramCache,this._shaderState={shader:null,uniforms:null,defines:null,optionalAttributes:null,useComputeBuffer:!1},this.materialManager=new o(e),this.textureManager=new l(t),this.textureUploadManager=new h.TextureUploadManager(t),this._effectsManager=new b.EffectManager,this._quadMesh=_.SimpleMesh.fromVertexStream(e,[0,0,1,0,0,1,1,1])}dispose(){if(this._programCache.destroy(),this.materialManager.dispose(),this.textureManager.dispose(),this.textureUploadManager.destroy(),this._blitRenderer=t.disposeMaybe(this._blitRenderer),this._worldExtentRenderer=t.disposeMaybe(this._worldExtentRenderer),this._quadMesh=t.destroyMaybe(this._quadMesh),this._brushCache&&(this._brushCache.forEach((e=>e.dispose())),this._brushCache.clear(),this._brushCache=null),this._fbos){let e;for(e in this._fbos)this._fbos[e]&&this._fbos[e].dispose()}for(const e of this._fboPool)e.dispose();if(this._fboPool.length=0,this.effects){let e;for(e in this.effects)this.effects[e]&&this.effects[e].dispose()}this._effectsManager.dispose(),this._blendEffect.dispose(this.context),this._vtlMaterialManager=t.disposeMaybe(this._vtlMaterialManager)}clearShaderCache(){this._programCache.destroy(),this._programCache=new E.TechniqueProgramCache}get blitRenderer(){return this._blitRenderer}get vectorTilesMaterialManager(){return this._vtlMaterialManager}get quadMesh(){return this._quadMesh}getFbos(){if(!this._fbos)throw new Error("InternalError: Painter FBOs not initialized");return this._fbos}acquireFbo(e,t){let r;if(this._fboPool.length>0)r=this._fboPool.pop();else{const s=new F.TextureDescriptor(e,t);s.samplingMode=g.TextureSamplingMode.NEAREST,s.wrapMode=g.TextureWrapMode.CLAMP_TO_EDGE,r=new M.FramebufferObject(this.context,s,this._stencilBuf)}return r.width===e&&r.height===t||r.resize(e,t),r}releaseFbo(e){this._fboPool.push(e)}getSharedStencilBuffer(){return this._stencilBuf}beforeRenderPhases(e,t,r){const{context:s}=e;this._worldExtentRenderer.render(e,t,r);const{width:i,height:n}=s.getViewport();if(this.updateFBOs(i,n),this._prevFBO=s.getBoundFramebufferObject(),s.bindFramebuffer(this.getFbos().output),s.setColorMask(!0,!0,!0,!0),null!=t){const{r:e,g:r,b:i,a:n}=t;s.setClearColor(n*e/255,n*r/255,n*i/255,n)}else s.setClearColor(0,0,0,0);s.setDepthWriteEnabled(!0),s.setClearDepth(1),s.clear(g.FramebufferBit.COLOR|g.FramebufferBit.DEPTH),s.setDepthWriteEnabled(!1)}afterRenderPhases(e){const{context:t}=e;t.bindFramebuffer(this._prevFBO),t.setStencilFunction(g.CompareFunction.EQUAL,n.backbufferStencilVisible,255),t.setStencilTestEnabled(!0),t.setDepthTestEnabled(!1),this.blitTexture(t,this.getFbos().output.colorTexture,g.TextureSamplingMode.NEAREST)}beforeRenderLayer(e,t,r){const{context:s,blendMode:i,effects:n,drawPhase:a,requireFBO:o}=e;if(s.setClearColor(0,0,0,0),o||w(a,i,n,r)){const e=s.getBoundFramebufferObject();this._prevBeforeLayerFBOStack.push(e);const{width:t,height:r}=s.getViewport(),i=this.acquireFbo(t,r);s.bindFramebuffer(i),s.setColorMask(!0,!0,!0,!0),s.setClearColor(0,0,0,0),s.setDepthWriteEnabled(!0),s.setClearDepth(1),s.clear(g.FramebufferBit.COLOR|g.FramebufferBit.DEPTH),s.setDepthWriteEnabled(!1)}s.setDepthWriteEnabled(!1),s.setDepthTestEnabled(!1),s.setStencilTestEnabled(!0),s.setClearStencil(t),s.setStencilWriteMask(255),s.clear(g.FramebufferBit.STENCIL)}afterRenderLayer(e,t){const{context:r,blendMode:s,effects:i,requireFBO:n,drawPhase:o}=e;if(n||w(o,s,i,t)){const n=r.getBoundFramebufferObject();null!=i&&i.length>0&&o===a.WGLDrawPhase.MAP&&(r.setColorMask(!0,!0,!0,!0),this._applyEffects(e,i,n)),r.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()),r.setStencilTestEnabled(!1),r.setStencilWriteMask(0),r.setBlendingEnabled(!0),r.setBlendFunctionSeparate(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA,g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA),r.setColorMask(!0,!0,!0,!0);const l=null==s||o===a.WGLDrawPhase.HIGHLIGHT||o===a.WGLDrawPhase.LABEL?"normal":s;this._blendEffect.draw(e,n.colorTexture,g.TextureSamplingMode.NEAREST,l,t),this.releaseFbo(n)}}renderObject(e,t,s,i){const n=r.brushes[s];if(!n)return;let a=this._brushCache.get(n);void 0===a&&(a=new n,this._brushCache.set(n,a)),a.prepareState(e),a.draw(e,t,i)}renderObjects(e,t,s,i){const n=r.brushes[s];if(!n)return;let a=this._brushCache.get(n);void 0===a&&(a=new n,this._brushCache.set(n,a)),a.drawMany(e,t,i)}registerRenderPass(e){const t=e.brushes.map((e=>(this._brushCache.has(e)||this._brushCache.set(e,new e),this._brushCache.get(e))));return new S(t,e)}blitTexture(e,t,r,s=1){e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA,g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA),e.setColorMask(!0,!0,!0,!0),this._blitRenderer.render(e,t,r,s),this._currentPipelineStateNeedsUpdate=!0}getPostProcessingEffects(e){return this._effectsManager.getPostProcessingEffects(e)}updateFBOs(e,t){if(e!==this._lastWidth||t!==this._lastHeight){if(this._lastWidth=e,this._lastHeight=t,this._fbos){let r;for(r in this._fbos)this._fbos[r].resize(e,t);return}const r=new F.TextureDescriptor(e,t);r.samplingMode=g.TextureSamplingMode.NEAREST,r.wrapMode=g.TextureWrapMode.CLAMP_TO_EDGE;const s=new m.RenderbufferDescriptor(g.SizedDepthStencilFormat.DEPTH24_STENCIL8,e,t);this._stencilBuf=new B.Renderbuffer(this.context,s),this._fbos={output:new M.FramebufferObject(this.context,r,this._stencilBuf),effect0:new M.FramebufferObject(this.context,r,this._stencilBuf)}}}_applyEffects(e,t,r){const{context:s}=e,i=this._effectsManager.getPostProcessingEffects(t);for(const{postProcessingEffect:t,effect:n}of i)s.bindFramebuffer(r),t.draw(e,r,n);this._currentPipelineStateNeedsUpdate=!0}setShader(e){this._shaderState.shader=e.shader,this._shaderState.uniforms=e.uniforms,this._shaderState.defines=e.defines,this._shaderState.optionalAttributes=e.optionalAttributes,this._shaderState.useComputeBuffer=e.useComputeBuffer??!1}setPipelineState(e){e!==this._currentPipelineState&&(this._currentPipelineState=e,this._currentPipelineStateNeedsUpdate=!0)}submitDraw(e,t){const{shader:r,uniforms:s,defines:i,optionalAttributes:n}=this._shaderState,a=e.context,o=t.getAttributePrecisionPackFactors(),l=this._programCache.getProgram(r,o,s,i??{},n??{});return l.setUniforms(s),l.bind(a),this.updatePipelineState(a),this.setStencilRef(a,t),t.draw(e,r.locationInfo),l.cleanupTemporaryTextures(),{vertexShader:l.vertexShader,fragmentShader:l.fragmentShader}}submitDrawMesh(e,t,r,s){this.submitDrawMeshUntyped(e,t,r,s)}submitDrawMeshUntyped(e,t,r,s){this.setShader(t);const{shader:i,uniforms:n,defines:a,optionalAttributes:o}=this._shaderState,l=this._programCache.getProgram(i,{},n,a??{},o??{});if(l.setUniforms(n),l.bind(e),this.updatePipelineState(e),s)for(const i of s)r.bind(e,t.shader.locationInfo,i),r.draw(e);else for(let s=0;s<r.parts.length;s++)r.bind(e,t.shader.locationInfo,s),r.draw(e);r.unbind(e),l.cleanupTemporaryTextures()}updatePipelineState(e){this._currentPipelineStateNeedsUpdate&&(this._currentPipelineStateNeedsUpdate=!1,this._updatePipelineState(e))}_updatePipelineState(e){if(null==this._currentPipelineState)throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");const{color:t,depth:r,stencil:s}=this._currentPipelineState;if(t){const{blendMode:r,write:s}=t;switch(e.setColorMask(...s),e.setBlendingEnabled(!0),e.setBlendEquation(g.BlendOperation.ADD),r){case"composite":e.setBlendFunctionSeparate(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA,g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA);break;case"additive":e.setBlendFunctionSeparate(g.BlendFactor.ONE,g.BlendFactor.ONE,g.BlendFactor.ONE,g.BlendFactor.ONE);break;case"custom":{const{blendParameters:r}=t,{dstAlpha:s,dstRGB:i,srcAlpha:n,srcRGB:a}=r;e.setBlendFunctionSeparate(a,i,n,s);break}case"delete":e.setBlendEquation(g.BlendOperation.REVERSE_SUBTRACT),e.setBlendFunctionSeparate(g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA,g.BlendFactor.ONE,g.BlendFactor.ONE_MINUS_SRC_ALPHA)}}else e.setColorMask(!1,!1,!1,!1);if(r){const{test:t,write:s}=r;s?(e.setDepthWriteEnabled(!0),e.setDepthRange(s.zNear,s.zFar)):e.setDepthWriteEnabled(!1),t?(e.setDepthTestEnabled(!0),e.setDepthFunction(t)):e.setDepthTestEnabled(!1)}else e.setDepthTestEnabled(!1),e.setDepthWriteEnabled(!1);if(s){const{test:t,write:r}=s;if(t){const{compare:r,mask:s,op:i,ref:n}=t;e.setStencilTestEnabled(!0),"function"!=typeof n&&e.setStencilFunctionSeparate(g.Face.FRONT_AND_BACK,r,n,s),e.setStencilOpSeparate(g.Face.FRONT_AND_BACK,i.fail,i.zFail,i.zPass)}else e.setStencilTestEnabled(!1);if(r){const{mask:t}=r;e.setStencilWriteMask(t)}else e.setStencilWriteMask(0)}else e.setStencilTestEnabled(!1),e.setStencilWriteMask(0)}setStencilRef(e,t){if(null==this._currentPipelineState)throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");const{stencil:r}=this._currentPipelineState;if(r){const{test:s}=r;if(s){const{compare:r,mask:i,ref:n}=s;let a=null;if("function"==typeof n?a=n(t):"number"==typeof n&&(a=n),null==a&&(a=t.getStencilReference()),null==a)throw new Error("InternalError: Stencil reference expected for target but not defined");e.setStencilFunctionSeparate(g.Face.FRONT_AND_BACK,r,a,i)}}}}}));