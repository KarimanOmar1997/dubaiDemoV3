// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/has","../../../../../core/maybe","../number","../PooledUint32Array","./FreeList","../../../../webgl/BufferObject","../../../../webgl/enums"],(function(t,i,e,r,s,n,h,a){"use strict";t.MappedBuffer=class{constructor(t,i,e,r){this._pool=r;const n=s.PooledUint32Array.create(i*e*Uint32Array.BYTES_PER_ELEMENT,this._pool);this.size=i,this.strideInt=e,this.bufferType=t,this.dirty={start:1/0,end:0},this.memoryStats={bytesUsed:0,bytesReserved:i*e*Uint32Array.BYTES_PER_ELEMENT},this._gpu=null,this._cpu=n,this.clear()}get elementSize(){return this._cpu.length/this.strideInt}get intSize(){return this.fillPointer*this.strideInt}get byteSize(){return this.intSize*Uint32Array.BYTES_PER_ELEMENT}get invalidated(){return this.bufferSize>0&&!this._gpu}get invalidatedComputeBuffer(){return this.bufferSize>0&&!this._gpuComputeTriangles}invalidate(){this._invalidateTriangleBuffer(),this._gpu?.dispose(),this._gpu=null}_invalidateTriangleBuffer(){this._gpuComputeTriangles?.dispose(),this._gpuComputeTriangles=null}destroy(){this._gpu?.dispose(),this._gpuComputeTriangles?.dispose(),this._cpu?.destroy()}clear(){this.dirty.start=1/0,this.dirty.end=0,this.freeList=new n.FreeList({start:0,end:this._cpu.length/this.strideInt}),this.fillPointer=0}ensure(t){if(!(this.maxAvailableSpace()>=t)&&t*this.strideInt>this._cpu.length-this.fillPointer){this.invalidate();const i=this._cpu.length/this.strideInt,e=Math.round(1.25*(i+t)),r=e*this.strideInt;this._cpu.expand(r*Uint32Array.BYTES_PER_ELEMENT),this.freeList.free(i,e-i),this.memoryStats.bytesReserved+=(e-i)*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}}setU32(t,i){this._cpu.array[t]!==i&&(this._cpu.array[t]=i,this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(t+1,this.dirty.end))}setF32(t,i){this.setU32(t,r.toUint32(i))}setF32Range(t,i,e){const s=r.toUint32(e);this._cpu.array.fill(s,t,i),this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(i,this.dirty.end)}getF32(t){return r.toFloat32(this._cpu.array[t])}getGPUBuffer(t,i=!1){if(!this.bufferSize)return null;if(i){if("index"!==this.bufferType)throw new Error("Tired to get triangle buffer, but target is not an index buffer");return null==this._gpuComputeTriangles&&(this._gpuComputeTriangles=this._createComputeBuffer(t)),this._gpuComputeTriangles}return null==this._gpu&&(this._gpu=this._createBuffer(t)),this._gpu}getView(t,i){return this._cpu.getUint32View(t,i/Uint32Array.BYTES_PER_ELEMENT)}get bufferSize(){return this._cpu.length/this.strideInt}maxAvailableSpace(){return this.freeList.maxAvailableSpace()}insert(t,i,r,s){const n=r*this.strideInt;if(!n)return 0;const h=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,a=new Uint32Array(t,h,n),d=this.freeList.firstFit(r);e.assertIsSome(d,"First fit region must be defined");const u=d*this.strideInt,o=n;if(this._cpu.array.set(a,u),0!==s)for(let t=0;t<a.length;t++)this._cpu.array[t+u]+=s;return this.dirty.start=Math.min(this.dirty.start,u),this.dirty.end=Math.max(this.dirty.end,u+o),this.fillPointer=Math.max(this.fillPointer,u+o),this.memoryStats.bytesUsed+=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d}copyFrom(t,i,r,s,n){const h=r*this.strideInt;if(!h)return 0;const a=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d=t._cpu.getUint32View(a,h),u=this.freeList.firstFit(r);e.assertIsSome(u,"First fit region must be defined");const o=u*this.strideInt,f=h;if(this._cpu.array.set(d,o),0!==s)for(let t=0;t<h;t++)this._cpu.array[o+t*this.strideInt+n]+=s;return this.dirty.start=Math.min(this.dirty.start,o),this.dirty.end=Math.max(this.dirty.end,o+f),this.fillPointer=Math.max(this.fillPointer,o+f),this.memoryStats.bytesUsed+=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,u}free(t,i,e){const r=t*this.strideInt,s=(t+i)*this.strideInt;if(!0===e)for(let e=t;e!==t+i;e++)this._cpu.array[e*this.strideInt]=2147450879;this.dirty.start=Math.min(this.dirty.start,r),this.dirty.end=Math.max(this.dirty.end,s),this.freeList.free(t,i),this.memoryStats.bytesUsed-=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}upload(){if(this.dirty.end){if(this._invalidateTriangleBuffer(),null==this._gpu)return this.dirty.start=1/0,void(this.dirty.end=0);this._gpu.setSubData(this._cpu.array,this.dirty.start,this.dirty.start,this.dirty.end),this.dirty.start=1/0,this.dirty.end=0}}reshuffle(t,i){if(0===i.length)return;const e=this.byteSize,r=t*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,n=e>r,h=this._cpu,a=s.PooledUint32Array.create(r,this._pool);n||a.array.set(this._cpu.getUint32View(0,this.intSize));for(const t of i)if(n||t.srcFrom!==t.dstFrom||0!==t.mutate){this.dirty.start=Math.min(this.dirty.start,t.dstFrom*this.strideInt),this.dirty.end=Math.max(this.dirty.end,(t.dstFrom+t.count)*this.strideInt);for(let i=0;i<t.count;i++){const e=(t.dstFrom+i)*this.strideInt,r=(t.srcFrom+i)*this.strideInt;for(let i=0;i<this.strideInt;i++)a.array[e+i]=h.array[r+i]+t.mutate}}this._cpu.destroy(),this._cpu=a,n&&this.invalidate(),this.freeList.clear(),this.memoryStats.bytesUsed=this.memoryStats.bytesReserved=r}_createBuffer(t){const i=a.Usage.DYNAMIC_DRAW;return"index"===this.bufferType?h.BufferObject.createIndex(t,i,this._cpu.array):h.BufferObject.createVertex(t,i,this._cpu.array)}_createComputeBuffer(t){const i=a.Usage.DYNAMIC_DRAW,e=new Uint32Array(this.fillPointer/3);for(let t=0;t<this.fillPointer;t+=3)e[t/3]=this._cpu.array[t];return h.BufferObject.createIndex(t,i,e)}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));