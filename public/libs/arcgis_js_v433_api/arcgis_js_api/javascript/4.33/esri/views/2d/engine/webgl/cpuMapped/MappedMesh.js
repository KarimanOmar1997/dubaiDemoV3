// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/has","../../../../../core/maybe","../number","./Buffer","../shaderGraph/techniques/mesh/dataViewUtils","../shaderGraph/techniques/mesh/utils","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,i,r,s,f,o,n,u){"use strict";const a=1e3,h=[{name:"visibility",offset:0,type:n.DataType.FLOAT,count:1}],l={hash:o.vertexLayoutHash(h),attributes:h,stride:4};function d(e,t){const i=e.attributes.filter((e=>t.locations.has(e.name))).map((t=>({name:t.name,type:t.type,count:t.count,divisor:0,normalized:t.normalized??!1,offset:t.offset,stride:e.stride})));return new Map([["geometry",i]])}e.MappedMesh=class{constructor(e,t,i){if(this._bufferPool=e,this._layout=t,this.useVisibility=i,this._invalidatedGeometry=!1,this._invalidatedCompute=!1,this._position=this._layout.attributes.find((e=>"pos"===e.name||"position"===e.name)),!this._position)throw new Error("InternalError: Unable to find position attribute")}destroy(){this._indexBuffer=i.destroyMaybe(this._indexBuffer),this._vertexBuffer=i.destroyMaybe(this._vertexBuffer),this._visibilityBuffer=i.destroyMaybe(this._visibilityBuffer),this._computeVAO?.disposeVAOOnly(),this._geometryVAO?.disposeVAOOnly()}get layout(){return this._layout}getDrawArgs(e,t,i,r){return r?{primitive:n.PrimitiveType.POINTS,count:t/3,offset:i/3}:{primitive:e,count:t,offset:i}}getAttributePrecisionPackFactors(){const e={};for(const t of this.layout.attributes)t.packPrecisionFactor&&(e[t.name]=t.packPrecisionFactor);return e}getDebugVertexInfo(e=!1,t){if(!this._vertexBuffer)return null;const i=this._layout,r=i.stride,s=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize),o=[];if(e)if(null==t)console.log("must provide location info to see compute attributes");else for(const e of i.attributes){const i=t.computeAttributeMap[e.name];null!=i&&2===i.length&&(o.push({...e,name:i[0],offset:e.offset+r}),o.push({...e,name:i[1],offset:e.offset+2*r}))}const n=new DataView(s.slice().buffer);let u=s.byteLength/r;e&&(u=this._indexBuffer.fillPointer/3);const a=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let h=0;const l=[];for(let t=0;t<u;t++){e&&(h=a[3*t]*r);const s={};for(const e of[...i.attributes,...o]){let t=`${e.offset} ${e.name}`,i=f.unpackDataView(n,e,h);if(e.packPrecisionFactor)if(t+=` (precision: ${e.packPrecisionFactor})`,"number"==typeof i)i/=e.packPrecisionFactor;else for(let t=0;t<i.length;t++)i[t]/=e.packPrecisionFactor;s[t]=i}h+=r,l.push(s)}return{vertices:l,layout:i}}_ensure(e,t){if(this._vertexBuffer&&this._indexBuffer)this._indexBuffer.ensure(Math.max(e,a)),this._vertexBuffer.ensure(Math.max(t,a)),this._visibilityBuffer&&this._visibilityBuffer.ensure(Math.max(t,a));else{const i=this._layout.stride/Uint32Array.BYTES_PER_ELEMENT;this._indexBuffer=new s.MappedBuffer("index",Math.max(e,a),1,this._bufferPool),this._vertexBuffer=new s.MappedBuffer("vertex",Math.max(t,a),i,this._bufferPool),this.useVisibility&&(this._visibilityBuffer=new s.MappedBuffer("vertex",Math.max(t,a),4/Uint32Array.BYTES_PER_ELEMENT,this._bufferPool))}}append(e){const t=e.layout.stride,i=e.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,r=e.vertices.byteLength/t;this._ensure(i,r);const{vertices:s,indices:f}=e,o=this._vertexBuffer.insert(s,0,s.byteLength/t,0),n=new Uint32Array(r);return new Float32Array(n.buffer).fill(255),this._visibilityBuffer&&this._visibilityBuffer.insert(n,0,n.byteLength/4,0),{vertexFrom:o,indexFrom:this._indexBuffer.insert(f,0,f.byteLength/4,o)}}setEntityRecordRangeVisibility(e,t,i,r){if(!(t+i>e.length))for(let s=t;s<t+i;s++){const{vertexStart:t,vertexCount:i}=e[s];this._visibilityBuffer.setF32Range(t,t+i,r)}}getEntityRecordVisibility(e,t){const i=e.records[t];return this._visibilityBuffer.getF32(i.vertexStart)}copyRecordFrom(e,t,i,s){const{indexStart:f,indexCount:o,vertexStart:n,vertexCount:u}=t;this._ensure(o,u);const a=e._position,h=i*(a.packPrecisionFactor??1),l=s*(a.packPrecisionFactor??1),d=a.offset,y=r.i1616to32(h,l),_=this._vertexBuffer.copyFrom(e._vertexBuffer,n,u,y,d);this._visibilityBuffer&&e._visibilityBuffer&&this._visibilityBuffer.copyFrom(e._visibilityBuffer,n,u,0,0);const c=this._indexBuffer.copyFrom(e._indexBuffer,f,o,_-n,0),v=t.clone();return v.vertexStart=_,v.indexStart=c,v.overlaps=0,v}remove(e,t,i,r){this._indexBuffer.free(e,t),this._vertexBuffer.free(i,r),this._visibilityBuffer&&this._visibilityBuffer.free(i,r)}upload(){this._invalidatedGeometry=!0,this._invalidatedCompute=!0}getGeometryVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedGeometry){(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||this._visibilityBuffer?.invalidated)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer&&this._visibilityBuffer.invalidate(),this._geometryVAO?.disposeVAOOnly(),this._geometryVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer&&this._visibilityBuffer.upload();const i=this._indexBuffer.getGPUBuffer(e,!1),r=new Map([["geometry",this._vertexBuffer.getGPUBuffer(e)]]);if(this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getGPUBuffer(e)),!this._geometryVAO){const s=d(this.layout,t);s.set("visibility",d(l,t).get("geometry")),this._geometryVAO=new u.VertexArrayObject(e,t.locations,s,r,i)}this._invalidatedGeometry=!1}return this._geometryVAO}getComputeVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedCompute){(this._vertexBuffer.invalidated||this._indexBuffer.invalidatedComputeBuffer)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer&&this._visibilityBuffer.invalidate(),this._computeVAO?.disposeVAOOnly(),this._computeVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer&&this._visibilityBuffer.upload();const i=this._indexBuffer.getGPUBuffer(e,!0),r=new Map([["geometry",this._vertexBuffer.getGPUBuffer(e)]]);if(this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getGPUBuffer(e)),!this._computeVAO){const s=function(e,t){const i=[],r=e.attributes.filter((e=>t.locations.has(e.name)));for(const s of r){i.push({name:s.name,type:s.type,count:s.count,divisor:0,normalized:s.normalized??!1,offset:s.offset,stride:e.stride});const r=t.computeAttributeMap[s.name];null!=r&&2===r.length&&(i.push({name:r[0],count:s.count,divisor:0,type:s.type,normalized:s.normalized??!1,offset:s.offset+e.stride,stride:e.stride}),i.push({name:r[1],count:s.count,divisor:0,type:s.type,normalized:s.normalized??!1,offset:s.offset+2*e.stride,stride:e.stride}))}return new Map([["geometry",i]])}(this.layout,t);s.set("visibility",d(l,t).get("geometry")),this._computeVAO=new u.VertexArrayObject(e,t.locations,s,r,i),this._invalidatedCompute=!1}}return this._computeVAO}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(e){this._vertexBuffer&&this._vertexBuffer.reshuffle(e.vertex.count,e.vertex.operations),this._indexBuffer&&this._indexBuffer.reshuffle(e.index.count,e.index.operations),this._visibilityBuffer&&this._visibilityBuffer.reshuffle(e.vertex.count,e.vertex.operations)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));