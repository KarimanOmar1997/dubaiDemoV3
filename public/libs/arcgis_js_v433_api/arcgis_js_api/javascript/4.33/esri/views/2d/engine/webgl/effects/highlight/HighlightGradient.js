// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../../../core/Logger","../../definitions","./parameters","../../../../../support/HighlightOptions","../../../../../webgl/enums","../../../../../webgl/Texture","../../../../../webgl/TextureDescriptor"],(function(o,i,t,e,l,h,r){"use strict";const n=()=>o.getLogger("esri.views.2d.engine.webgl.painter.highlight.HighlightGradient"),s=[0,0,0,0];return class{constructor(){this.type="single",this._highlightOptions=new e,this._convertedHighlightOptions={fillColor:[0,0,0,0],outlineColor:[0,0,0,0],outlinePosition:0,outlineWidth:0,innerHaloWidth:0,outerHaloWidth:0},this._optionsShadeTexKey="",this._texelData=new Uint8Array(4*t.shadeTextureSize),this._minMaxDistance=[0,0]}setHighlightOptions(o){this._highlightOptions=o}applyHighlightOptions(o,t){this._updateGradientTexture(o),o.bindTexture(this._shadeTex,i.textureBindingHighlight1),t.setUniform2fv("u_minMaxDistance",this._minMaxDistance)}destroy(){this._shadeTex?.dispose(),this._shadeTex=null}getReasonsWithGradients(){return[{activeReasons:(1<<i.maxHighlightReasons)-1,activeGradient:this}]}_updateGradientTexture(o){const i=`${(e=this._highlightOptions).color};${e.haloColor};${e.haloOpacity};${e.fillOpacity};${e.haloWidth};${e.haloBlur}`;var e;if(i===this._optionsShadeTexKey)return;this._optionsShadeTexKey=i,function(o,i){i.fillColor[0]=o.color.r/255,i.fillColor[1]=o.color.g/255,i.fillColor[2]=o.color.b/255,i.fillColor[3]=o.color.a,o.haloColor?(i.outlineColor[0]=o.haloColor.r/255,i.outlineColor[1]=o.haloColor.g/255,i.outlineColor[2]=o.haloColor.b/255,i.outlineColor[3]=o.haloColor.a):(i.outlineColor[0]=i.fillColor[0],i.outlineColor[1]=i.fillColor[1],i.outlineColor[2]=i.fillColor[2],i.outlineColor[3]=i.fillColor[3]),i.fillColor[3]*=o.fillOpacity,i.outlineColor[3]*=o.haloOpacity,i.fillColor[0]*=i.fillColor[3],i.fillColor[1]*=i.fillColor[3],i.fillColor[2]*=i.fillColor[3],i.outlineColor[0]*=i.outlineColor[3],i.outlineColor[1]*=i.outlineColor[3],i.outlineColor[2]*=i.outlineColor[3],i.outlineWidth=(1-o.haloBlur)*o.haloWidth,i.outerHaloWidth=o.haloBlur*o.haloWidth/2,i.innerHaloWidth=o.haloBlur*o.haloWidth/2,i.outlinePosition=0}(this._highlightOptions,this._convertedHighlightOptions);const a=this._convertedHighlightOptions,u=a.outlinePosition-a.outlineWidth/2-a.outerHaloWidth,d=a.outlinePosition-a.outlineWidth/2,g=a.outlinePosition+a.outlineWidth/2,C=a.outlinePosition+a.outlineWidth/2+a.innerHaloWidth,f=Math.sqrt(Math.PI/2)*t.sigma,c=Math.abs(u)>f?Math.round(10*(Math.abs(u)-f))/10:0,p=Math.abs(C)>f?Math.round(10*(Math.abs(C)-f))/10:0;let x;c&&!p?n().error("The outer rim of the highlight is "+c+"px away from the edge of the feature; consider reducing some width values or shifting the outline position towards positive values (inwards)."):!c&&p?n().error("The inner rim of the highlight is "+p+"px away from the edge of the feature; consider reducing some width values or shifting the outline position towards negative values (outwards)."):c&&p&&n().error("The highlight is "+Math.max(c,p)+"px away from the edge of the feature; consider reducing some width values.");const _=[void 0,void 0,void 0,void 0];function T(o,i,t){_[0]=(1-t)*o[0]+t*i[0],_[1]=(1-t)*o[1]+t*i[1],_[2]=(1-t)*o[2]+t*i[2],_[3]=(1-t)*o[3]+t*i[3]}const{_texelData:w}=this;for(let o=0;o<t.shadeTextureSize;++o)x=u+o/(t.shadeTextureSize-1)*(C-u),x<u?(_[0]=0,_[1]=0,_[2]=0,_[3]=0):x<d?T(s,a.outlineColor,(x-u)/(d-u)):x<g?[_[0],_[1],_[2],_[3]]=a.outlineColor:x<C?T(a.outlineColor,a.fillColor,(x-g)/(C-g)):[_[0],_[1],_[2],_[3]]=a.fillColor,w[4*o]=255*_[0],w[4*o+1]=255*_[1],w[4*o+2]=255*_[2],w[4*o+3]=255*_[3];if(this._minMaxDistance[0]=u,this._minMaxDistance[1]=C,!this._shadeTex){const i=new r.TextureDescriptor;i.wrapMode=l.TextureWrapMode.CLAMP_TO_EDGE,i.width=t.shadeTextureSize,i.height=1,this._shadeTex=new h.Texture(o,i)}this._shadeTex.updateData(0,0,0,t.shadeTextureSize,1,this._texelData)}}}));