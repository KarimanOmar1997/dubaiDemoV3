// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/has","../../../../../core/Logger","../../../../../core/string","./graph/glsl","./graph/GlslGraphWriter","./graph/ShaderGraphContext","./graph/ShaderGraphNode","./typed/TypedShaderProgram","../../../../webgl/ShaderBuilder"],(function(e,t,r,o,n,i,s,p,a,u,c){"use strict";function d(e){return new e}function y(e,t,r){const o=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:o.slice()}),e.constructor[t].push(r)}const h=e=>(t,r)=>{y(t,"builtins",{builtin:e,propertyKey:r})},f=(e,t)=>(r,o)=>{r.constructor.builtins.push({builtin:e,propertyKey:o,typeCtor:t})};class l{static{this.builtins=[]}}t.__decorate([f("gl_VertexID",i.Int)],l.prototype,"glVertexID",void 0);class m{static{this.builtins=[]}}t.__decorate([f("gl_FragCoord",i.Vec4)],m.prototype,"glFragCoord",void 0),t.__decorate([f("gl_PointCoord",i.Vec2)],m.prototype,"glPointCoord",void 0);class g{}t.__decorate([h("gl_FragDepth")],g.prototype,"glFragDepth",void 0),e.ComputeVertexInput=class{},e.FragmentInput=m,e.FragmentOutput=g,e.GraphShaderModule=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&0===e.parameterIndex));if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&1===e.parameterIndex))}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"fragment"===e.propertyKey));if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const r of this.locations)t.has(r.index)?o.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:e}):(e.set(r.propertyKey,r.index),t.add(r.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map((([e,t])=>`${e}.${t}`)).join("."),r=n.numericHash(t),o=this.computeAttributes;this._locationInfo={hash:r,stringHash:t,locations:e,computeAttributeMap:o}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,o){try{const{vertex:n,fragment:i,uniformBindings:s}=this._generateShaders(e,t,r,o);return new u.TypedShaderProgram(n,i,this.renamedLocationsMap,this.locationInfo,s,this.transformFeedbackBindings)}catch(e){return new u.TypedShaderProgram("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find((t=>t.propertyKey===e));if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find((t=>t.propertyKey===e));if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,o){const n=Object.keys(e).map((t=>`${t}.${e[t]}`)).join("."),i=Object.keys(r).map((e=>`${e}.${r[e]}`)).join("."),s=Object.keys(o).map((e=>`${e}.${o[e]}`)).join("."),p=Object.keys(t).filter((e=>this.optionPropertyKeys.has(e)&&t[e])).join(".");return`${this.type}.${n}.${i}.${s}.${p}`}_generateShaders(e,t,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,t),this._setRequiredUniforms(n);const i=this._hydrateVertexInput(o),u=this._injectPackPrecisionFactor(i,e),c=this._hydrateComputeInput(),d=c&&this._injectComputePackPrecisionFactor(c,e),y=this.vertex(u,d),h=this._hydrateFragmentInput(y),f=this.fragment(h),l=new Set;for(const e in f){const t=f[e];a.setReachableUids(l,t)}const m=this._getVertexInputBuiltins(),g=p.ShaderGraphContext.createVertex({...i,...c},y,m,n,this.transformFeedbackBindings,l);(new s.GlslShaderWriter).write(g);const _=this._getFragmentInputBuiltins(f);_.set("glPointCoord","gl_PointCoord");const b=p.ShaderGraphContext.createFragment(h,f,_,n,g,this.transformFeedbackBindings);(new s.GlslShaderWriter).write(b);const x=this._createShaderBuilder(g,b),C=x.generate("vertex"),I=x.generate("fragment");return this.logShader&&(console.log(C),console.log(I)),{vertex:C,fragment:I,uniformBindings:n}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options)t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new(0,t.typeCtor);for(const o of r._uniforms??[]){const n=d(o.typeCtor),i=`u_${t.propertyKey}_${o.propertyKey}`,s=n.type,p=[t.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const t=n;e.push({shaderModulePath:p,uniformName:i,uniformType:s,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:n})}else if("type"in o.typeCtor&&"array-2d"===o.typeCtor.type){const t=n;e.push({shaderModulePath:p,uniformName:i,uniformType:s,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:n})}else e.push({shaderModulePath:p,uniformName:i,uniformType:s,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce(((t,r)=>!1===e[r.propertyKey]?t:{...t,[r.propertyKey]:d(r.typeCtor)}),{});for(const{propertyKey:e,typeCtor:o}of t.builtins){const t=d(o);r[e]=t}return r}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce(((e,t)=>({...e,[t.propertyKey]:d(t.typeCtor)})),{})}_injectPackPrecisionFactor(e,t){const r={};for(const o in e){const n=e[o],s=t[o];if(s){if("float"!==n.type&&"vec2"!==n.type&&"vec3"!==n.type&&"vec4"!==n.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${n.type}`);r[o]=n.divide(new i.Float(s))}else r[o]=n}return r}_injectComputePackPrecisionFactor(e,t){const r={},o=new Map;for(const e in this.computeAttributes)for(const t of this.computeAttributes[e]??[])o.set(t,e);for(const n in e){const s=e[n],p=o.get(n);if(!p)continue;const a=t[p];if(a){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[n]=s.divide(new i.Float(a))}else r[n]=s}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:e,typeCtor:r}of m.builtins){const o=d(r);t[e]=o}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:o}of e.builtins)t.set(o,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const e of t.builtins??[])r.set(e.propertyKey,e.builtin);return r}_createShaderBuilder(e,t){const r=new c.ShaderBuilder;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}},e.UniformGroup=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},e.VertexInput=l,e.builtin=h,e.define=(e,t)=>{y(e,"defines",{propertyKey:t})},e.input=e=>(t,r,o)=>{y(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:o})},e.location=function(e,t){return(r,o)=>{y(r,"locations",{typeCtor:t,propertyKey:o,parameterIndex:null,index:e})}},e.option=e=>(t,r)=>{y(t,"options",{typeCtor:e,propertyKey:r})},e.transformFeedback=function(e){return(t,r)=>{y(t,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:e})}},e.uniform=e=>(t,r)=>{y(t,"uniforms",{typeCtor:e,propertyKey:r})},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));