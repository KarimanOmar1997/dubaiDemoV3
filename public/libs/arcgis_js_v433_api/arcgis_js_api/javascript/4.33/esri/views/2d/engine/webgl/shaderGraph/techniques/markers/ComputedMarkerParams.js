// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../../core/screenUtils","../../../../../../../symbols/cim/enums","../../../../../../../symbols/cim/utils","../../../definitions"],(function(t,e,i,o,s){"use strict";class h{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const i=new h(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:o,width:s,height:r,angle:n,alignment:a,outlineSize:c,referenceSize:f,sprite:l,overrideOutlineColor:m}=t;return i.rawWidth=e.pt2px(s),i.rawHeight=e.pt2px(r),i.angle=n,i.alignment=a,i.outlineSize=e.pt2px(c),i.referenceSize=e.pt2px(f),i.overrideOutlineColor=m,i.offsetX=e.pt2px(t.offsetX),i.offsetY=e.pt2px(t.offsetY),"simple"!==o||l.sdf||(i.rawWidth=l.width,i.rawHeight=l.height),i._computeSize(t,!1),i}static fromComplexMeshParams(t){const i=new h(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:s,transforms:r,size:n,scaleX:a,anchorX:c,anchorY:f,angle:l,colorLocked:m,frameHeight:d,widthRatio:p,offsetX:u,offsetY:g,outlineSize:x,referenceSize:w,scaleFactor:S,sizeRatio:z,isAbsoluteAnchorPoint:X,rotateClockwise:P,scaleSymbolsProportionally:Y,sprite:C}=t;if(r&&r.infos.length>0){const t=o.applyParentTransform(n,l,P,u,g,r);n=t.size,l=t.rotation,u=t.offsetX,g=t.offsetY,P=!1}S&&(n*=S,u*=S,g*=S);const H=a*(C.width/C.height);i.alignment=s,i.rawHeight=e.pt2px(n),i.rawWidth=i.rawHeight*H,i.referenceSize=e.pt2px(w),i.sizeRatio=z,i.sdfDecodeCoeff=(C.sdfDecodeCoeff??1)*z,i.angle=l,i.rotateClockwise=P,i.anchorX=c,i.anchorY=f,i.offsetX=e.pt2px(u),i.offsetY=e.pt2px(g),X&&n&&(C.sdf?i.anchorX=c/(n*p):i.anchorX=c/(n*H),i.anchorY=f/n);const M=Y&&d?n/d:1;return i.outlineSize=0===x||isNaN(x)?0:e.pt2px(x)*M,i.scaleSymbolsProportionally=Y,i.colorLocked=m,i._computeSize(t,!0),i}constructor(t,e,o,s,h,r,n){this.sprite=t,this.color=e,this.outlineColor=o,this.minPixelBuffer=s,this.placement=h,this.scaleInfo=r,this.effects=n,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=i.Alignment.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:i,hasSizeVV:o}=t,h=!!i.sdf,a=i.sdfPaddingRatio??.5,{rawWidth:c,rawHeight:f,sizeRatio:l,outlineSize:m}=this,d=i.rect;let p=c*l,u=f*l,g=0,x=0;if(h){const t=1/(1-a);if(p*=t,u*=t,o)this.computedWidth=p,this.computedHeight=u;else{const t=e&&c>f?p:c,o=f,s=m+2;this.computedWidth=Math.min(t+s,p),this.computedHeight=Math.min(o+s,u);const h=Math.max(i.width,i.height)/Math.max(p,u);g=(this.computedWidth-p)*h,x=(this.computedHeight-u)*h}}else this.computedWidth=p*(d.width/i.width),this.computedHeight=u*(d.height/i.height),g=2*s.spritePadding,x=2*s.spritePadding;const w=d.x+s.spritePadding-g/2,S=d.y+s.spritePadding-x/2,z=w+i.width+g,X=S+i.height+x;this.texXmin=r(w),this.texYmin=r(S),this.texXmax=n(z),this.texYmax=n(X),this.computedWidth*=(this.texXmax-this.texXmin)/(z-w),this.computedHeight*=(this.texYmax-this.texYmin)/(X-S),this.anchorX*=p/this.computedWidth,this.anchorY*=u/this.computedHeight}}function r(t,e=1e-7){const i=Math.ceil(t);return i-t<e?i:Math.floor(t)}function n(t,e=1e-7){const i=Math.floor(t);return t-i<e?i:Math.ceil(t)}t.ComputedMarkerParams=h,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));