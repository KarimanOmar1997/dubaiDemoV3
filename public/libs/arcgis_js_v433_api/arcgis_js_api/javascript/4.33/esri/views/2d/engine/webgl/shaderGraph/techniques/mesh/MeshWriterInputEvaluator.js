// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../../core/arrayUtils","../../../../../../../core/Error","../../../../../../../core/lang","../../../../../../../core/Logger","../../../../../../../support/ArcadeExpression","../../../grouping","../../../animations/infos","../../../animations/utils","./utils","../../../../../layers/features/support/DictionaryValue"],(function(e,t,r,s,o,a,i,n,c,p,m){"use strict";async function f(e,t,r,s){const{defaultValue:o,valueExpressionInfo:a,value:i}=t;if(a){if("dictionary-template"===a.type)return{...t,computed:e.createDictionaryTemplateField(a,r),defaultValue:o};const{expression:i}=a,n=await e.createComputedField({expression:i},s);return n?{...t,computed:n,defaultValue:o}:null}return{...t,computed:new m.DictionaryValue(i),defaultValue:o}}async function l(e,t,r){const{valueExpressionInfo:s}=t,o="dictionary-template"===s.type?e.createDictionaryTemplateField(s,r):await e.createComputedField({expression:s.expression});return o?{...t,computed:o}:null}function d(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function u(e){if(Array.isArray(e))for(const t of e)if(u(t))return!0;if("object"==typeof e){if(d(e))return!0;for(const t in e)if(u(e[t]))return!0}return!1}class y{static async create(e,r,s,o){const a={},i=new Map,n=new Map,p=new Map,m=new Map,h=new Map,v=new Map;for(const y in s){const P=s[y];if(null!=P&&"object"==typeof P)if(Array.isArray(P)){if("object"==typeof P[0])throw new Error(`InternalError: Cannot handle ${y}. Nested array params are not supported`);a[y]=P}else if("valueExpressionInfo"in P){if(P.value){a[y]=P.value;continue}const t=await l(e,P,o);if(!t){a[y]=P.defaultValue;continue}i.set(y,t),a[y]=null}else switch(P.type){case"cim-effect-infos":if(P.effectInfos.some((e=>e.overrides.length))){n.set(y,{effects:await Promise.all(P.effectInfos.map((async r=>{const s=r.overrides.map((t=>f(e,t,o,!1)));return{effect:r.effect,compiledOverrides:(await Promise.all(s)).filter(t.isSome)}})))});break}a[y]=P.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":P.overrides.length&&p.set(y,{placementInfo:P,compiledOverrides:(await Promise.all(P.overrides.map((t=>f(e,t,o,!1))))).filter(t.isSome)}),a[y]=P.placement;break;case"text-rasterization-param":{if(P.overrides.length){const r=P.overrides.map((t=>f(e,t,o,P.useLegacyLabelEvaluationRules??!1)));m.set(y,{compiledOverrides:(await Promise.all(r)).filter(t.isSome),rasterizationParam:P,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:P.resource};a[y]=await r.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(P.overrides.length){const r=P.overrides.map((t=>f(e,t,o,!1)));m.set(y,{compiledOverrides:(await Promise.all(r)).filter(t.isSome),rasterizationParam:P,objectIdToResourceId:new Map});continue}if("animated"===P.resource.type){m.set(y,{compiledOverrides:[],rasterizationParam:P,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:P.resource};a[y]=await r.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=P;if(u(t)){const r={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const s={props:{}};for(const r in t)if(d(t[r])){const a=await l(e,t[r],o);s.compiledExpressionMap||(s.compiledExpressionMap=new Map);const i=s.compiledExpressionMap;a&&i.set(r,a)}else s.props[r]=t[r];r.compiledMarkerInfos.push(s)}))),h.set(y,r)}else a[y]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:t}=P,s=c.createParamList(t);if(u(s)){const t=await Promise.all(s.map((t=>c.compileAnimationParam(t,e))));v.set(y,{params:t,propertyIdToResourceId:new Map,key:y})}else{const e=c.fromJSON(s),t=await r.fetchResourceImmediate({type:"animation-info",resource:e});null!=t&&"sprite"===t.type&&(a[y]={dataRow:t.rect.y,dataColumn:t.rect.x})}break}default:a[y]=P}else a[y]=P}return new y(s,a,i,n,p,m,h,v)}constructor(e,t,r,s,o,i,n,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=r,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=o,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=c,this.evaluator=e=>e,this._arcadeDependencies=new Set;for(const e of this._expressions())a.collectExpressionDependencies(this._arcadeDependencies,e)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,a){for(const n of this._dynamicAsyncProperties.values()){const c=s.clone(n.rasterizationParam.resource);"animated"===n.rasterizationParam.resource.type&&n.rasterizationParam.resource.randomizeStartTime&&(c.primitiveName="__RESERVED__PRIMITIVE__NAME__",c.startGroup=i.getStartGroup(t.getObjectId()||0));for(const{primitiveName:e,propertyName:s,computed:i,defaultValue:m,valueExpressionInfo:f}of n.compiledOverrides)try{const r="animated"===n.rasterizationParam.resource.type?c.primitiveName:e;p.applyComputedValue(c,r,s,i,t,a,m)}catch(e){o.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new r("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:e,valueExpressionInfo:f}))}const m=e.enqueueRequest({type:"cim-rasterization-info",resource:c});n.objectIdToResourceId.set(t.getObjectId(),m)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map((e=>c.resolveToAnimationInfo(e,t,a))).map(n.hydrate).map((e=>e.simplify())),o=c.encodeParamList(s),i=e.enqueueRequest({type:"animation-info",resource:o});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,i)}}evaluateMeshParams(e,t,r){for(const[e,s]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=s.computed.readWithDefault(t,r,s.defaultValue);for(const[e,s]of this._dynamicPlacementProperties.entries())for(const{computed:o,defaultValue:a,propertyName:i}of s.compiledOverrides){const n=o.readWithDefault(t,r,a);s.placementInfo.placement[i]=n,this._resolvedMeshParams[e]=s.placementInfo.placement}for(const[e,s]of this._dynamicEffectProperties.entries())for(const o of s.effects){for(const{computed:e,defaultValue:s,propertyName:a}of o.compiledOverrides){const i=e.readWithDefault(t,r,s);o.effect[a]=i}this._resolvedMeshParams[e]=s.effects.map((e=>e.effect))}for(const[e,s]of this._dynamicTransformProperties.entries()){const o={type:"cim-marker-transform-info",infos:[]};for(const e of s.compiledMarkerInfos){const s={...e.props};if(e.compiledExpressionMap)for(const[o,a]of e.compiledExpressionMap){const e=a.computed.readWithDefault(t,r,a.defaultValue);s[o]="number"==typeof e||"boolean"==typeof e?e:a.defaultValue}o.infos.push(s)}this._resolvedMeshParams[e]=o}for(const[r,s]of this._dynamicAsyncProperties.entries()){const o=s.objectIdToResourceId.get(t.getObjectId());if(null==o)continue;const a=e.getResource(o);this._resolvedMeshParams[r]=a}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const o=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(null==o)continue;const a=e.getResource(o);this._resolvedMeshParams[r]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const e of t.compiledOverrides)yield e.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(null!=t.compiledExpressionMap)for(const e of t.compiledExpressionMap.values())yield e.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*c.getAnimationExpressions(t)}}e.MeshWriterInputEvaluator=y,e.hasExpression=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));