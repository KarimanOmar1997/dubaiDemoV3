// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../../chunks/tslib.es6","../../../definitions","../../GraphShaderModule","../../graph/glsl","../shaders/AFeatureShader","../shaders/constants","../shaders/hittestUtils","../shaders/MosaicInfo","../shaders/utils","../shaders/VisualVariableColor","../shaders/VisualVariableOpacity","../shaders/VisualVariableRotation","../shaders/VisualVariableSizeMinMaxValue","../shaders/VisualVariableSizeScaleStops","../shaders/VisualVariableSizeStops","../shaders/VisualVariableSizeUnitValue","../shaders/vvUtils"],(function(e,t,i,o,a,l,s,r,n,d,p,c,u,y,V,h,x,f){"use strict";const b=360/254;var v;e.TextRenderPassType=void 0,(v=e.TextRenderPassType||(e.TextRenderPassType={}))[v.Color=0]="Color",v[v.Outline=1]="Outline",v[v.Halo=2]="Halo";class m extends l.FeatureVertexInput{}t.__decorate([o.location(3,a.Vec4)],m.prototype,"color",void 0),t.__decorate([o.location(4,a.Vec2)],m.prototype,"offset",void 0),t.__decorate([o.location(5,a.Vec2)],m.prototype,"textureUV",void 0),t.__decorate([o.location(6,a.Vec2)],m.prototype,"fontAndReferenceSize",void 0),t.__decorate([o.location(7,a.Vec4)],m.prototype,"outlineColor",void 0),t.__decorate([o.location(8,a.Vec4)],m.prototype,"haloColor",void 0),t.__decorate([o.location(9,a.Vec2)],m.prototype,"outlineAndHaloSize",void 0),t.__decorate([o.location(10,a.Vec2)],m.prototype,"zoomRange",void 0),t.__decorate([o.location(11,a.Float)],m.prototype,"clipAngle",void 0),t.__decorate([o.location(12,a.Vec4)],m.prototype,"referenceSymbol",void 0),t.__decorate([o.location(15,a.Float)],m.prototype,"visibility",void 0);class _ extends o.ComputeVertexInput{}t.__decorate([o.location(13,a.Vec2)],_.prototype,"offsetNextVertex1",void 0),t.__decorate([o.location(14,a.Vec2)],_.prototype,"offsetNextVertex2",void 0);class w extends l.FeatureFragmentInput{}class S extends l.AFeatureShader{constructor(){super(...arguments),this.type="TextShader",this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"]},this.textRenderPassType=e.TextRenderPassType.Color,this.isBackgroundPass=!1,this.isLabel=!1}clipLabel(e,t){const{clipAngle:o,zoomRange:l,visibility:s}=e,r=o.multiply(b),n=a.abs(this.view.rotation.subtract(r)),d=a.min(new a.Float(360).subtract(n),n);let p=new a.Float(0);const c=a.floor(this.view.currentZoom.multiply(i.minMaxZoomPrecisionFactor)).divide(i.minMaxZoomPrecisionFactor),u=l.x,y=l.y,V=new a.Float(1).subtract(a.step(u,c)).multiply(2),h=a.step(new a.Float(90),d).multiply(2),x=new a.Float(2).multiply(new a.Float(1).subtract(a.step(c,y)));return p=p.add(t.multiply(V)),p=p.add(t.multiply(h)),p=p.add(x),s&&(p=p.add(s)),p}vertex(t,o){const l=d.getBit(t.bitset,s.bitsetTextIsBackground),r=new a.Float(1).subtract(l);let n=t.fontAndReferenceSize[0];const p=t.fontAndReferenceSize[1];let c=n.divide(s.sdfFontSize);const u=this.textRenderPassType===e.TextRenderPassType.Outline?t.outlineColor:this.textRenderPassType===e.TextRenderPassType.Halo?t.haloColor:this._getVertexColor(t),y=this.view.displayViewScreenMat3.multiply(new a.Vec3(t.pos,1));let V=t.offset,h=new a.Float(1),x=a.Mat3.identity(),b=new a.Vec2(0);if(this.isLabel){if(!t.referenceSymbol)throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");const e=t.referenceSymbol,o=e.xy,a=e.z,l=this._unpackDirection(e.w),s=f.getVisualVariableSize(this,t.id,a).divide(2),r=l.multiply(s.add(i.labelPlacementOffsetPadding));b=o.add(r),V=V.add(b)}else h=f.getVisualVariableSize(this,t.id,p).divide(p),n=n.multiply(h),c=c.multiply(h),V=V.multiply(h),x=f.getVisualVariableRotation(this,t.id),V=x.multiply(new a.Vec3(V,0)).xy;const v=d.getBit(t.bitset,s.bitsetTextIsMapAligned),m=this._getViewRotationMatrix(v).multiply(new a.Vec3(V,0));let _=this.isLabel?this.clipLabel(t,v):this.clip(t.id,t.zoomRange);_=this.isBackgroundPass?_.add(r.multiply(2)):_.add(l.multiply(2));let w=new a.Float(0);if(this.textRenderPassType===e.TextRenderPassType.Outline&&(_=_.add(a.ifElse(a.equal(t.outlineAndHaloSize.x,new a.Float(0)),new a.Float(2),new a.Float(0))),w=new a.Float(t.outlineAndHaloSize.x).divide(c).divide(s.maxSdfDistance)),this.textRenderPassType===e.TextRenderPassType.Halo){const e=t.outlineAndHaloSize.x,i=new a.Float(t.outlineAndHaloSize.y);_=_.add(a.ifElse(a.equal(i,new a.Float(0)),new a.Float(2),new a.Float(0))),w=i.add(e).divide(c).divide(s.maxSdfDistance)}const S=this.isLabel?a.greaterThan(_,new a.Float(1)):new a.Bool(!1);return{glPosition:new a.Vec4(y.xy.add(m.xy),_,1),color:u,size:c,textureUV:t.textureUV.divide(this.mosaicInfo.size),antialiasingWidth:new a.Float(.105*s.sdfFontSize).divide(n).divide(this.view.pixelRatio),outlineDistanceOffset:w,...this.maybeRunHittest(t,o,{vvSizeAdjustment:h,vvRotation:x,labelOffset:b,labelClipped:S})}}_getViewRotationMatrix(e){const t=this.view.displayViewMat3,i=this.view.displayMat3,o=new a.Float(1).subtract(e);return t.multiply(e).add(i.multiply(o))}fragment(e){const t=new a.Float(2/8),i=new a.Float(1).subtract(t),o=a.texture2D(this.mosaicInfo.texture,e.textureUV).a;let l=i.subtract(e.outlineDistanceOffset);this.highlight&&(l=l.divide(2));const s=e.antialiasingWidth,r=a.smoothstep(l.subtract(s),l.add(s),o);return this.getFragmentOutput(e.color.multiply(r),e)}hittest(e,t,{vvSizeAdjustment:i,vvRotation:o,labelOffset:l,labelClipped:s}){let n,d,p;this.isLabel?(n=new a.Vec3(e.offset.add(l),0),d=new a.Vec3(t.offsetNextVertex1.add(l),0),p=new a.Vec3(t.offsetNextVertex2.add(l),0)):(n=o.multiply(new a.Vec3(e.offset.multiply(i),0)),d=o.multiply(new a.Vec3(t.offsetNextVertex1.multiply(i),0)),p=o.multiply(new a.Vec3(t.offsetNextVertex2.multiply(i),0)));const{viewMat3:c,tileMat3:u}=this.view,y=c.multiply(u).multiply(new a.Vec3(e.pos,1)),V=y.add(u.multiply(n)).xy,h=y.add(u.multiply(d)).xy,x=y.add(u.multiply(p)).xy,f=r.distPointTriangle(this.hittestRequest.position,V.xy,h.xy,x.xy);return this.isLabel?a.ifElse(s,r.failHittest(this.hittestRequest),f):f}_unpackDirection(e){const t=new a.Int(e),i=a.bitRShift(t,new a.Int(2)),o=a.bitAnd(t,new a.Int(3));return new a.Vec2(new a.Float(i).subtract(1),new a.Float(o).subtract(1))}_getVertexColor(e){let t=e.color;if(this.visualVariableColor){const i=this.storage.getColorValue(e.id);t=this.visualVariableColor.getColor(i,e.color,new a.Bool(!1))}if(this.visualVariableOpacity){const i=this.storage.getOpacityValue(e.id),o=this.visualVariableOpacity.getOpacity(i);t=t.multiply(o)}return t}}t.__decorate([o.option(p.VisualVariableColor)],S.prototype,"visualVariableColor",void 0),t.__decorate([o.option(c.VisualVariableOpacity)],S.prototype,"visualVariableOpacity",void 0),t.__decorate([o.option(u.VisualVariableRotation)],S.prototype,"visualVariableRotation",void 0),t.__decorate([o.option(y.VisualVariableSizeMinMaxValue)],S.prototype,"visualVariableSizeMinMaxValue",void 0),t.__decorate([o.option(V.VisualVariableSizeScaleStops)],S.prototype,"visualVariableSizeScaleStops",void 0),t.__decorate([o.option(h.VisualVariableSizeStops)],S.prototype,"visualVariableSizeStops",void 0),t.__decorate([o.option(x.VisualVariableSizeUnitValue)],S.prototype,"visualVariableSizeUnitValue",void 0),t.__decorate([o.uniform(n.MosaicInfo)],S.prototype,"mosaicInfo",void 0),t.__decorate([o.define],S.prototype,"textRenderPassType",void 0),t.__decorate([o.define],S.prototype,"isBackgroundPass",void 0),t.__decorate([o.define],S.prototype,"isLabel",void 0),t.__decorate([t.__param(0,o.input(m)),t.__param(1,o.input(_))],S.prototype,"vertex",null),t.__decorate([t.__param(0,o.input(w))],S.prototype,"fragment",null),e.TextFragmentInput=w,e.TextShader=S,e.TextVertexInput=m,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));