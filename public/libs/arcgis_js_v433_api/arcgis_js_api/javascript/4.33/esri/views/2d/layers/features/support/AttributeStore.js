// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/Error","../../../../../core/has","../../../../../core/Logger","../../../../../core/accessorSupport/diffUtils","../../../../../support/ArcadeExpression","../../../engine/webgl/definitions","../../../engine/webgl/DisplayId","../../../engine/webgl/Utils","../../../engine/webgl/shaderGraph/techniques/shaders/constants","../../../engine/webgl/util/debug","./DisplayIdGenerator","./FeatureFilterEvaluator","../../../../webgl/enums"],(function(t,e,i,s,a,r,n,l,o,h,d,c,u,p){"use strict";function g(t,e){if(!t||!e)return t;switch(e){case"radius":case"distance":return 2*t;case"diameter":case"width":return t;case"area":return Math.sqrt(t)}return t}const y=()=>s.getLogger("esri.views.layers.2d.features.support.AttributeStore"),_=d.createDebugLogger(d.DEBUG_ATTR_UPDATES,y()),b=i("esri-shared-array-buffer");i("esri-atomics");class f{constructor(t,e,i){this.size=0,this.texelSize=4,this.dirtyStart=0,this.dirtyEnd=0;const{pixelType:s,layout:a,textureOnly:r}=e;this.textureOnly=r||!1,this.pixelType=s,this.layout=a,this._resetRange(),this.size=t,this.isLocal=i,r||(this.data=this._initData(s,t))}get buffer(){return this.data?.buffer}unsetComponentAllTexels(t,e){const i=this.data;for(let s=0;s<this.size*this.size;s++)i[s*this.texelSize+t]&=~e;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponentAllTexels(t,e){const i=this.data;for(let s=0;s<this.size*this.size;s++)i[s*this.texelSize+t]|=255&e;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponent(t,e,i){const s=this.data;for(const a of i)s[a*this.texelSize+t]|=e,this.dirtyStart=Math.min(this.dirtyStart,a),this.dirtyEnd=Math.max(this.dirtyEnd,a)}setComponentTexel(t,e,i){this.data[i*this.texelSize+t]|=e,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}unsetComponentTexel(t,e,i){this.data[i*this.texelSize+t]&=~e,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}getData(t,e){const i=l.getDisplayIdTexel(t);return this.data[i*this.texelSize+e]}setData(t,e,i){const s=l.getDisplayIdTexel(t),a=1<<e;0!==(this.layout&a)?null!=this.data&&(this.data[s*this.texelSize+e]=i,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s)):y().error("mapview-attributes-store","Tried to set a value for a texel's readonly component")}expand(t){if(this.size=t,!this.textureOnly){const e=this._initData(this.pixelType,t),i=this.data;e.set(i),this.data=e}}toMessage(){const t=this.dirtyStart,e=this.dirtyEnd,i=this.texelSize;if(t>e)return null;this._resetRange();const s=!this.isLocal,a=this.pixelType,r=this.layout,n=this.data;return{start:t,end:e,data:s&&n.slice(t*i,(e+1)*i)||null,pixelType:a,layout:r}}_initData(t,e){const i=ArrayBuffer,s=o.getPixelArrayCtor(t),a=new s(new i(e*e*4*s.BYTES_PER_ELEMENT));for(let t=0;t<a.length;t+=4)a[t+1]=255;return a}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}}t.AttributeStore=class{constructor(t){this._client=t,this._filters=[],this._blocks=new Array,this._attributeComputeInfo=null,this._abortController=new AbortController,this._size=n.attributeStoreInitialSize,this._idsToHighlight=new Map,this._arcadeDependencies=new Set,this._initialized=!1,this.version=0,this._idGenerator=new c.DisplayIdGenerator,this._epoch=1}destroy(){this._abortController.abort()}_initialize(){if(null!=this._blockDescriptors)return;const t=p.PixelType.FLOAT;_(`Creating AttributeStore ${b?"with":"without"} shared memory`),this._blockDescriptors=[{pixelType:p.PixelType.UNSIGNED_BYTE,layout:1},{pixelType:p.PixelType.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:p.PixelType.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:p.PixelType.FLOAT,layout:15}],this._blocks=this._blockDescriptors.map((()=>null))}get hasHighlight(){return this._idsToHighlight.size>0}createDisplayIdForObjectId(t){return this._idGenerator.createIdForObjectId(t)}releaseDisplayIdForObjectId(t){return this._idGenerator.releaseIdForObjectId(t)}getDisplayIdForObjectId(t){return this._idGenerator.getDisplayIdForObjectId(t)}incrementDisplayIdGeneration(){this._idGenerator.incrementGeneration()}hasArcadeDependency(t){return this._arcadeDependencies.has(t)}releaseAllIds(){this._idGenerator.releaseAll()}async update(t,e,s,r=0){const n=a.diff(this._schema,t);if(this.version=r,n&&(i("esri-2d-update-debug")&&console.debug(`Version[${r}] AttributeStore.update`,{changed:n}),this._schema=t,this._attributeComputeInfo=null,this._initialize(),null!=t))if(s&&(this._filters=await Promise.all(t.filters.map((t=>t?u.create({geometryType:s.geometryType,hasM:!1,hasZ:!1,timeInfo:s.timeInfo,fieldsIndex:s.fieldsIndex,spatialReference:s.outSpatialReference,filterJSON:t}):null)))),"multi"!==t.type)this._attributeComputeInfo={type:"feature",map:new Map},await Promise.all(t.bindings.map((async t=>{const i=await this._bind(e,t);this._updateReferences(i)})));else{this._attributeComputeInfo={type:"multi",keyField:t.keyField,map:new Map};for(const i in t.bindings){const s=t.bindings[i];await Promise.all(s.map((async t=>{const s=await this._bind(e,t,parseInt(i,10));this._updateReferences(s)})))}}}setHighlight(t,e){let i=null;0===t.length&&0===e.length&&(i=this._getBlock(0),i.unsetComponentAllTexels(0,(1<<n.maxHighlightReasons)-1));for(const{displayId:e,highlightFlags:s}of t){if(null==e||-1===e)continue;i||(i=this._getBlock(0),i.unsetComponentAllTexels(0,(1<<n.maxHighlightReasons)-1));const t=l.getDisplayIdTexel(e);i.setComponent(0,s,[t])}this._idsToHighlight.clear();for(const{objectId:e,highlightFlags:i}of t)this._idsToHighlight.set(e,i);for(const{objectId:t,highlightFlags:i}of e)this._idsToHighlight.set(t,i)}setData(t,e,i,s){const a=l.getDisplayIdTexel(t);this._ensureSizeForTexel(a),this._getBlock(e).setData(t,i,s)}getData(t,e,i){return this._getBlock(e).getData(t,i)}getHighlightFlags(t){return this._idsToHighlight.get(t)||0}unsetAttributeData(t){const e=l.getDisplayIdTexel(t);this._getBlock(0).setData(e,0,0)}setAttributeData(t,e,i,s){const a=l.getDisplayIdTexel(t);this._ensureSizeForTexel(a),this._getBlock(0).setData(a,0,this.getFilterFlags(e,s));const r=this._attributeComputeInfo;let o=null;r&&(o="multi"===r.type?r.map.get(e.readAttribute(r.keyField)):r.map,o?.size&&o.forEach(((t,s)=>{const r=1*s%4,l=Math.floor(1*s/4),o=this._getBlock(l+n.AttributeDataType.VV);let d=t.field?.read(e,i);t.valueRepresentation&&(d=g(d,t.valueRepresentation)),(null===d||isNaN(d)||d===1/0||d===-1/0)&&(d=h.nanMagicNumber),o.setData(a,r,d)})))}get epoch(){return this._epoch}sendUpdates(){const t=this._blocks.map((t=>null!=t?t.toMessage():null)),e=this._getInitArgs();i("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.start"),this._client.update({initArgs:e,blockData:t,version:this.version,sendUpdateEpoch:this._epoch}),this._epoch+=1,i("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.end")}_ensureSizeForTexel(t){for(;t>=this._size*this._size;)if(this._expand())return}async _bind(t,e,i){const s=await t.createComputedField(e),{valueRepresentation:a}=e,r=this._attributeComputeInfo;if("multi"===r.type){const t=r.map.get(i)??new Map;t.set(e.binding,{field:s,valueRepresentation:a}),r.map.set(i,t)}else r.map.set(e.binding,{field:s,valueRepresentation:a});return s}_getInitArgs(){return this._initialized?null:(this._initialized=!0,this._getBlock(n.AttributeDataType.Animation),this._getBlock(n.AttributeDataType.GPGPU),this._getBlock(n.AttributeDataType.LocalTimeOrigin),{blockSize:this._size,blockDescriptors:this._blocks.map((t=>null!=t?{textureOnly:t.textureOnly,buffer:t.buffer,pixelType:t.pixelType}:null))})}_getBlock(t){const e=this._blocks[t];if(null!=e)return e;_(`Initializing AttributeBlock at index ${t}`);const i=new f(this._size,this._blockDescriptors[t],this._client.isLocal);return this._blocks[t]=i,this._initialized=!1,i}_expand(){if(this._size<this._schema.capabilities.maxTextureSize){const t=this._size<<=1;_("Expanding block size to",t,this._blocks);for(const e of this._blocks)e?.expand(t);return this._initialized=!1,this._size=t,0}return y().error(new e("mapview-limitations","Maximum number of onscreen features exceeded.")),-1}_updateReferences(t){r.collectExpressionDependencies(this._arcadeDependencies,t)}isVisible(t){return!!(this._getBlock(0).getData(t,0)&1<<n.maxHighlightReasons)}getFilterFlags(t,e){let i=0;for(let s=0;s<this._filters.length;s++){const a=!!(1<<s),r=this._filters[s];i|=(!a||null==r||r.check(t,e)?1:0)<<s}let s=0;if(this._idsToHighlight.size){const e=t.getObjectId();s=this.getHighlightFlags(e)}return i<<n.maxHighlightReasons|s}},t.getVisualVariableSizeValueRepresentationRatio=g,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));