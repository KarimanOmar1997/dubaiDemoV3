// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/compilerUtils","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/ellipsoidUtils","../../../../chunks/sphere","./common","./ConstraintTypes","./InteractionType","./TiltMode","../../state/utils/viewUtils"],(function(e,t,n,r,a,i,s,o,c,l,u,d,m,f){"use strict";function p(e,t,r,a=l.defaultConstraintOptions,s){if(!e.state.constraints.tilt)return 0;const C=Math.min(t.relativeElevation*g,t.distance),T=e.state.constraints.tilt(C,A);return function(e,t,n){if(t.interactionType===d.InteractionType.NONE)return;const{interactionStartCamera:r,interactionFactor:a}=t;if(!r)return;const{min:i,max:s}=n,o=p(e,r,l.defaultConstraintOptions,t),c=0===o?0:f.viewAngle(e.renderCoordsHelper,r.center,r.eye);n.min=i,n.max=s,t.interactionType===d.InteractionType.TUMBLE?(l.hasConstraintType(t.selection,u.ConstraintTypes.ALTITUDE)&&y(e,r,n),l.adjustRangeForInteraction(o,c,!0,a,O,n)):l.adjustRangeForInteraction(o,c,!1,a,O,n)}(e,r,T),a.interactionType===d.InteractionType.TUMBLE&&l.hasConstraintType(a.selection,u.ConstraintTypes.ALTITUDE)&&y(e,a.interactionStartCamera,T),r.tiltMode===m.TiltMode.LOOK_AROUND||a.tiltMode===m.TiltMode.LOOK_AROUND?function(e,t,r,a){switch(a&&(a.requiresTwoSteps=!1),e.viewingMode){case"global":return function(e,t,r,a){const s=function(e,t,r){const a=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,s=a+o.getReferenceEllipsoid(e.spatialReference).radius,l=e.renderCoordsHelper.intersectManifold(t.ray,a,I);return r.distance=Math.min(t.relativeElevation*g,t.distance),r.centerIsOnSurface=!1,null!=l?(r.distance=Math.min(t.relativeElevation*g,i.distance(t.eye,l)),r.tiltAtCenter=f.viewAngle(e.renderCoordsHelper,l,t.eye),r.centerIsOnSurface=!0):e.state.isLocal?r.tiltAtCenter=f.viewAngle(e.renderCoordsHelper,t.center,t.eye):(c.closestPointOnSilhouette(c.fromRadius(c.tmpSphere,s),t.ray,I),r.distance=Math.min(t.relativeElevation*g,i.distance(t.eye,I)),r.tiltAtCenter=n.acosClamped(-i.dot(t.viewForward,i.normalize(I,I)))),r.radius=s,r.eyeRadius=i.length(t.eye),r.constraints=e.state.constraints,r}(e,t,v),l=n.clamp(s.tiltAtCenter,r.min,r.max);if(!M(s.tiltAtCenter-l))return 0;let u,d;return s.centerIsOnSurface?(u=function(e){const{constraints:t,distance:n,tiltAtCenter:r}=e;let a=r,i=t.clampTilt(n,r);const s=h(e,i);if(t.clampTilt(s,r)===i)return i;let o=0;for(;o<10&&M(i-a);){const n=(a+i)/2,r=h(e,n);M(t.clampTilt(r,n)-n)?a=n:i=n,o++}return i}(s),d=function(e,t){const r=n.asinClamped(e.radius/e.eyeRadius*Math.sin(e.tiltAtCenter)),a=n.asinClamped(e.radius/e.eyeRadius*Math.sin(t));return e.eyeRadius>e.radius?r-a:a-r}(s,u)):(u=s.constraints.clampTilt(s.distance,s.tiltAtCenter),a&&u<Math.PI/2&&(a.requiresTwoSteps=!0,u=Math.PI/2-1e-5),d=function(e,t){return e.tiltAtCenter-Math.PI/2-(t-Math.PI/2)}(s,u)),a&&(a.eyeCenterDistance=h(s,u)),d}(e,t,r,a);case"local":return function(e,t,r,a){const i=f.viewAngle(e.renderCoordsHelper,t.center,t.eye),s=n.clamp(i,r.min,r.max),o=i-s;if(!M(o))return 0;if(a){const n=Math.abs(e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude),r=e.renderCoordsHelper.getAltitude(t.eye)-n,i=Math.max(Math.cos(s),1e-4);Math.abs(i)>1e-4?a.eyeCenterDistance=r/i:a.eyeCenterDistance=t.distance}return o}(e,t,r,a)}}(e,t,T,s):function(e,t,r){const a=f.viewAngle(e.renderCoordsHelper,t.center,t.eye),i=a-n.clamp(a,r.min,r.max);return M(i)?i:0}(e,t,T)}function M(e){return Math.abs(e)>1e-9}function h(e,t){if(!e.centerIsOnSurface)return e.distance;const r=Math.PI-n.clamp(t,0,Math.PI),a=n.asinClamped(e.radius/e.eyeRadius*Math.sin(r)),i=Math.PI-r-a,s=Math.sin(i)/Math.sin(r);if(e.eyeRadius<e.radius&&s>1){const t=Math.PI-a,n=Math.PI-r-t;return Math.sin(n)/Math.sin(r)*e.eyeRadius}return s*e.eyeRadius}function y(e,t,r){const a=e.state.constraints;if(e.state.isLocal||!a.altitude||!t)return;const s=i.squaredLength(t.center),c=Math.sqrt(s),l=t.distance,u=o.getReferenceEllipsoid(e.spatialReference).radius,d=a.altitude.min+u,m=a.altitude.max+u,f=(d*d-l*l-s)/(-2*c*l),p=(m*m-l*l-s)/(-2*c*l);r.min=Math.max(r.min,Math.min(Math.PI-n.acosClamped(p),r.max)),r.max=Math.min(r.max,Math.PI-n.acosClamped(f))}const C=s.create(),T=a.create(),I=s.create(),O=n.deg2rad(5),g=30,A={min:0,max:0},v={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,distance:0,tiltAtCenter:0},R={eyeCenterDistance:0,requiresTwoSteps:!1};e.applyTiltConstraint=function e(n,a,s,o=!0){R.eyeCenterDistance=0,R.requiresTwoSteps=!1;const c=p(n,a,s,l.defaultConstraintOptions,R);if(0===c)return!1;switch(r.fromRotation(T,-c,a.viewRight),s.tiltMode){case m.TiltMode.LOOK_AROUND:i.transformMat4(C,a.viewForward,T),i.scale(C,C,R.eyeCenterDistance),a.center=i.add(I,a.eye,C);break;case m.TiltMode.TUMBLE:i.subtract(C,a.center,a.eye),i.transformMat4(C,C,T),a.eye=i.subtract(I,a.center,C);break;default:t.neverReached(s.tiltMode)}return a.up=i.transformMat4(I,a.up,T),!R.requiresTwoSteps||!o||e(n,a,s,!1)},e.getTiltConstraintError=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));