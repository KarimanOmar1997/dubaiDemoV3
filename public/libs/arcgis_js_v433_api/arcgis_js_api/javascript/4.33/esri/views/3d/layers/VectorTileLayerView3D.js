// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
require({cache:{"esri/views/2d/engine/vectorTiles/SchemaHelper":function(){define(["exports"],(function(e){"use strict";e.SchemaHelper=class{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,r=0;const n=this._shift+this.getLevelShift(e[0]);if(n){const a=(1<<n)-1,o=t/(this._scale*(1<<n-1));i=(e[2]&a)*o,r=(e[1]&a)*o}return[i,r]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/TileHandler3D":function(){define(["../../../../core/MemCache","../../../../core/promiseUtils","../../../../core/libs/gl-matrix-2/factories/mat3f32","../../../../geometry/support/aaBoundingRect","./constants","./TileHandler","./VectorTile","../../tiling/TileInfoViewPOT","../../tiling/TileKey"],(function(e,t,i,r,n,a,o,s,l){"use strict";class c extends a.TileHandler{constructor(e,t,i,r){super(e,t,i,e.tileInfo.lods.length-1),this._memCache=r,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new s(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(a,s){const c=new l(a[0],a[1],a[2],0);let u=this._memCache.get(c.id);if(u)return u.retain(),u;const h=await this._getVectorTileData(c);if(t.throwIfAborted(s),!this._layer)return null;if(u=this._memCache.get(c.id),u)return u.retain(),u;const p=this._layer.tileInfo.getTileBounds(r.create(),c),d=this._tileInfoView.getTileResolution(a[0]);return u=new o.VectorTile(c,d,p[0],p[3],n.tilePixelSize,n.tilePixelSize,this._styleRepository,this._memCache),u.setData(h),h&&(u.retain(),this._memCache.put(c.id,u,e.MinPriority)),u.neededForCoverage=!0,u.transforms.tileUnitsToPixels=i.fromValues(1/8,0,0,0,1/8,0,0,0,1),u}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,r={signal:i.signal},n=this._getParsedVectorTileData(e,r).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,n),this._ongoingRequestToController.set(t,i),n}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}}return c}))},"esri/views/2d/engine/vectorTiles/TileHandler":function(){define(["exports","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/workers/workers","./enums","./GlyphMosaic","./GlyphSource","./SpriteMosaic","../../tiling/TileKey"],(function(e,t,i,r,n,a,o,s,l,c){"use strict";e.TileHandler=class{constructor(e,t,i,r){this._layer=e,this._styleRepository=t,this.devicePixelRatio=i,this._sourceDataMaxLOD=r,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=t.abortMaybe(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(e){this._requestSprite(e);const t=this._layer.currentStyleInfo.glyphsUrl,a=new s(t?r.addQueryParameters(t,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new o(1024,1024,a),this._broadcastPromise=n.open("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then((t=>{if(this._layer&&(this._connection?.close(),this._connection=t,this._layer&&!this._connection.closed)){const r=t.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},e);Promise.all(r).catch((e=>i.throwIfNotAbortError(e)))}}))}_requestSprite(e){this._spriteSourceAbortController?.abort();const t=new AbortController;this._spriteSourceAbortController=t;const r=e?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,r&&(this._inputSignalEventListener=function(e){return()=>e.abort()}(t),r.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:n}=t,a={...e,signal:n};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,a),this._spriteSourcePromise.then((e=>{i.throwIfAbortError(n),this._spriteMosaic=new l(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}))}async updateStyle(e){const t=[];for(const i of e)i.type===a.StyleUpdateType.SPRITES_CHANGED?t.push({type:a.StyleUpdateType.SPRITES_CHANGED,data:{spriteSource:null}}):t.push(i);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(e){const t=new l(1024,1024,250);return t.setSpriteSource(e),this._spriteMosaic=t,this._spriteSourcePromise=Promise.resolve(e),this._spriteSourceAbortController=null,t}async setStyle(e,t,i){await this._broadcastPromise,this._styleRepository=e,this._sourceDataMaxLOD=i,this._requestSprite();const n=new s(this._layer.currentStyleInfo.glyphsUrl?r.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new o(1024,1024,n),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:t,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(e,t){const i=await this._getRefKeys(e,t);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),i,t)}async fetchTilePBFs(e){const t=Object.keys(this._layer.sourceNameToSource),i={},r=await this._getRefKeys(e,i),n=[],a=[];for(let e=0;e<r.length;e++)if(null==r[e].value||null==t[e])a.push(null);else{const o=r[e].value,s=this._getTilePayload(o,t[e],i);s.then((e=>{n.push({...e,key:o})})),a.push(s)}return Promise.all(a).then((()=>n))}async parseTileData(e,t){const i=e&&e.data;if(!i)return null;const{sourceName2DataAndRefKey:r,transferList:n}=i;return 0===Object.keys(r).length?null:this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:r,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:n})))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}async _getTilePayload(e,t,r){const n=c.pool.acquire(e.id),a=this._layer.sourceNameToSource[t],{level:o,row:s,col:l}=n;c.pool.release(n);try{return{protobuff:await a.requestTile(o,s,l,r),sourceName:t}}catch(e){if(i.isAbortError(e))throw e;return{protobuff:null,sourceName:t}}}async _getRefKeys(e,t){const r=this._layer.sourceNameToSource,n=new Array;for(const i in r){const a=r[i].getRefKey(e,t);n.push(a)}return i.eachAlways(n)}_getSourcesData(e,t,r){const n=[];for(let i=0;i<t.length;i++)if(null==t[i].value||null==e[i])n.push(null);else{const a=t[i].value,o=this._getTilePayload(a,e[i],r);n.push(o)}return i.eachAlways(n).then((e=>{const i={},r=[];for(let n=0;n<e.length;n++){const a=e[n].value;if(a&&a.protobuff&&a.protobuff.byteLength>0){const e=t[n].value.id;i[a.sourceName]={refKey:e,protobuff:a.protobuff},r.push(a.protobuff)}}return{sourceName2DataAndRefKey:i,transferList:r}}))}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/GlyphMosaic":function(){define(["./RectangleBinPack","../webgl/Rect","../../../webgl/enums","../../../webgl/Texture","../../../webgl/TextureDescriptor"],(function(e,t,i,r,n){"use strict";return class{constructor(t,i,r){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=i,this._glyphSource=r,this._binPack=new e(t-4,i-4),this._glyphData.push(new Uint8Array(t*i)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,r){const n=[],a=this._glyphSource,o=new Set,s=1/256;for(const e of r){const t=Math.floor(e*s);o.add(t)}const l=[];return o.forEach((e=>{const t=i+e;if(this._rangePromises.has(t))l.push(this._rangePromises.get(t));else{const r=a.getRange(i,e).then((()=>{this._rangePromises.delete(t)}),(()=>{this._rangePromises.delete(t)}));this._rangePromises.set(t,r),l.push(r)}})),Promise.all(l).then((()=>{let o=this._glyphIndex[i];o||(o={},this._glyphIndex[i]=o);for(const s of r){const r=o[s];if(r){n[s]={sdf:!0,rect:r.rect,metrics:r.metrics,page:r.page,code:s};continue}const l=a.getGlyph(i,s);if(!l?.metrics)continue;const c=l.metrics;let u;if(0===c.width)u=new t(0,0,0,0);else{const t=3,i=c.width+2*t,r=c.height+2*t;let n=i%4?4-i%4:4,a=r%4?4-r%4:4;1===n&&(n=5),1===a&&(a=5),u=this._binPack.allocate(i+n,r+a),u.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new e(this.width-4,this.height-4),u=this._binPack.allocate(i+n,r+a));const o=this._glyphData[this._currentPage],s=l.bitmap;let h,p;if(s)for(let e=0;e<r;e++){h=i*e,p=this.width*(u.y+e+1)+u.x;for(let e=0;e<i;e++)o[p+e+1]=s.at(h+e)}}o[s]={rect:u,metrics:c,tileIDs:null,page:this._currentPage},n[s]={sdf:!0,rect:u,metrics:c,page:this._currentPage,code:s},this._dirties[this._currentPage]=!0}return n}))}removeGlyphs(e){for(const t in this._glyphIndex){const i=this._glyphIndex[t];if(!i)continue;let r;for(const t in i)if(r=i[t],r.tileIDs.delete(e),0===r.tileIDs.size){const e=this._glyphData[r.page],n=r.rect;let a,o;for(let t=0;t<n.height;t++)for(a=this.width*(n.y+t)+n.x,o=0;o<n.width;o++)e[a+o]=0;delete i[t],this._dirties[r.page]=!0}}}bind(e,t,a,o=0){if(!this._textures[a]){const t=new n.TextureDescriptor;t.pixelFormat=i.PixelFormat.ALPHA,t.wrapMode=i.TextureWrapMode.CLAMP_TO_EDGE,t.width=this.width,t.height=this.height,this._textures[a]=new r.Texture(e,t,new Uint8Array(this.width*this.height))}const s=this._textures[a];s.setSamplingMode(t),this._dirties[a]&&s.setData(this._glyphData[a]),e.bindTexture(s,o),this._dirties[a]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}}))},"esri/views/2d/engine/vectorTiles/RectangleBinPack":function(){define(["../webgl/Rect"],(function(e){"use strict";return class{constructor(t,i){this._width=0,this._height=0,this._free=[],this._width=t,this._height=i,this._free.push(new e(0,0,t,i))}get width(){return this._width}get height(){return this._height}allocate(t,i){if(t>this._width||i>this._height)return new e;let r=null,n=-1;for(let e=0;e<this._free.length;++e){const a=this._free[e];t<=a.width&&i<=a.height&&(null===r||a.y<=r.y&&a.x<=r.x)&&(r=a,n=e)}return null===r?new e:(this._free.splice(n,1),r.width<r.height?(r.width>t&&this._free.push(new e(r.x+t,r.y,r.width-t,i)),r.height>i&&this._free.push(new e(r.x,r.y+i,r.width,r.height-i))):(r.width>t&&this._free.push(new e(r.x+t,r.y,r.width-t,r.height)),r.height>i&&this._free.push(new e(r.x,r.y+i,t,r.height-i))),new e(r.x,r.y,t,i))}release(e){for(let t=0;t<this._free.length;++t){const i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}}}))},"esri/views/2d/engine/webgl/Rect":function(){define((function(){"use strict";return class{constructor(e=0,t=0,i=0,r=0){this.x=e,this.y=t,this.width=i,this.height=r}get isEmpty(){return this.width<=0||this.height<=0}union(e){this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.width=Math.max(this.width,e.width),this.height=Math.max(this.height,e.height)}}}))},"esri/views/2d/engine/vectorTiles/GlyphSource":function(){define(["../../../../request","../../../../core/pbf"],(function(e,t){"use strict";class i{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const t=new Map;let i=0;for(;e.next();)switch(e.tag()){case 1:{const r=e.getMessage();for(;r.next();)switch(r.tag()){case 3:{const e=r.getMessage();let n,a,o,s,l,c,u;for(;e.next();)switch(e.tag()){case 1:n=e.getUInt32();break;case 2:a=e.getBytes();break;case 3:o=e.getUInt32();break;case 4:s=e.getUInt32();break;case 5:l=e.getSInt32();break;case 6:c=e.getSInt32();break;case 7:u=e.getUInt32();break;default:e.skip()}if(e.release(),n){const e=a?.length??0;this._metrics[n]={width:o,height:s,left:l,top:c,advance:u,startOffset:i,length:e},t.set(n,a),i+=e}break}default:r.skip()}r.release();break}default:e.skip()}const r=new Uint8Array(i),n=this._metrics;for(const[e,i]of t){const{startOffset:t,length:a}=n[e];if(i)for(let e=0;e<a;++e)r[t+e]=i[e]}this._allBitmaps=r}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const t=this._metrics[e];if(void 0===t)return;const{startOffset:i,length:r}=t;return 0!==r?new n(this._allBitmaps,i,r):void 0}}class r{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(e){return this._ranges[e]}addRange(e,t){this._ranges[e]=t}}class n{constructor(e,t,i){this._array=e,this._start=t,this.length=i}at(e){return 0<=e&&e<this.length?this._array[this._start+e]:void 0}}return class{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(r,n){const a=this._getFontStack(r);if(a.getRange(n))return Promise.resolve();const o=256*n,s=o+255;if(this._baseURL){const l=this._baseURL.replace("{fontstack}",r).replace("{range}",o+"-"+s);return e(l,{responseType:"array-buffer"}).then((e=>{a.addRange(n,new i(new t(new Uint8Array(e.data),new DataView(e.data))))})).catch((()=>{a.addRange(n,new i)}))}return a.addRange(n,new i),Promise.resolve()}getGlyph(e,t){const i=this._getFontStack(e);if(!i)return;const r=Math.floor(t/256),n=i.getRange(r);return n?{metrics:n.getMetrics(t),bitmap:n.getBitmap(t)}:void 0}_getFontStack(e){let t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new r),t}}}))},"esri/views/2d/engine/vectorTiles/SpriteMosaic":function(){define(["../../../../core/has","../../../../symbols/cim/rasterizingUtils","./RectangleBinPack","../webgl/Rect","../../../webgl/enums","../../../webgl/Texture","../../../webgl/TextureDescriptor"],(function(e,t,i,r,n,a,o){"use strict";class s{constructor(e,t,r=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,r>0&&(this._maxItemSize=r),this._binPack=new i(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new i(this._pageWidth-4,this._pageHeight-4);const e=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),r=new Uint32Array(e*t);this._mosaicsData[0]=r,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let i,r,n=this._mosaicRects[e];if(n)return n;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(e&&e.startsWith("dasharray-")?([i,r]=this._rasterizeDash(e),t=!0):i=this._sprites.getSpriteInfo(e),!i?.width||!i.height||i.width<0||i.height<0)return null;const a=i.width,o=i.height,[s,l,c]=this._allocateImage(a,o);return s.width<=0?null:(this._copy(s,i,l,c,t,r),n={type:"sprite",rect:s,width:a,height:o,sdf:i.sdf,simplePattern:!1,rasterizationScale:i.pixelRatio??1,samplingMode:"Linear",page:l},this._mosaicRects[e]=n,n)}getSpriteItems(e){const t={};for(const i of e)t[i.name]=this.getSpriteItem(i.name,i.repeat);return t}getMosaicItemPosition(e,t){const i=this.getSpriteItem(e,t),r=i?.rect;if(!r)return null;r.width=i.width,r.height=i.height;const n=i.width,a=i.height;return{tl:[r.x+2,r.y+2],br:[r.x+2+n,r.y+2+a],page:i.page}}bind(e,t,i=0,r=0){if(i>=this._size.length||i>=this._mosaicsData.length)return;if(!this._textures[i]){const t=new o.TextureDescriptor;t.wrapMode=n.TextureWrapMode.CLAMP_TO_EDGE,t.width=this._size[i][0],t.height=this._size[i][1],this._textures[i]=new a.Texture(e,t,new Uint8Array(this._mosaicsData[i].buffer))}const s=this._textures[i];s.setSamplingMode(t),this._dirties[i]&&s.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(s,r),this._dirties[i]=!1}static _copyBits(e,t,i,r,n,a,o,s,l,c,u){let h=r*t+i,p=s*a+o;if(u){p-=a;for(let o=-1;o<=c;o++,h=((o+c)%c+r)*t+i,p+=a)for(let t=-1;t<=l;t++)n[p+t]=e[h+(t+l)%l]}else for(let i=0;i<c;i++){for(let t=0;t<l;t++)n[p+t]=e[h+t];h+=t,p+=a}}_copy(e,t,i,r,n,a){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const o=new Uint32Array(a?a.buffer:this._sprites.image.buffer),l=this._mosaicsData[i],c=a?t.width:this._sprites.width;s._copyBits(o,c,t.x,t.y,l,r[0],e.x+2,e.y+2,t.width,t.height,n),this._dirties[i]=!0}_allocateImage(e,t){e+=2,t+=2;const n=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<n){const i=new r(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[e,t]]}let a=e%4?4-e%4:4,o=t%4?4-t%4:4;1===a&&(a=5),1===o&&(o=5);const s=this._binPack.allocate(e+a,t+o);return s.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new i(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[s,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const i=e.match(/\[(.*?)\]/);if(!i)return null;const r=i[1].split(",").map(Number),n=e.slice(e.lastIndexOf("-")+1),[a,o,s]=t.rasterizeDash(r,n);return[{x:0,y:0,width:o,height:s,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}return s}))},"esri/symbols/cim/rasterizingUtils":function(){define(["exports","../../core/floatRGBA","../../core/Logger","../../core/mathUtils","./constants","./defaultCIMValues","../../views/2d/engine/webgl/definitions"],(function(e,t,i,r,n,a,o){"use strict";const s=()=>i.getLogger("esri.symbols.cim.rasterizingUtils");let l;function c(e){const t=[];switch(e.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{"CIMPolarContinuousColorRamp"===e.type&&s().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const i=e;t.push({offset:0,color:[i.fromColor[0],i.fromColor[1],i.fromColor[2],i.fromColor[3]/255]}),t.push({offset:1,color:[i.toColor[0],i.toColor[1],i.toColor[2],i.toColor[3]/255]});break}case"CIMFixedColorRamp":{const i=e,r=1/(i.colors.length-1);let n=0;for(const e of i.colors)t.push({offset:n,color:[e[0],e[1],e[2],e[3]/255]}),n+=r;break}case"CIMMultipartColorRamp":{const i=e,r=i.weights.reduce(((e,t)=>e+t),0);let n=0;for(let e=0;e<i.colorRamps.length;e++){const a=i.colorRamps[e],o=i.weights[e],s=c(a);for(const e of s)t.push({offset:(n+e.offset*o)/r,color:e.color});n+=o}break}default:s().error(`Color ramp "${e.type}" currently unsupported.`)}return t}function u(e,t){const i=[],r=(e.length-1)/(t-1);for(let n=0;n<t;n++){const a=e[Math.round(n*r)].color;i.push({offset:n/t,color:a}),i.push({offset:(n+1)/t,color:a})}return i}function h(e,t,i=0){for(const{offset:r,color:n}of t)e.addColorStop(Math.min(Math.max(r,i),1-i),`rgba(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`)}function p(e,t,i,r,n){const a=i+2*n;e.width=a,e.height=r;const o=(n+1)/a,s=e.getContext("2d",{willReadFrequently:!0});if(t.length>0){const e=s.createLinearGradient(0,0,a,r);h(e,t,o),s.fillStyle=e}else s.fillStyle="rgba(128, 128, 128, 1)";s.fillRect(0,0,a,r)}function d(e){const{width:t,height:i}=e,r=e.getContext("2d").getImageData(0,0,t,i),n=new Uint8Array(r.data);for(let e=0;e<n.length;e+=4){const t=n[e+3]/255;n[e]*=t,n[e+1]*=t,n[e+2]*=t}return[n,t,i]}e.addColorStops=function(e,t){const{colorRamp:i,gradientType:r}=t,n=c(i),o="CIMFixedColorRamp"===i.type;if("Continuous"===r&&!o)return h(e,n);const s=t.interval??a.defaultCIMValues.CIMGradientFill.interval;if(o)return h(e,u(n,s));const d=[];l??=document.createElement("canvas"),p(l,n,s,1,0);const y=l.getContext("2d").getImageData(0,0,s,1).data;for(let e=0,t=0;e<s;e++,t=4*e){const i=[y[t+0],y[t+1],y[t+2],y[t+3]];d.push({offset:e/s,color:i}),d.push({offset:(e+1)/s,color:i})}return h(e,d)},e.rasterizeDash=function(e,i){null==e&&(e=[]);const r="Butt"===i,a="Square"===i,o=!r&&!a;e.length%2==1&&(e=[...e,...e]);const s=n.dashRadius,l=2*s;let c=0;for(const t of e)c+=t;const u=Math.round(c*s),h=new Float32Array(u*l),p=.5*s;let d=0,y=0,f=.5,g=!0;for(const t of e){for(d=y,y+=t*s;f<=y;){let e=.5;for(;e<l;){const t=(e-.5)*u+f-.5,i=o?(e-s)*(e-s):Math.abs(e-s);h[t]=g?r?Math.max(Math.max(d+p-f,i),Math.max(f-y+p,i)):i:o?Math.min((f-d)*(f-d)+i,(f-y)*(f-y)+i):a?Math.min(Math.max(f-d,i),Math.max(y-f,i)):Math.min(Math.max(f-d+p,i),Math.max(y+p-f,i)),e++}f++}g=!g}const m=h.length,_=new Uint8Array(4*m);for(let e=0;e<m;++e){const i=(o?Math.sqrt(h[e]):h[e])/s;t.packFloatRGBA(i,_,4*e)}return[_,u,l]},e.rasterizeDash1D=function(e){e.length%2==1&&(e=[...e,...e]);const i=e.reduce(((e,t)=>e+t),0),r=Math.round(i*n.dashSdfRasterizationScale),a=new Float32Array(1*r);let o=0,s=0,l=.5,c=!0;for(const t of e){for(o=s,s+=t*n.dashSdfRasterizationScale;l<=s;){const e=l-.5,t=Math.min(Math.abs(l-o),Math.abs(l-s));a[e]=c?-t:t,l++}c=!c}const u=a.length,h=new Uint8Array(4*u);for(let e=0;e<u;++e){const i=a[e]/n.dashSdfRasterizationScale/n.dashSdfDistanceNormalization*.5+.5;t.packFloatRGBA(i,h,4*e)}return[h,r,1]},e.rasterizeFillStyle=function(e,t,i){const n=t.style,a=r.nextPowerOfTwo(Math.ceil(i)),o=(e=>"vertical"===e||"horizontal"===e||"cross"===e||"esriSFSCross"===e||"esriSFSVertical"===e||"esriSFSHorizontal"===e)(n)?8*a:16*a,s=2*a;e.width=o,e.height=o;const l=e.getContext("2d");l.strokeStyle="#ffffff",l.lineWidth=a,l.beginPath(),"vertical"!==n&&"cross"!==n&&"esriSFSCross"!==n&&"esriSFSVertical"!==n||(l.moveTo(o/2,-s),l.lineTo(o/2,o+s)),"horizontal"!==n&&"cross"!==n&&"esriSFSCross"!==n&&"esriSFSHorizontal"!==n||(l.moveTo(-s,o/2),l.lineTo(o+s,o/2)),"backward-diagonal"!==n&&"diagonal-cross"!==n&&"esriSFSDiagonalCross"!==n&&"esriSFSBackwardDiagonal"!==n||(l.moveTo(-s,-s),l.lineTo(o+s,o+s),l.moveTo(o-s,-s),l.lineTo(o+s,s),l.moveTo(-s,o-s),l.lineTo(s,o+s)),"forward-diagonal"!==n&&"diagonal-cross"!==n&&"esriSFSForwardDiagonal"!==n&&"esriSFSDiagonalCross"!==n||(l.moveTo(o+s,-s),l.lineTo(-s,o+s),l.moveTo(s,-s),l.lineTo(-s,s),l.moveTo(o+s,o-s),l.lineTo(o-s,o+s)),l.stroke();const c=l.getImageData(0,0,e.width,e.height),u=new Uint8Array(c.data);let h;for(let e=0;e<u.length;e+=4)h=u[e+3]/255,u[e]=u[e]*h,u[e+1]=u[e+1]*h,u[e+2]=u[e+2]*h;return[u,e.width,e.height,a]},e.rasterizeGradient=function(e,t){const{colorRamp:i,gradientType:r}=t,n="CIMFixedColorRamp"===i.type,s=t.interval||a.defaultCIMValues.CIMGradientFill.interval;let l=c(i);return n&&(l=u(l,s)),"Discrete"===r||n?function(e,t,i){return p(e,t,i,1,o.gradientTextureExternalPadding),d(e)}(e,l,s):function(e,t){return p(e,t,32,1,o.gradientTextureExternalPadding),d(e)}(e,l)},e.scale=function(e,t){const i=function(e){const t=e[0]?.[0]?.[0]??0,i=e[0]?.[0]?.[1]??0,r={ymin:i,xmin:t,ymax:i,xmax:t,width:0,height:0};for(let t=0;t<e.length;t++){const i=e[t];for(let e=0;e<i.length;e++){const t=i[e][0],n=i[e][1];t<r.xmin&&(r.xmin=t),t>r.xmax&&(r.xmax=t),n<r.ymin&&(r.ymin=n),n>r.ymax&&(r.ymax=n)}}return r.width=Math.abs(r.xmax-r.xmin),r.height=Math.abs(r.ymax-r.ymin),r}(e),r=0===i.width?1:i.width,n=0===i.height?1:i.height,a=[];for(let o=0;o<e.length;o++){const s=e[o],l=[];for(let e=0;e<s.length;e++){let a=Math.round(s[e][0]-i.xmin),o=Math.round(s[e][1]-i.ymin);if(a=t.xmin+a*t.width/r,o=t.ymin+o*t.height/n,isNaN(a)||isNaN(o))throw new Error("Scaled shape has NaN values");l.push([a,o])}a.push(l)}return a},e.translate=function(e,t,i){const r=[];for(let n=0;n<e.length;n++){const a=e[n],o=[];for(let e=0;e<a.length;e++){const r=a[e][0]+t,n=a[e][1]+i;if(isNaN(r)||isNaN(n))throw new Error("Scaled shape has NaN values");o.push([r,n])}r.push(o)}return r},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/symbols/cim/constants":function(){define(["exports","./defaultCIMValues"],(function(e,t){"use strict";const i={outlineWidth:.75,referenceWidth:.75,cap:t.defaultCIMValues.CIMSolidStroke.capstyle,join:t.defaultCIMValues.CIMSolidStroke.joinstyle,miterLimit:t.defaultCIMValues.CIMSolidStroke.miterlimit};e.antialiasingOutlineFillSettings=i,e.dashRadius=15.5,e.dashSdfDistanceNormalization=64,e.dashSdfRasterizationScale=4,e.maxTileCoordValue=1024,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/tiling/TileInfoViewPOT":function(){define(["../../../layers/support/TileInfo","./TileInfoView","./TileKey"],(function(e,t,i){"use strict";return class extends t{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const t=i.pool.acquire(e),r=0===t.level?null:i.getId(t.level-1,t.row>>1,t.col>>1,t.world);return i.pool.release(t),r}getTileCoverage(e,t,i=!0,r){const n=super.getTileCoverage(e,t,i,r);if(!n)return n;const a=1<<n.lodInfo.level;return n.spans=n.spans.filter((e=>e.row>=0&&e.row<a)),n}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const t=this._fullCacheLodInfos;if(e>t[0].scale)return t[0].level;let i,r;for(let n=0;n<t.length-1;n++)if(r=t[n+1],e>r.scale)return i=t[n],i.level+(i.scale-e)/(i.scale-r.scale);return t[t.length-1].level}}_initializeFullCacheLODs(t){let i;if(0===t[0].level)i=t.map((e=>({level:e.level,resolution:e.resolution,scale:e.scale})));else{const t=this.tileInfo.size[0],r=this.tileInfo.spatialReference;i=e.create({size:t,spatialReference:r}).lods.map((e=>({level:e.level,resolution:e.resolution,scale:e.scale})))}for(let e=0;e<i.length;e++)this._levelByScale[i[e].scale]=i[e].level;this._fullCacheLodInfos=i}}}))},"esri/views/2d/engine/vectorTiles/VTLPainter3D":function(){define(["../../../../core/maybe","../vtlBrushes","./shaders/VTLMaterialManager","./style/StyleDefinition","../../../webgl/enums"],(function(e,t,i,r,n){"use strict";const a=1e-6,o=[null];return class{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new i}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=e.disposeMaybe(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,i,n){const s=n.layers;e.renderPass="translucent";let l=this._brushCache.vtlSymbol;null==l&&(l=new t.vtlBrushes.vtlSymbol,this._brushCache.vtlSymbol=l),o[0]=i;for(let t=0;t<s.length;t++){const i=s[t];if(i.type!==r.StyleLayerType.SYMBOL)continue;const n=i.getLayoutProperty("visibility");if(n&&n.getValue()===r.Visibility.NONE)continue;const c=e.displayLevel;void 0!==i.minzoom&&i.minzoom>c+a||void 0!==i.maxzoom&&i.maxzoom<=c-a||(e.styleLayerUID=i.uid,e.styleLayer=i,l.drawMany(e,o))}o[0]=null}drawBackground(e,i,n){if(0===n.backgroundBucketIds.length)return;const{context:s,displayLevel:l,requiredLevel:c}=e;i.key.level=c,s.setBlendingEnabled(!0),s.setDepthTestEnabled(!1),s.setStencilTestEnabled(!1),e.renderPass="background";let u=this._brushCache.vtlBackground;null==u&&(u=new t.vtlBrushes.vtlBackground,this._brushCache.vtlBackground=u),o[0]=i,n.backgroundBucketIds.forEach((t=>{const i=n.getLayerById(t);if(i.type!==r.StyleLayerType.BACKGROUND)return;const s=i.getLayoutProperty("visibility");s&&s.getValue()===r.Visibility.NONE||void 0!==i.minzoom&&i.minzoom>l+a||void 0!==i.maxzoom&&i.maxzoom<=l-a||(e.styleLayerUID=i.uid,e.styleLayer=i,u.drawMany(e,o))})),o[0]=null}drawTile(e,t,i,a){const{context:o}=e,s=i.layers;o.setBlendingEnabled(!1),o.setDepthTestEnabled(!0),o.setDepthWriteEnabled(!0),o.setDepthFunction(n.CompareFunction.LEQUAL);const l=s.filter((e=>{if(null!=a&&a!==e.type||!t.layerData.has(e.uid))return!1;const i=e.getLayoutProperty("visibility");return i?.getValue()!==r.Visibility.NONE}));e.renderPass="opaque";for(let i=l.length-1;i>=0;--i)this._renderStyleLayer(l[i],e,t);o.setDepthWriteEnabled(!1),o.setBlendingEnabled(!0),o.setBlendFunctionSeparate(n.BlendFactor.ONE,n.BlendFactor.ONE_MINUS_SRC_ALPHA,n.BlendFactor.ONE,n.BlendFactor.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent",l.forEach((i=>this._renderStyleLayer(i,e,t))),o.setDepthTestEnabled(!1),o.bindVAO()}_renderStyleLayer(e,i,n){const{renderPass:s}=i;let l;switch(e.type){case r.StyleLayerType.BACKGROUND:if("background"!==s)return;l=this._brushCache.vtlBackground,l||(l=new t.vtlBrushes.vtlBackground,this._brushCache.vtlBackground=l);break;case r.StyleLayerType.FILL:if("opaque"!==s&&"translucent"!==i.renderPass)return;l=this._brushCache.vtlFill,null==l&&(l=new t.vtlBrushes.vtlFill,this._brushCache.vtlFill=l);break;case r.StyleLayerType.LINE:if("translucent"!==s)return;l=this._brushCache.vtlLine,null==l&&(l=new t.vtlBrushes.vtlLine,this._brushCache.vtlLine=l);break;case r.StyleLayerType.CIRCLE:if("translucent"!==s)return;l=this._brushCache.vtlCircle,null==l&&(l=new t.vtlBrushes.vtlCircle,this._brushCache.vtlCircle=l);break;case r.StyleLayerType.SYMBOL:if("translucent"!==s)return;l=this._brushCache.vtlSymbol,null==l&&(l=new t.vtlBrushes.vtlSymbol,this._brushCache.vtlSymbol=l)}const{displayLevel:c}=i,{minzoom:u,maxzoom:h}=e;if(void 0!==u&&u>c+a||void 0!==h&&h<=c-a)return;const{context:p}=i;p.setStencilTestEnabled(!1),p.setStencilWriteMask(0),i.styleLayerUID=e.uid,i.styleLayer=e,o[0]=n,l.drawMany(i,o),o[0]=null}}}))},"esri/views/2d/engine/vtlBrushes":function(){define(["exports","./webgl/brushes/WGLBrushVTLBackground","./webgl/brushes/WGLBrushVTLCircle","./webgl/brushes/WGLBrushVTLFill","./webgl/brushes/WGLBrushVTLLine","./webgl/brushes/WGLBrushVTLSymbol"],(function(e,t,i,r,n,a){"use strict";const o={vtlBackground:t.WGLBrushVTLBackground,vtlFill:r.WGLBrushVTLFill,vtlLine:n.WGLBrushVTLLine,vtlCircle:i.WGLBrushVTLCircle,vtlSymbol:a.WGLBrushVTLSymbol};e.vtlBrushes=o,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/brushes/WGLBrushVTLBackground":function(){define(["exports","../../../../../core/mathUtils","../../../../../core/libs/gl-matrix-2/factories/mat3f32","../../../../../core/libs/gl-matrix-2/factories/vec4f32","../definitions","./WGLBrush","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,i,r,n,a,o,s,l){"use strict";e.WGLBrushVTLBackground=class extends a{constructor(){super(...arguments),this._color=r.fromValues(1,0,0,1),this._patternMatrix=i.create(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,i){const{context:r,painter:a,requestRender:o,allowDelayedRender:l}=e;this._loadWGLResources(e);const c=e.displayLevel,u=e.styleLayer,h=u.backgroundMaterial,p=a.vectorTilesMaterialManager,d=u.getPaintValue("background-color",c),y=u.getPaintValue("background-opacity",c),f=u.getPaintValue("background-pattern",c),g=void 0!==f,m=1|window.devicePixelRatio,_=e.spriteMosaic;let v,T;const w=m>n.vtlHighResCutoff?2:1,b=this._programOptions;b.pattern=g;const x=p.getMaterialProgram(r,h,b);if(!l||null==o||x.compiled){if(r.bindVAO(this._vao),r.useProgram(x),g){const e=_.getMosaicItemPosition(f,!0);if(null!=e){const{tl:t,br:i,page:a}=e;v=i[0]-t[0],T=i[1]-t[1];const o=_.getPageSize(a);null!=o&&(_.bind(r,s.TextureSamplingMode.LINEAR,a,n.vtlTextureBindingUnitSprites),x.setUniform4f("u_tlbr",t[0],t[1],i[0],i[1]),x.setUniform2fv("u_mosaicSize",o),x.setUniform1i("u_texture",n.vtlTextureBindingUnitSprites))}x.setUniform1f("u_opacity",y)}else{const e=d[3]*y;this._color[0]=e*d[0],this._color[1]=e*d[1],this._color[2]=e*d[2],this._color[3]=e,x.setUniform4fv("u_color",this._color)}x.setUniform1f("u_depth",u.z||0);for(const e of i){if(x.setUniform1f("u_coord_range",e.rangeX),x.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),g){const i=Math.max(2**(Math.round(c)-e.key.level),1),r=w*e.width*i,n=r/t.nextPowerOfTwo(v),a=r/t.nextPowerOfTwo(T);this._patternMatrix[0]=n,this._patternMatrix[4]=a,x.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}r.setStencilFunction(s.CompareFunction.EQUAL,0,255),r.drawArrays(s.PrimitiveType.TRIANGLE_STRIP,0,4)}}else o()}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,r=i.backgroundMaterial,n=new Int8Array([0,0,1,0,0,1,1,1]),a=o.BufferObject.createVertex(t,s.Usage.STATIC_DRAW,n),c=new l.VertexArrayObject(t,r.getAttributeLocations(),r.getLayoutInfo(),new Map([["geometry",a]]));this._vao=c}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/brushes/WGLBrush":function(){define((function(){"use strict";return class{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,t){}draw(e,t,i){}drawMany(e,t,i){for(const r of t)r.visible&&this.draw(e,r,i)}}}))},"esri/views/2d/engine/webgl/brushes/WGLBrushVTLCircle":function(){define(["exports","../../vectorTiles/style/StyleDefinition","./WGLBrush","../../../../webgl/enums"],(function(e,t,i,r){"use strict";e.WGLBrushVTLCircle=class extends i{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,i){const{context:n,displayLevel:a,requiredLevel:o,state:s,painter:l,spriteMosaic:c,styleLayerUID:u,requestRender:h,allowDelayedRender:p}=e;if(!i.some((e=>e.layerData.get(u)?.circleIndexCount??!1)))return;const d=e.styleLayer,y=d.circleMaterial,f=l.vectorTilesMaterialManager,g=d.getPaintValue("circle-translate",a),m=d.getPaintValue("circle-translate-anchor",a),_=this._programOptions,v=f.getMaterialProgram(n,y,_);if(p&&null!=h&&!v.compiled)return void h();n.useProgram(v),v.setUniformMatrix3fv("u_displayMat3",m===t.TranslateAnchor.VIEWPORT?s.displayMat3:s.displayViewMat3),v.setUniform2fv("u_circleTranslation",g),v.setUniform1f("u_depth",d.z),v.setUniform1f("u_antialiasingWidth",1.2);let T=-1;for(const e of i){if(!e.layerData.has(u))continue;e.key.level!==T&&(T=e.key.level,y.setDataUniforms(v,a,d,T,c));const t=e.layerData.get(u);if(!t.circleIndexCount)continue;t.prepareForRendering(n);const i=t.vao;null!=i&&(n.bindVAO(i),v.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),o!==e.key.level?n.setStencilFunction(r.CompareFunction.EQUAL,e.stencilRef,255):n.setStencilFunction(r.CompareFunction.GREATER,255,255),n.drawElements(r.PrimitiveType.TRIANGLES,t.circleIndexCount,r.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.circleIndexStart),e.triangleCount+=t.circleIndexCount/3)}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/brushes/WGLBrushVTLFill":function(){define(["exports","../../vectorTiles/style/StyleDefinition","../definitions","./WGLBrush","../../../../webgl/enums"],(function(e,t,i,r,n){"use strict";const a=1/65536;e.WGLBrushVTLFill=class extends r{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,renderPass:r,spriteMosaic:n,styleLayerUID:a}=e;let o=!1;for(const e of t)if(e.layerData.has(a)){const t=e.layerData.get(a);if(t.fillIndexCount>0||t.outlineIndexCount>0){o=!0;break}}if(!o)return;const s=e.styleLayer,l=s.getPaintProperty("fill-pattern"),c=void 0!==l,u=c&&l.isDataDriven;let h;if(c&&!u){const e=l.getValue(i);h=n.getMosaicItemPosition(e,!0)}const p=!c&&s.getPaintValue("fill-antialias",i);let d=!0,y=1;if(!c){const e=s.getPaintProperty("fill-color"),t=s.getPaintProperty("fill-opacity");if(!e?.isDataDriven&&!t?.isDataDriven){const e=s.getPaintValue("fill-color",i);y=s.getPaintValue("fill-opacity",i)*e[3],y>=1&&(d=!1)}}if(d&&"opaque"===r)return;const f=s.getPaintValue("fill-translate",i),g=s.getPaintValue("fill-translate-anchor",i);(d||"translucent"!==r)&&this._drawFill(e,a,s,t,f,g,c,h,u);const m=!s.hasDataDrivenOutlineColor&&s.outlineUsesFillColor&&y<1;p&&"opaque"!==r&&!m&&this._drawOutline(e,a,s,t,f,g)}_drawFill(e,r,o,s,l,c,u,h,p){if(u&&!p&&null==h)return;const{context:d,displayLevel:y,state:f,painter:g,pixelRatio:m,spriteMosaic:_,requestRender:v,allowDelayedRender:T}=e,w=o.fillMaterial,b=g.vectorTilesMaterialManager,x=m>i.vtlHighResCutoff?2:1,S=this._fillProgramOptions;S.pattern=u;const E=b.getMaterialProgram(d,w,S);if(T&&null!=v&&!E.compiled)return void v();if(d.useProgram(E),null!=h){const{page:e}=h,t=_.getPageSize(e);null!=t&&(_.bind(d,n.TextureSamplingMode.LINEAR,e,i.vtlTextureBindingUnitSprites),E.setUniform2fv("u_mosaicSize",t),E.setUniform1i("u_texture",i.vtlTextureBindingUnitSprites))}E.setUniformMatrix3fv("u_displayMat3",c===t.TranslateAnchor.VIEWPORT?f.displayMat3:f.displayViewMat3),E.setUniform2fv("u_fillTranslation",l),E.setUniform1f("u_depth",o.z+a);let D=-1;for(const e of s){if(!e.layerData.has(r))continue;e.key.level!==D&&(D=e.key.level,w.setDataUniforms(E,y,o,D,_));const t=e.layerData.get(r);if(!t.fillIndexCount)continue;t.prepareForRendering(d);const a=t.fillVAO;if(null!=a){if(d.bindVAO(a),E.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),d.setStencilFunction(n.CompareFunction.EQUAL,e.stencilRef,255),u){const t=Math.max(2**(Math.round(y)-e.key.level),1),i=e.rangeX/(x*e.width*t);E.setUniform1f("u_patternFactor",i)}if(p){const e=t.patternMap;if(!e)continue;for(const[t,r]of e){const e=_.getPageSize(t);null!=e&&(_.bind(d,n.TextureSamplingMode.LINEAR,t,i.vtlTextureBindingUnitSprites),E.setUniform2fv("u_mosaicSize",e),E.setUniform1i("u_texture",i.vtlTextureBindingUnitSprites),d.drawElements(n.PrimitiveType.TRIANGLES,r[1],n.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*r[0]))}}else d.drawElements(n.PrimitiveType.TRIANGLES,t.fillIndexCount,n.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.fillIndexStart);e.triangleCount+=t.fillIndexCount/3}}}_drawOutline(e,i,r,o,s,l){const{context:c,displayLevel:u,state:h,painter:p,pixelRatio:d,spriteMosaic:y,requestRender:f,allowDelayedRender:g}=e,m=r.outlineMaterial,_=p.vectorTilesMaterialManager,v=.75/d,T=this._outlineProgramOptions,w=_.getMaterialProgram(c,m,T);if(g&&null!=f&&!w.compiled)return void f();c.useProgram(w),w.setUniformMatrix3fv("u_displayMat3",l===t.TranslateAnchor.VIEWPORT?h.displayMat3:h.displayViewMat3),w.setUniform2fv("u_fillTranslation",s),w.setUniform1f("u_depth",r.z+a),w.setUniform1f("u_outline_width",v);let b=-1;for(const e of o){if(!e.layerData.has(i))continue;e.key.level!==b&&(b=e.key.level,m.setDataUniforms(w,u,r,b,y));const t=e.layerData.get(i);if(t.prepareForRendering(c),!t.outlineIndexCount)continue;const a=t.outlineVAO;null!=a&&(c.bindVAO(a),w.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),c.setStencilFunction(n.CompareFunction.EQUAL,e.stencilRef,255),c.drawElements(n.PrimitiveType.TRIANGLES,t.outlineIndexCount,n.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.outlineIndexStart),e.triangleCount+=t.outlineIndexCount/3)}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/brushes/WGLBrushVTLLine":function(){define(["exports","../../vectorTiles/style/StyleDefinition","../definitions","./WGLBrush","../../../../webgl/enums"],(function(e,t,i,r,n){"use strict";e.WGLBrushVTLLine=class extends r{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,r){const{context:a,displayLevel:o,state:s,painter:l,pixelRatio:c,spriteMosaic:u,styleLayerUID:h,requestRender:p,allowDelayedRender:d}=e;if(!r.some((e=>e.layerData.get(h)?.lineIndexCount??!1)))return;const y=e.styleLayer,f=y.lineMaterial,g=l.vectorTilesMaterialManager,m=y.getPaintValue("line-translate",o),_=y.getPaintValue("line-translate-anchor",o),v=y.getPaintProperty("line-pattern"),T=void 0!==v,w=T&&v.isDataDriven;let b,x;if(T&&!w){const e=v.getValue(o);b=u.getMosaicItemPosition(e)}let S=!1;if(!T){const e=y.getPaintProperty("line-dasharray");if(x=void 0!==e,S=x&&e.isDataDriven,x&&!S){const t=e.getValue(o),i=y.getDashKey(t,y.getLayoutValue("line-cap",o));b=u.getMosaicItemPosition(i)}}const E=1/c,D=this._programOptions;D.pattern=T,D.sdf=x;const P=g.getMaterialProgram(a,f,D);if(d&&null!=p&&!P.compiled)return void p();if(a.useProgram(P),P.setUniformMatrix3fv("u_displayViewMat3",s.displayViewMat3),P.setUniformMatrix3fv("u_displayMat3",_===t.TranslateAnchor.VIEWPORT?s.displayMat3:s.displayViewMat3),P.setUniform2fv("u_lineTranslation",m),P.setUniform1f("u_depth",y.z),P.setUniform1f("u_antialiasing",E),b&&null!=b){const{page:e}=b,t=u.getPageSize(e);null!=t&&(u.bind(a,n.TextureSamplingMode.LINEAR,e,i.vtlTextureBindingUnitSprites),P.setUniform2fv("u_mosaicSize",t),P.setUniform1i("u_texture",i.vtlTextureBindingUnitSprites))}let L=-1;for(const e of r){if(!e.layerData.has(h))continue;e.key.level!==L&&(L=e.key.level,f.setDataUniforms(P,o,y,L,u));const t=2**(o-L)/c;P.setUniform1f("u_zoomFactor",t);const r=e.layerData.get(h);if(!r.lineIndexCount)continue;r.prepareForRendering(a);const s=r.vao;if(null!=s){if(a.bindVAO(s),P.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),a.setStencilFunction(n.CompareFunction.EQUAL,e.stencilRef,255),w||S){const e=r.patternMap;if(!e)continue;for(const[t,r]of e){const e=u.getPageSize(t);null!=e&&(u.bind(a,n.TextureSamplingMode.LINEAR,t,i.vtlTextureBindingUnitSprites),P.setUniform2fv("u_mosaicSize",e),P.setUniform1i("u_texture",i.vtlTextureBindingUnitSprites),a.drawElements(n.PrimitiveType.TRIANGLES,r[1],n.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*r[0]))}}else a.drawElements(n.PrimitiveType.TRIANGLES,r.lineIndexCount,n.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*r.lineIndexStart);e.triangleCount+=r.lineIndexCount/3}}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/brushes/WGLBrushVTLSymbol":function(){define(["exports","../../../../../core/libs/gl-matrix-2/factories/vec2f32","../../vectorTiles/decluttering/config","../../vectorTiles/style/StyleDefinition","../definitions","../GeometryUtils","./WGLBrush","../../../../webgl/enums"],(function(e,t,i,r,n,a,o,s){"use strict";const l=1/65536;e.WGLBrushVTLSymbol=class extends o{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=t.create()}dispose(){}drawMany(e,t){const i=e.styleLayer;this._drawIcons(e,i,t),this._drawText(e,i,t)}_drawIcons(e,t,o){const{context:s,displayLevel:l,painter:c,spriteMosaic:u,state:h,styleLayerUID:p,requestRender:d,allowDelayedRender:y}=e,f=t.iconMaterial,g=c.vectorTilesMaterialManager;let m,_=!1;for(const e of o)if(e.layerData.has(p)&&(m=e.layerData.get(p),m.iconPerPageElementsMap.size>0)){_=!0;break}if(!_)return;const v=t.getPaintValue("icon-translate",l),T=t.getPaintValue("icon-translate-anchor",l);let w=t.getLayoutValue("icon-rotation-alignment",l);w===r.RotationAlignment.AUTO&&(w=t.getLayoutValue("symbol-placement",l)===r.SymbolPlacement.POINT?r.RotationAlignment.VIEWPORT:r.RotationAlignment.MAP);const b=w===r.RotationAlignment.MAP,x=t.getLayoutValue("icon-keep-upright",l)&&b,S=m.isIconSDF,E=this._iconProgramOptions;E.sdf=S;const D=g.getMaterialProgram(s,f,E);if(y&&null!=d&&!D.compiled)return void d();s.useProgram(D),D.setUniformMatrix3fv("u_displayViewMat3",w===r.RotationAlignment.MAP?h.displayViewMat3:h.displayMat3),D.setUniformMatrix3fv("u_displayMat3",T===r.TranslateAnchor.VIEWPORT?h.displayMat3:h.displayViewMat3),D.setUniform2fv("u_iconTranslation",v),D.setUniform1f("u_depth",t.z),D.setUniform1f("u_mapRotation",a.degToByte(h.rotation)),D.setUniform1f("u_keepUpright",x?1:0),D.setUniform1f("u_level",10*l),D.setUniform1i("u_texture",n.vtlTextureBindingUnitSprites),D.setUniform1f("u_fadeDuration",i.fadeDuration/1e3);let P=-1;for(const i of o){if(!i.layerData.has(p))continue;if(i.key.level!==P&&(P=i.key.level,f.setDataUniforms(D,l,t,P,u)),m=i.layerData.get(p),0===m.iconPerPageElementsMap.size)continue;m.prepareForRendering(s),m.updateOpacityInfo();const r=m.iconVAO;if(null!=r){s.bindVAO(r),D.setUniformMatrix3fv("u_dvsMat3",i.transforms.displayViewScreenMat3),D.setUniform1f("u_time",(performance.now()-m.lastOpacityUpdate)/1e3);for(const[t,r]of m.iconPerPageElementsMap)this._renderIconRange(e,D,r,t,i)}}}_renderIconRange(e,t,i,r,a){const{context:o,spriteMosaic:l}=e;this._spritesTextureSize[0]=l.getWidth(r)/4,this._spritesTextureSize[1]=l.getHeight(r)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),l.bind(o,s.TextureSamplingMode.LINEAR,r,n.vtlTextureBindingUnitSprites),this._setStencilState(e,a),o.drawElements(s.PrimitiveType.TRIANGLES,i[1],s.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),a.triangleCount+=i[1]/3}_drawText(e,o,s){const{context:c,displayLevel:u,glyphMosaic:h,painter:p,pixelRatio:d,spriteMosaic:y,state:f,styleLayerUID:g,requestRender:m,allowDelayedRender:_}=e,v=o.textMaterial,T=p.vectorTilesMaterialManager;let w,b=!1;for(const e of s)if(e.layerData.has(g)&&(w=e.layerData.get(g),w.glyphPerPageElementsMap.size>0)){b=!0;break}if(!b)return;const x=o.getPaintProperty("text-opacity");if(x&&!x.isDataDriven&&0===x.getValue(u))return;const S=o.getPaintProperty("text-color"),E=!S||S.isDataDriven||S.getValue(u)[3]>0,D=o.getPaintProperty("text-halo-width"),P=o.getPaintProperty("text-halo-color"),L=(!D||D.isDataDriven||D.getValue(u)>0)&&(!P||P.isDataDriven||P.getValue(u)[3]>0);if(!E&&!L)return;let I=o.getLayoutValue("text-rotation-alignment",u);I===r.RotationAlignment.AUTO&&(I=o.getLayoutValue("symbol-placement",u)===r.SymbolPlacement.POINT?r.RotationAlignment.VIEWPORT:r.RotationAlignment.MAP);const R=I===r.RotationAlignment.MAP,M=o.getLayoutValue("text-keep-upright",u)&&R,A=.8*3/d;this._glyphTextureSize||(this._glyphTextureSize=t.fromValues(h.width/4,h.height/4));const N=o.getPaintValue("text-translate",u),U=o.getPaintValue("text-translate-anchor",u),C=this._sdfProgramOptions,V=T.getMaterialProgram(c,v,C);if(_&&null!=m&&!V.compiled)return void m();c.useProgram(V),V.setUniformMatrix3fv("u_displayViewMat3",I===r.RotationAlignment.MAP?f.displayViewMat3:f.displayMat3),V.setUniformMatrix3fv("u_displayMat3",U===r.TranslateAnchor.VIEWPORT?f.displayMat3:f.displayViewMat3),V.setUniform2fv("u_textTranslation",N),V.setUniform1f("u_depth",o.z+l),V.setUniform2fv("u_mosaicSize",this._glyphTextureSize),V.setUniform1f("u_mapRotation",a.degToByte(f.rotation)),V.setUniform1f("u_keepUpright",M?1:0),V.setUniform1f("u_level",10*u),V.setUniform1i("u_texture",n.vtlTextureBindingUnitGlyphs),V.setUniform1f("u_antialiasingWidth",A),V.setUniform1f("u_fadeDuration",i.fadeDuration/1e3);let O=-1;for(const t of s){if(!t.layerData.has(g))continue;if(t.key.level!==O&&(O=t.key.level,v.setDataUniforms(V,u,o,O,y)),w=t.layerData.get(g),0===w.glyphPerPageElementsMap.size)continue;w.prepareForRendering(c),w.updateOpacityInfo();const i=w.textVAO;if(null==i)continue;c.bindVAO(i),V.setUniformMatrix3fv("u_dvsMat3",t.transforms.displayViewScreenMat3),this._setStencilState(e,t);const r=(performance.now()-w.lastOpacityUpdate)/1e3;V.setUniform1f("u_time",r),w.glyphPerPageElementsMap.forEach(((e,i)=>{this._renderGlyphRange(c,e,i,h,V,L,E,t)}))}}_renderGlyphRange(e,t,i,r,a,o,l,c){r.bind(e,s.TextureSamplingMode.LINEAR,i,n.vtlTextureBindingUnitGlyphs),o&&(a.setUniform1f("u_halo",1),e.drawElements(s.PrimitiveType.TRIANGLES,t[1],s.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),c.triangleCount+=t[1]/3),l&&(a.setUniform1f("u_halo",0),e.drawElements(s.PrimitiveType.TRIANGLES,t[1],s.DataType.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),c.triangleCount+=t[1]/3)}_setStencilState(e,t){const{context:i,is3D:r,stencilSymbols:n}=e;if(i.setStencilTestEnabled(!0),n)return i.setStencilWriteMask(255),void i.setStencilFunction(s.CompareFunction.ALWAYS,t.stencilRef,255);i.setStencilWriteMask(0),r?i.setStencilFunction(s.CompareFunction.EQUAL,t.stencilRef,255):i.setStencilFunction(s.CompareFunction.GREATER,255,255)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/webgl/GeometryUtils":function(){define(["exports"],(function(e){"use strict";const t=128/Math.PI,i=256/360,r=1/Math.LN2;function n(e,t){return(e%=t)>=0?e:e+t}e.between=function(e,t,i){return e>=t&&e<=i||e>=i&&e<=t},e.degToByte=function(e){return n(e*i,256)},e.interpolate=function(e,t,i){return e*(1-i)+t*i},e.log2=function(e){return Math.log(e)*r},e.positiveMod=n,e.radToByte=function(e){return n(e*t,256)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLMaterialManager":function(){define(["../enums","./Programs"],(function(e,t){"use strict";return class{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,t,i){const r=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(r))return this._programByKey.get(r);const n=this._getProgramTemplate(t.type),{shaders:a}=n,{vertexShader:o,fragmentShader:s}=a(i),l=t.getShaderHeader(),c=t.getShaderMain(),u=o.replace("#pragma header",l).replace("#pragma main",c),h=e.programCache.acquire(u,s,t.getAttributeLocations());return this._programByKey.set(r,h),h}_getMaterialOptionsValue(t,i){switch(t){case e.ShaderProgramType.BACKGROUND:case e.ShaderProgramType.FILL:return(i.pattern?1:0)<<1;case e.ShaderProgramType.OUTLINE:return 0;case e.ShaderProgramType.LINE:{const e=i;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1}case e.ShaderProgramType.ICON:return(i.sdf?1:0)<<1;case e.ShaderProgramType.CIRCLE:case e.ShaderProgramType.TEXT:default:return 0}}_getProgramTemplate(i){switch(i){case e.ShaderProgramType.BACKGROUND:return t.background;case e.ShaderProgramType.CIRCLE:return t.circle;case e.ShaderProgramType.FILL:return t.fill;case e.ShaderProgramType.ICON:return t.icon;case e.ShaderProgramType.LINE:return t.line;case e.ShaderProgramType.OUTLINE:return t.outline;case e.ShaderProgramType.TEXT:return t.text;default:return null}}}}))},"esri/views/2d/engine/vectorTiles/shaders/Programs":function(){define(["exports","./sources/resolver","../../../../webgl/programUtils"],(function(e,t,i){"use strict";const r=e=>i.glslifyDefineMap({PATTERN:e.pattern}),n={shaders:e=>({vertexShader:r(e)+t.resolveIncludes("background/background.vert"),fragmentShader:r(e)+t.resolveIncludes("background/background.frag")})},a={shaders:e=>({vertexShader:t.resolveIncludes("circle/circle.vert"),fragmentShader:t.resolveIncludes("circle/circle.frag")})},o=e=>i.glslifyDefineMap({PATTERN:e.pattern}),s={shaders:e=>({vertexShader:o(e)+t.resolveIncludes("fill/fill.vert"),fragmentShader:o(e)+t.resolveIncludes("fill/fill.frag")})},l={shaders:e=>({vertexShader:t.resolveIncludes("outline/outline.vert"),fragmentShader:t.resolveIncludes("outline/outline.frag")})},c=e=>i.glslifyDefineMap({SDF:e.sdf}),u={shaders:e=>({vertexShader:c(e)+t.resolveIncludes("icon/icon.vert"),fragmentShader:c(e)+t.resolveIncludes("icon/icon.frag")})},h=e=>i.glslifyDefineMap({PATTERN:e.pattern,SDF:e.sdf}),p={shaders:e=>({vertexShader:h(e)+t.resolveIncludes("line/line.vert"),fragmentShader:h(e)+t.resolveIncludes("line/line.frag")})},d={shaders:e=>({vertexShader:t.resolveIncludes("text/text.vert"),fragmentShader:t.resolveIncludes("text/text.frag")})};e.background=n,e.circle=a,e.fill=s,e.icon=u,e.line=p,e.outline=l,e.text=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/sources/resolver":function(){define(["exports","./shaderRepository","../../../../../webgl/ShaderCompiler"],(function(e,t,i){"use strict";const r=new i.ShaderCompiler((function(e){let i=t;return e.split("/").forEach((e=>{i&&(i=i[e])})),i}));e.resolveIncludes=function(e){return r.resolveIncludes(e)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/sources/shaderRepository":function(){define((function(){"use strict";return{background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}}}))},"esri/views/webgl/ShaderCompiler":function(){define(["exports"],(function(e){"use strict";e.ShaderCompiler=class{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,t=new Map){if(t.has(e))return t.get(e);const i=this._read(e);if(!i)throw new Error(`cannot find shader file ${e}`);const r=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let n=r.exec(i);const a=[];for(;null!=n;)a.push({path:n[1],start:n.index,length:n[0].length}),n=r.exec(i);let o=0,s="";return a.forEach((e=>{s+=i.slice(o,e.start),s+=t.has(e.path)?"":this._resolve(e.path,t),o=e.start+e.length})),s+=i.slice(o),t.set(e,s),s}_read(e){return this._readFile(e)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/webgl/programUtils":function(){define(["exports"],(function(e){"use strict";function t(e){const{options:t,value:i}=e;return"number"==typeof t[i]}e.glslifyDefineMap=function(e){let i="";for(const r in e){const n=e[r];if("boolean"==typeof n)n&&(i+=`#define ${r}\n`);else if("number"==typeof n)i+=`#define ${r} ${n.toFixed()}\n`;else if("object"==typeof n)if(t(n)){const{value:e,options:t,namespace:a}=n,o=a?`${a}_`:"";for(const e in t)i+=`#define ${o}${e} ${t[e].toFixed()}\n`;i+=`#define ${r} ${o}${e}\n`}else{const e=n.options;let t=0;for(const r in e)i+=`#define ${e[r]} ${(t++).toFixed()}\n`;i+=`#define ${r} ${e[n.value]}\n`}}return i},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/style/StyleRepository":function(){define(["../../../../../core/lang","./StyleDefinition","./StyleLayer"],(function(e,t,i){"use strict";class r{constructor(i,r=!0){if(this.backgroundBucketIds=[],this._uidToLayer=new Map,this._layerByName={},this._runningId=0,this._style=r?e.clone(i):i,this._style.layers||(this._style.layers=[]),this.version=parseFloat(this._style.version),this.layers=this._style.layers.map(((e,t,i)=>this._create(e,t,i))).filter((e=>!!e)),this.layers)for(let e=0;e<this.layers.length;e++){const i=this.layers[e];this._layerByName[i.id]=i,this._uidToLayer.set(i.uid,i),i.type===t.StyleLayerType.BACKGROUND&&this.backgroundBucketIds.push(i.id)}this._identifyRefLayers()}getLayerStyleProperties(e,i){const r=this.getStyleLayerByUID(e),n=r?.getLayoutValue("symbol-placement",i)!==t.SymbolPlacement.POINT;let a=r?.getLayoutValue("icon-rotation-alignment",i);a===t.RotationAlignment.AUTO&&(a=n?t.RotationAlignment.MAP:t.RotationAlignment.VIEWPORT);let o=r?.getLayoutValue("text-rotation-alignment",i);o===t.RotationAlignment.AUTO&&(o=n?t.RotationAlignment.MAP:t.RotationAlignment.VIEWPORT);const s=r?.getPaintValue("icon-translate",i),l=r?.getPaintValue("icon-translate-anchor",i),c=r?.getPaintValue("text-translate",i),u=r?.getPaintValue("text-translate-anchor",i);return{geometryType:null,iconAllowOverlap:r?.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:r?.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:r?.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:r?.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:a,textRotationAlignment:o,iconTranslateAnchor:l,iconTranslate:s,textTranslateAnchor:u,textTranslate:c}}isPainterDataDriven(e){const t=this._layerByName[e];return!!t&&t.isPainterDataDriven()}getStyleLayerId(e){return e>=this.layers.length?null:this.layers[e].id}getStyleLayerByUID(e){return this._uidToLayer.get(e)??null}getStyleLayerIndex(e){const t=this._layerByName[e];return t?this.layers.indexOf(t):-1}setStyleLayer(e,t){if(!e?.id)return;const i=this._style;null!=t&&t>=this.layers.length&&(t=this.layers.length-1);let n,a=!0;const o=this._layerByName[e.id];if(o){const s=this.layers.indexOf(o);t||(t=s),t===s?(a=!1,n=r._recreateLayer(e,o),this.layers[t]=n,i.layers[t]=e):(this.layers.splice(s,1),i.layers.splice(s,1),n=this._create(e,t,this.layers),this.layers.splice(t,0,n),i.layers.splice(t,0,e))}else n=this._create(e,t,this.layers),!t||t>=this.layers.length?(this.layers.push(n),i.layers.push(e)):(this.layers.splice(t,0,n),i.layers.splice(t,0,e));this._layerByName[e.id]=n,this._uidToLayer.set(n.uid,n),a&&this._recomputeZValues(),this._identifyRefLayers()}getStyleLayer(e){const t=this._layerByName[e];return t?{type:t.typeName,id:t.id,source:t.source,"source-layer":t.sourceLayer,minzoom:t.minzoom,maxzoom:t.maxzoom,filter:t.filter,layout:t.layout,paint:t.paint}:null}deleteStyleLayer(e){const t=this._layerByName[e];if(t){delete this._layerByName[e],this._uidToLayer.delete(t.uid);const i=this.layers.indexOf(t);this.layers.splice(i,1),this._style.layers.splice(i,1),this._recomputeZValues(),this._identifyRefLayers()}}getLayerById(e){return this._layerByName[e]}getLayoutProperties(e){const t=this._layerByName[e];return t?t.layout:null}getPaintProperties(e){const t=this._layerByName[e];return t?t.paint:null}setPaintProperties(e,t){const i=this._layerByName[e];if(!i)return;const n={type:i.typeName,id:i.id,source:i.source,"source-layer":i.sourceLayer,minzoom:i.minzoom,maxzoom:i.maxzoom,filter:i.filter,layout:i.layout,paint:t},a=r._recreateLayer(n,i),o=this.layers.indexOf(i);this.layers[o]=a,this._style.layers[o].paint=t,this._layerByName[i.id]=a,this._uidToLayer.set(i.uid,a)}setLayoutProperties(e,t){const i=this._layerByName[e];if(!i)return;const n={type:i.typeName,id:i.id,source:i.source,"source-layer":i.sourceLayer,minzoom:i.minzoom,maxzoom:i.maxzoom,filter:i.filter,layout:t,paint:i.paint},a=r._recreateLayer(n,i),o=this.layers.indexOf(i);this.layers[o]=a,this._style.layers[o].layout=t,this._layerByName[i.id]=a,this._uidToLayer.set(i.uid,a)}setStyleLayerVisibility(e,t){const i=this._layerByName[e];if(!i)return;const n=i.layout||{};n.visibility=t;const a={type:i.typeName,id:i.id,source:i.source,"source-layer":i.sourceLayer,minzoom:i.minzoom,maxzoom:i.maxzoom,filter:i.filter,layout:n,paint:i.paint},o=r._recreateLayer(a,i),s=this.layers.indexOf(i);this.layers[s]=o,this._style.layers[s].layout=n,this._layerByName[i.id]=o,this._uidToLayer.set(i.uid,o)}getStyleLayerVisibility(e){const t=this._layerByName[e];if(!t)return"none";const i=t.layout;return i?.visibility??"visible"}_recomputeZValues(){const e=this.layers,t=1/(e.length+1);for(let i=0;i<e.length;i++)e[i].z=1-(1+i)*t}_identifyRefLayers(){const e=[],i=[];let r=0;for(const n of this.layers){const a=n.layout;if(n.type===t.StyleLayerType.FILL){const t=n;let i=n.source+"|"+n.sourceLayer;i+="|"+(a?.visibility??""),i+="|"+n.minzoom,i+="|"+n.maxzoom,i+="|"+JSON.stringify(n.filter),(t.hasDataDrivenFill||t.hasDataDrivenOutline)&&(i+="|"+r),e.push({key:i,layer:n})}else if(n.type===t.StyleLayerType.LINE){const e=n,t=n.paint,o=null!=t&&(null!=t["line-pattern"]||null!=t["line-dasharray"]);let s=n.source+"|"+n.sourceLayer;s+="|"+(a?.visibility??""),s+="|"+n.minzoom,s+="|"+n.maxzoom,s+="|"+JSON.stringify(n.filter),s+="|"+(void 0!==a?a["line-cap"]:""),s+="|"+(void 0!==a?a["line-join"]:""),(e.hasDataDrivenLine||o)&&(s+="|"+r),i.push({key:s,layer:n})}++r}this._assignRefLayers(e),this._assignRefLayers(i)}_assignRefLayers(e){let i,r;e.sort(((e,t)=>e.key<t.key?-1:e.key>t.key?1:0));const n=e.length;for(let a=0;a<n;a++){const o=e[a];if(o.key===i)o.layer.refLayerId=r;else if(i=o.key,r=o.layer.id,o.layer.type===t.StyleLayerType.FILL){if(!o.layer.getPaintProperty("fill-outline-color"))for(let t=a+1;t<n;t++){const n=e[t];if(n.key!==i)break;if(n.layer.getPaintProperty("fill-outline-color")){e[a]=n,e[t]=o,r=n.layer.id;break}}}else if(o.layer.type===t.StyleLayerType.LINE){let t=o.layer;for(let s=a+1;s<n;s++){const n=e[s];if(n.key!==i)break;const l=n.layer;(t.canUseThinTessellation&&!l.canUseThinTessellation||!t.canUseThinTessellation&&(l.getPaintProperty("line-pattern")||l.getPaintProperty("line-dasharray")))&&(t=l,e[a]=n,e[s]=o,r=n.layer.id)}}}}_create(e,r,n){const a=1-(1+r)*(1/(n.length+1)),o=this._runningId++;switch(e.type){case"background":return new i.BackgroundStyleLayer(t.StyleLayerType.BACKGROUND,e,a,o);case"fill":return new i.FillStyleLayer(t.StyleLayerType.FILL,e,a,o);case"line":return new i.LineStyleLayer(t.StyleLayerType.LINE,e,a,o);case"symbol":return new i.SymbolStyleLayer(t.StyleLayerType.SYMBOL,e,a,o);case"raster":return console.warn(`Unsupported vector tile raster layer ${e.id}`),null;case"circle":return new i.CircleStyleLayer(t.StyleLayerType.CIRCLE,e,a,o)}return null}static _recreateLayer(e,r){switch(e.type){case"background":return new i.BackgroundStyleLayer(t.StyleLayerType.BACKGROUND,e,r.z,r.uid);case"fill":return new i.FillStyleLayer(t.StyleLayerType.FILL,e,r.z,r.uid);case"line":return new i.LineStyleLayer(t.StyleLayerType.LINE,e,r.z,r.uid);case"symbol":return new i.SymbolStyleLayer(t.StyleLayerType.SYMBOL,e,r.z,r.uid);case"raster":return console.warn(`Unsupported vector tile raster layer ${e.id}`),null;case"circle":return new i.CircleStyleLayer(t.StyleLayerType.CIRCLE,e,r.z,r.uid)}return null}}return r}))},"esri/views/2d/engine/vectorTiles/style/StyleLayer":function(){define(["exports","../../../../../geometry/support/aaBoundingRect","../constants","../enums","../GeometryUtils","../shaders/VTLBackgroundMaterial","../shaders/VTLCircleMaterial","../shaders/VTLFillMaterial","../shaders/VTLLineMaterial","../shaders/VTLSymbolMaterial","./Filter","./StyleDefinition","./StyleProperty","../../webgl/definitions"],(function(e,t,i,r,n,a,o,s,l,c,u,h,p,d){"use strict";var y;e.CapType=void 0,(y=e.CapType||(e.CapType={}))[y.BUTT=0]="BUTT",y[y.ROUND=1]="ROUND",y[y.SQUARE=2]="SQUARE",y[y.UNKNOWN=4]="UNKNOWN";class f{constructor(e,t,i,r){switch(this.type=e,this.typeName=t.type,this.id=t.id,this.source=t.source,this.sourceLayer=t["source-layer"],this.minzoom=t.minzoom,this.maxzoom=t.maxzoom,this.filter=t.filter,this.layout=t.layout,this.paint=t.paint,this.z=i,this.uid=r,e){case h.StyleLayerType.BACKGROUND:this._layoutDefinition=h.StyleDefinition.backgroundLayoutDefinition,this._paintDefinition=h.StyleDefinition.backgroundPaintDefinition;break;case h.StyleLayerType.FILL:this._layoutDefinition=h.StyleDefinition.fillLayoutDefinition,this._paintDefinition=h.StyleDefinition.fillPaintDefinition;break;case h.StyleLayerType.LINE:this._layoutDefinition=h.StyleDefinition.lineLayoutDefinition,this._paintDefinition=h.StyleDefinition.linePaintDefinition;break;case h.StyleLayerType.SYMBOL:this._layoutDefinition=h.StyleDefinition.symbolLayoutDefinition,this._paintDefinition=h.StyleDefinition.symbolPaintDefinition;break;case h.StyleLayerType.CIRCLE:this._layoutDefinition=h.StyleDefinition.circleLayoutDefinition,this._paintDefinition=h.StyleDefinition.circlePaintDefinition}this._layoutProperties=this._parseLayout(this.layout),this._paintProperties=this._parsePaint(this.paint)}getFeatureFilter(){return void 0!==this._featureFilter?this._featureFilter:this._featureFilter=u.createFilter(this.filter)}getLayoutProperty(e){return this._layoutProperties[e]}getPaintProperty(e){return this._paintProperties[e]}getLayoutValue(e,t,i){let r;const n=this._layoutProperties[e];return n&&(r=n.getValue(t,i)),void 0===r&&(r=this._layoutDefinition[e].default),r}getPaintValue(e,t,i){let r;const n=this._paintProperties[e];return n&&(r=n.getValue(t,i)),void 0===r&&(r=this._paintDefinition[e].default),r}isPainterDataDriven(){const e=this._paintProperties;if(e)for(const t in e)if(e[t].isDataDriven)return!0;return!1}isIntersectingFeature(e,t,i,r,n,a,o){return!1}getFeatureInflatedBounds(e,t,i,r){return null}_parseLayout(e){const t={};for(const i in e){const r=this._layoutDefinition[i];r&&(t[i]=new p(r,e[i]))}return t}_parsePaint(e){const t={};for(const i in e){const r=this._paintDefinition[i];r&&(t[i]=new p(r,e[i]))}return t}computeAttributesKey(e,t,i,r){let n=0,a=0;for(const e of t){let t=3;if(!e||e!==r){const r=i[e],{isLayout:n,isOptional:a}=r,o=n?this.getLayoutProperty(e):this.getPaintProperty(e);t=o?.interpolator?2:o?.isDataDriven?1:a&&!o?3:0}a|=t<<n,n+=2}return a<<3|e}}function g(e){const i=e?.getGeometry();if(null==i)return null;let r=1/0,n=1/0,a=-1/0,o=-1/0;for(const e of i)if(e)for(const t of e)r=Math.min(r,t.x),n=Math.min(n,t.y),a=Math.max(a,t.x),o=Math.max(o,t.y);return t.fromValues(r,n,a,o)}e.BackgroundStyleLayer=class extends f{constructor(e,t,i,n){super(e,t,i,n),this.backgroundMaterial=new a.VTLBackgroundMaterial(this.computeAttributesKey(r.ShaderProgramType.BACKGROUND,a.VTLBackgroundMaterial.ATTRIBUTES,a.VTLBackgroundMaterial.ATTRIBUTES_INFO))}},e.CircleStyleLayer=class extends f{constructor(e,t,i,n){super(e,t,i,n),this.circleMaterial=new o.VTLCircleMaterial(this.computeAttributesKey(r.ShaderProgramType.CIRCLE,o.VTLCircleMaterial.ATTRIBUTES,o.VTLCircleMaterial.ATTRIBUTES_INFO))}getFeatureInflatedBounds(e,t,r,n){const a=g(e);if(!a)return null;const o=this.getPaintValue("circle-translate",t,e),s=Math.max(o[0],o[1]);a[0]-=s,a[2]-=s,a[1]+=s,a[3]+=s;const l=n*(i.tilePixelRatio*(this.getPaintValue("circle-radius",t,e)+this.getPaintValue("circle-stroke-width",t,e))/2);return a[0]-=l,a[1]-=l,a[2]+=l,a[3]+=l,a}isIntersectingFeature(e,t,r,a,o,s,l){const c=a.getGeometry();if(!c)return!1;const u=i.tilePixelRatio/l.normalizationRatio;e=e/l.normalizationRatio+l.normalizationOffsetX,t=t/l.normalizationRatio+l.normalizationOffsetY,r*=u;const h=n.translateAnchor(this.getPaintValue("circle-translate",o,a),this.getPaintValue("circle-translate-anchor",o,a),s,u),p=u*(this.getPaintValue("circle-radius",o,a)+this.getPaintValue("circle-stroke-width",o,a));let d,y;for(const i of c)if(i)for(const n of i)if(d=n.x+h.x,y=n.y+h.y,Math.sqrt((e-d)*(e-d)+(t-y)*(t-y))-r<=p)return!0;return!1}},e.FillStyleLayer=class extends f{constructor(e,t,i,n){super(e,t,i,n);const a=this.getPaintProperty("fill-color"),o=this.getPaintProperty("fill-opacity"),l=this.getPaintProperty("fill-pattern");this.hasDataDrivenColor=a?.isDataDriven,this.hasDataDrivenOpacity=o?.isDataDriven,this.hasDataDrivenFill=this.hasDataDrivenColor||this.hasDataDrivenOpacity||l?.isDataDriven;const c=this.getPaintProperty("fill-outline-color");this.outlineUsesFillColor=!c,this.hasDataDrivenOutlineColor=c?.isDataDriven,this.hasDataDrivenOutline=c?c.isDataDriven:!!a&&a.isDataDriven,this.hasDataDrivenOutline=(c?this.hasDataDrivenOutlineColor:this.hasDataDrivenColor)||this.hasDataDrivenOpacity,this.fillMaterial=new s.VTLFillMaterial(this.computeAttributesKey(r.ShaderProgramType.FILL,s.VTLFillMaterial.ATTRIBUTES,s.VTLFillMaterial.ATTRIBUTES_INFO)),this.outlineMaterial=new s.VTLOutlineMaterial(this.computeAttributesKey(r.ShaderProgramType.OUTLINE,this.outlineUsesFillColor?s.VTLOutlineMaterial.ATTRIBUTES_FILL:s.VTLOutlineMaterial.ATTRIBUTES_OUTLINE,this.outlineUsesFillColor?s.VTLOutlineMaterial.ATTRIBUTES_INFO_FILL:s.VTLOutlineMaterial.ATTRIBUTES_INFO_OUTLINE),this.outlineUsesFillColor)}getFeatureInflatedBounds(e,t,i,r){const n=g(e);if(!n)return null;const a=this.getPaintValue("fill-translate",t,e),o=r*Math.max(a[0],a[1]);return n[0]-=o,n[2]-=o,n[1]+=o,n[3]+=o,n}isIntersectingFeature(e,t,r,a,o,s,l){const c=a.getGeometry();if(!c)return!1;const u=i.tilePixelRatio/l.normalizationRatio;e=e/l.normalizationRatio+l.normalizationOffsetX,t=t/l.normalizationRatio+l.normalizationOffsetY;const h=n.translateAnchor(this.getPaintValue("fill-translate",o,a),this.getPaintValue("fill-translate-anchor",o,a),s,i.tilePixelRatio);return e-=u*h.x,t-=u*h.y,!!n.pointInPolygon(e,t,c)||n.distanceFromToPolylineWithinThreshold(e,t,c,u*r)}},e.IconLayout=class{constructor(e,t,i){let r;this.allowOverlap=e.getLayoutValue("icon-allow-overlap",t),this.ignorePlacement=e.getLayoutValue("icon-ignore-placement",t),this.keepUpright=e.getLayoutValue("icon-keep-upright",t),this.optional=e.getLayoutValue("icon-optional",t),this.rotationAlignment=e.getLayoutValue("icon-rotation-alignment",t),this.rotationAlignment===h.RotationAlignment.AUTO&&(this.rotationAlignment=i?h.RotationAlignment.MAP:h.RotationAlignment.VIEWPORT),r=e.getLayoutProperty("icon-anchor"),r?.isDataDriven?this._anchorProp=r:this.anchor=e.getLayoutValue("icon-anchor",t),r=e.getLayoutProperty("icon-offset"),r?.isDataDriven?this._offsetProp=r:this.offset=e.getLayoutValue("icon-offset",t),r=e.getLayoutProperty("icon-padding"),r?.isDataDriven?this._paddingProp=r:this.padding=e.getLayoutValue("icon-padding",t),r=e.getLayoutProperty("icon-rotate"),r?.isDataDriven?this._rotateProp=r:this.rotate=e.getLayoutValue("icon-rotate",t),r=e.getLayoutProperty("icon-size"),r?.isDataDriven?this._sizeProp=r:this.size=e.getLayoutValue("icon-size",t)}update(e,t){this._anchorProp&&(this.anchor=this._anchorProp.getValue(e,t)),this._offsetProp&&(this.offset=this._offsetProp.getValue(e,t)),this._paddingProp&&(this.padding=this._paddingProp.getValue(e,t)),this._rotateProp&&(this.rotate=this._rotateProp.getValue(e,t)),this._sizeProp&&(this.size=this._sizeProp.getValue(e,t))}},e.IndexItem=class{constructor(e,t,i,r,n,a){this.layer=e,this.feature=t,this.bounds=i,this.normalizationRatio=r,this.normalizationOffsetX=n,this.normalizationOffsetY=a}},e.LineStyleLayer=class extends f{constructor(e,t,i,n){super(e,t,i,n);const a=this.getPaintProperty("line-pattern");if(this.lineMaterial=new l.VTLLineMaterial(this.computeAttributesKey(r.ShaderProgramType.LINE,l.VTLLineMaterial.ATTRIBUTES,l.VTLLineMaterial.ATTRIBUTES_INFO,a?"line-dasharray":"")),this.hasDataDrivenLine=this.getPaintProperty("line-blur")?.isDataDriven||this.getPaintProperty("line-color")?.isDataDriven||this.getPaintProperty("line-gap-width")?.isDataDriven||this.getPaintProperty("line-offset")?.isDataDriven||this.getPaintProperty("line-opacity")?.isDataDriven||this.getPaintProperty("line-pattern")?.isDataDriven||this.getPaintProperty("line-dasharray")?.isDataDriven||this.getLayoutProperty("line-cap")?.isDataDriven||this.getPaintProperty("line-width")?.isDataDriven,this.canUseThinTessellation=!1,!this.hasDataDrivenLine){const e=this.getPaintProperty("line-width");if(!e||"number"==typeof e&&.5*e<d.thinLineHalfWidthThreshold){const e=this.getPaintProperty("line-offset");(!e||"number"==typeof e&&0===e)&&(this.canUseThinTessellation=!0)}}}getDashKey(t,i){let r;switch(i){case e.CapType.BUTT:r="Butt";break;case e.CapType.ROUND:r="Round";break;case e.CapType.SQUARE:r="Square";break;default:r="Butt"}return`dasharray-[${t.toString()}]-${r}`}getFeatureInflatedBounds(e,t,i,r){const n=g(e);if(!n)return null;const a=this.getPaintValue("line-translate",t,e),o=r*Math.max(a[0],a[1]);n[0]-=o,n[2]-=o,n[1]+=o,n[3]+=o;const s=r*Math.abs(this.getPaintValue("line-offset",t,e)||0),l=r*(this.getPaintValue("line-width",t,e)/2);return n[0]-=s+l,n[1]-=s+l,n[2]+=s+l,n[3]+=s+l,n}isIntersectingFeature(e,t,r,a,o,s,l){let c=a.getGeometry();if(!c)return!1;const u=i.tilePixelRatio/l.normalizationRatio;e=e/l.normalizationRatio+l.normalizationOffsetX,t=t/l.normalizationRatio+l.normalizationOffsetY;const h=n.translateAnchor(this.getPaintValue("line-translate",o,a),this.getPaintValue("line-translate-anchor",o,a),s,i.tilePixelRatio);e-=u*h.x,t-=u*h.y;const p=u*this.getPaintValue("line-offset",o,a)||0;0!==p&&(c=n.offsetLine(c,-p));const d=this.getPaintValue("line-width",o,a)/2;return n.distanceFromToPolylineWithinThreshold(e,t,c,u*(r+d))}},e.StyleLayer=f,e.SymbolStyleLayer=class extends f{constructor(e,t,i,n){super(e,t,i,n),this.iconMaterial=new c.VTLIconMaterial(this.computeAttributesKey(r.ShaderProgramType.ICON,c.VTLIconMaterial.ATTRIBUTES,c.VTLIconMaterial.ATTRIBUTES_INFO)),this.textMaterial=new c.VTLTextMaterial(this.computeAttributesKey(r.ShaderProgramType.TEXT,c.VTLTextMaterial.ATTRIBUTES,c.VTLTextMaterial.ATTRIBUTES_INFO)),this.hasDataDrivenIcon=this.getPaintProperty("icon-color")?.isDataDriven||this.getPaintProperty("icon-halo-blur")?.isDataDriven||this.getPaintProperty("icon-halo-color")?.isDataDriven||this.getPaintProperty("icon-halo-width")?.isDataDriven||this.getPaintProperty("icon-opacity")?.isDataDriven||this.getLayoutProperty("icon-size")?.isDataDriven,this.hasDataDrivenText=this.getPaintProperty("text-color")?.isDataDriven||this.getPaintProperty("text-halo-blur")?.isDataDriven||this.getPaintProperty("text-halo-color")?.isDataDriven||this.getPaintProperty("text-halo-width")?.isDataDriven||this.getPaintProperty("text-opacity")?.isDataDriven||this.getLayoutProperty("text-size")?.isDataDriven}},e.TextLayout=class{constructor(e,t,i){let r;this.allowOverlap=e.getLayoutValue("text-allow-overlap",t),this.ignorePlacement=e.getLayoutValue("text-ignore-placement",t),this.keepUpright=e.getLayoutValue("text-keep-upright",t),this.optional=e.getLayoutValue("text-optional",t),this.rotationAlignment=e.getLayoutValue("text-rotation-alignment",t),this.rotationAlignment===h.RotationAlignment.AUTO&&(this.rotationAlignment=i?h.RotationAlignment.MAP:h.RotationAlignment.VIEWPORT),r=e.getLayoutProperty("text-anchor"),r?.isDataDriven?this._anchorProp=r:this.anchor=e.getLayoutValue("text-anchor",t),r=e.getLayoutProperty("text-justify"),r?.isDataDriven?this._justifyProp=r:this.justify=e.getLayoutValue("text-justify",t),r=e.getLayoutProperty("text-letter-spacing"),r?.isDataDriven?this._letterSpacingProp=r:this.letterSpacing=e.getLayoutValue("text-letter-spacing",t),r=e.getLayoutProperty("text-line-height"),r?.isDataDriven?this._lineHeightProp=r:this.lineHeight=e.getLayoutValue("text-line-height",t),r=e.getLayoutProperty("text-max-angle"),r?.isDataDriven?this._maxAngleProp=r:this.maxAngle=e.getLayoutValue("text-max-angle",t),r=e.getLayoutProperty("text-max-width"),r?.isDataDriven?this._maxWidthProp=r:this.maxWidth=e.getLayoutValue("text-max-width",t),r=e.getLayoutProperty("text-offset"),r?.isDataDriven?this._offsetProp=r:this.offset=e.getLayoutValue("text-offset",t),r=e.getLayoutProperty("text-padding"),r?.isDataDriven?this._paddingProp=r:this.padding=e.getLayoutValue("text-padding",t),r=e.getLayoutProperty("text-rotate"),r?.isDataDriven?this._rotateProp=r:this.rotate=e.getLayoutValue("text-rotate",t),r=e.getLayoutProperty("text-size"),r?.isDataDriven?this._sizeProp=r:this.size=e.getLayoutValue("text-size",t),r=e.getLayoutProperty("text-writing-mode"),r?.isDataDriven?this._writingModeProp=r:this.writingMode=e.getLayoutValue("text-writing-mode",t)}update(e,t){this._anchorProp&&(this.anchor=this._anchorProp.getValue(e,t)),this._justifyProp&&(this.justify=this._justifyProp.getValue(e,t)),this._letterSpacingProp&&(this.letterSpacing=this._letterSpacingProp.getValue(e,t)),this._lineHeightProp&&(this.lineHeight=this._lineHeightProp.getValue(e,t)),this._maxAngleProp&&(this.maxAngle=this._maxAngleProp.getValue(e,t)),this._maxWidthProp&&(this.maxWidth=this._maxWidthProp.getValue(e,t)),this._offsetProp&&(this.offset=this._offsetProp.getValue(e,t)),this._paddingProp&&(this.padding=this._paddingProp.getValue(e,t)),this._rotateProp&&(this.rotate=this._rotateProp.getValue(e,t)),this._sizeProp&&(this.size=this._sizeProp.getValue(e,t)),this._writingModeProp&&(this.writingMode=this._writingModeProp.getValue(e,t))}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLBackgroundMaterial":function(){define(["exports","./VTLMaterial","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r){"use strict";class n extends t.VTLMaterial{static{this.ATTRIBUTES=[]}static{this.GEOMETRY_LAYOUT=[new r.VertexElementDescriptor("a_pos",2,i.DataType.BYTE,0,2)]}static{this.ATTRIBUTES_INFO={}}constructor(e){super(e)}geometryInfo(){return n.GEOMETRY_LAYOUT}opacityInfo(){return null}attributes(){return n.ATTRIBUTES}attributesInfo(){return n.ATTRIBUTES_INFO}}e.VTLBackgroundMaterial=n,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLMaterial":function(){define(["exports","../MemoryBuffer","./enums","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r,n){"use strict";class a{constructor(e){this._locations=new Map,this._key=e}get key(){return this._key}get type(){return 7&this._key}defines(){return[]}getStride(){return this._layout||this._buildAttributesInfo(),this._stride}getAttributeLocations(){return 0===this._locations.size&&this._buildAttributesInfo(),this._locations}getLayoutInfo(){return this._layout||this._buildAttributesInfo(),this._layout}getEncodingInfos(){return this._propertyEncodingInfo||this._buildAttributesInfo(),this._propertyEncodingInfo}getUniforms(){return this._uniforms||this._buildAttributesInfo(),this._uniforms}getShaderHeader(){return this._shaderHeader||this._buildAttributesInfo(),this._shaderHeader}getShaderMain(){return this._shaderMain||this._buildAttributesInfo(),this._shaderMain}setDataUniforms(e,t,i,r,n){const a=this.getUniforms();for(const o of a){const{name:a,type:s,getValue:l}=o,c=l(i,t,r,n);if(null!==c)switch(s){case"float":e.setUniform1f(a,c);break;case"vec2":e.setUniform2fv(a,c);break;case"vec4":e.setUniform4fv(a,c)}}}encodeAttributes(e,t,r,n){const a=this.attributesInfo(),o=this.getEncodingInfos(),s=[];let l=0,c=0;for(const u of Object.keys(o)){const h=o[u],{type:p,precisionFactor:d,isLayout:y}=a[u],f=y?r.getLayoutProperty(u):r.getPaintProperty(u),g=f.interpolator?.getInterpolationRange(t);let m=0;for(const r of h){const{offset:a,bufferElementsToAdd:o}=r;if(o>0){for(let e=0;e<o;e++)s.push(0);l+=c,c=r.bufferElementsToAdd}const u=n??f.getValue(g?g[m]:t,e);switch(p){case i.EncodingType.R8_SIGNED:case i.EncodingType.R8_UNSIGNED:s[l]|=this._encodeByte(u*(d||1),8*a);break;case i.EncodingType.R16_SIGNED:case i.EncodingType.R16_UNSIGNED:s[l]|=this._encodeShort(u*(d||1),8*a);break;case i.EncodingType.R8G8_SIGNED:case i.EncodingType.R8G8_UNSIGNED:s[l]|=this._encodeByte(u*(d||1),8*a),s[l]|=this._encodeByte(u*(d||1),8*a+8);break;case i.EncodingType.R16G16_SIGNED:case i.EncodingType.R16G16_UNSIGNED:s[l]|=this._encodeShort(u*(d||1),8*a),s[l]|=this._encodeShort(u*(d||1),8*a+16);break;case i.EncodingType.R8G8B8A8_SIGNED:case i.EncodingType.R8G8B8A8_UNSIGNED:s[l]|=this._encodeByte(u*(d||1),8*a),s[l]|=this._encodeByte(u*(d||1),8*a+8),s[l]|=this._encodeByte(u*(d||1),8*a+16),s[l]|=this._encodeByte(u*(d||1),8*a+24);break;case i.EncodingType.R8G8B8A8_COLOR:s[l]=this._encodeColor(u);break;case i.EncodingType.R16G16B16A16_DASHARRAY:case i.EncodingType.R16G16B16A16_PATTERN:this._encodePattern(l,s,u);break;default:throw new Error("Unsupported encoding type")}m++}}return s}getAtributeState(e){let t=0;const i=3+2*e;return t|=this._bit(i),t|=this._bit(i+1)<<1,t}static{this._encodingInfo={[i.EncodingType.R8_SIGNED]:{dataType:r.DataType.BYTE,bytesPerElement:1,count:1,normalized:!1},[i.EncodingType.R8_UNSIGNED]:{dataType:r.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:1,normalized:!1},[i.EncodingType.R16_SIGNED]:{dataType:r.DataType.SHORT,bytesPerElement:2,count:1,normalized:!1},[i.EncodingType.R16_UNSIGNED]:{dataType:r.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:1,normalized:!1},[i.EncodingType.R8G8_SIGNED]:{dataType:r.DataType.BYTE,bytesPerElement:1,count:2,normalized:!1},[i.EncodingType.R8G8_UNSIGNED]:{dataType:r.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:2,normalized:!1},[i.EncodingType.R16G16_SIGNED]:{dataType:r.DataType.SHORT,bytesPerElement:2,count:2,normalized:!1},[i.EncodingType.R16G16_UNSIGNED]:{dataType:r.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:2,normalized:!1},[i.EncodingType.R8G8B8A8_SIGNED]:{dataType:r.DataType.BYTE,bytesPerElement:1,count:4,normalized:!1},[i.EncodingType.R8G8B8A8_UNSIGNED]:{dataType:r.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!1},[i.EncodingType.R8G8B8A8_COLOR]:{dataType:r.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!0},[i.EncodingType.R16G16B16A16_DASHARRAY]:{dataType:r.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1},[i.EncodingType.R16G16B16A16_PATTERN]:{dataType:r.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1}}}_buildAttributesInfo(){const e=[],t={},n={};let o=-1;const s=this.attributesInfo(),l=this.attributes();let c=-1;for(const r of l){c++;const l=this.getAtributeState(c);if(l===i.AttributeStatus.UNIFORM||l===i.AttributeStatus.UNUSED)continue;const u=s[r],h=[];t[r]=h;const p=u.type;for(let t=0;t<l;t++){const{dataType:t,bytesPerElement:i,count:r,normalized:s}=a._encodingInfo[p],l=i*r,c=`${t}-${!0===s}`;let u=n[c],d=0;if(!u||u.count+r>4)o++,u={dataIndex:o,count:0,offset:0},4!==r&&(n[c]=u),e.push({location:-1,name:"a_data_"+o,count:r,type:t,normalized:s}),d=Math.ceil(Math.max(l/4,1));else{const t=e[u.dataIndex];t.count+=r,d=Math.ceil(Math.max(t.count*i/4,1))-Math.ceil(Math.max(u.offset/4,1))}h.push({dataIndex:u.dataIndex,offset:u.offset,bufferElementsToAdd:d}),u.offset+=l,u.count+=r}}for(const t of e)switch(t.type){case r.DataType.BYTE:case r.DataType.UNSIGNED_BYTE:t.count=4;break;case r.DataType.SHORT:case r.DataType.UNSIGNED_SHORT:t.count+=t.count%2}this._buildVertexBufferLayout(e);let u=0;const h=this._layout.get("geometry");for(const e of h)this._locations.set(e.name,u++);const p=this._layout.get("opacity");if(p)for(const e of p)this._locations.set(e.name,u++);this._buildShaderInfo(e,t),this._propertyEncodingInfo=t}_buildVertexBufferLayout(e){const t=new Map,i=this.geometryInfo();let r=i[0].stride;if(0===e.length)t.set("geometry",i);else{const a=[];let s=r;for(const t of e)r+=o(t.type)*t.count;for(const e of i)a.push(new n.VertexElementDescriptor(e.name,e.count,e.type,e.offset,r,e.normalized));for(const t of e)a.push(new n.VertexElementDescriptor(t.name,t.count,t.type,s,r,t.normalized)),s+=o(t.type)*t.count;t.set("geometry",a)}const a=this.opacityInfo();a&&t.set("opacity",a),this._layout=t,this._stride=r}_buildShaderInfo(e,t){let r="\n",n="\n";const o=[];for(const t of e)r+=`attribute ${this._getType(t.count)} ${t.name};\n`;const l=this.attributes(),c=this.attributesInfo();let u=-1;for(const e of l){u++;const{name:l,type:h,precisionFactor:p,isLayout:d}=c[e],y=p&&1!==p?" * "+1/p:"",{bytesPerElement:f,count:g}=a._encodingInfo[h],m=e=>`a_data_${e.dataIndex}${s(g,e.offset,f)}`;switch(this.getAtributeState(u)){case i.AttributeStatus.UNIFORM:{const t=this._getType(g),a=`u_${l}`;o.push({name:a,type:t,getValue:(t,r,n,a)=>{const o=d?t.getLayoutValue(e,r):t.getPaintValue(e,r);if(h===i.EncodingType.R16G16B16A16_DASHARRAY){const e=t.getDashKey(o,t.getLayoutValue("line-cap",r)),i=a.getMosaicItemPosition(e,!1);if(null==i)return null;const{tl:n,br:s}=i;return[n[0],s[1],s[0],n[1]]}if(h===i.EncodingType.R16G16B16A16_PATTERN){const t=a.getMosaicItemPosition(o,!e.includes("line-"));if(null==t)return null;const{tl:i,br:r}=t;return[i[0],r[1],r[0],i[1]]}if(h===i.EncodingType.R8G8B8A8_COLOR){const e=o[3];return[e*o[0],e*o[1],e*o[2],e]}return o}}),r+=`uniform ${t} ${a};\n`,n+=`${t} ${l} = ${a};\n`}break;case i.AttributeStatus.DATA_DRIVEN:{const i=m(t[e][0]);n+=`${this._getType(g)} ${l} = ${i}${y};\n`}break;case i.AttributeStatus.INTERPOLATED_DATA_DRIVEN:{const i=`u_t_${l}`;o.push({name:i,type:"float",getValue:(t,i,r,n)=>(d?t.getLayoutProperty(e):t.getPaintProperty(e)).interpolator.interpolationUniformValue(r,i)}),r+=`uniform float ${i};\n`;const a=m(t[e][0]),s=m(t[e][1]);n+=`${this._getType(g)} ${l} = mix(${a}${y}, ${s}${y}, ${i});\n`}}}this._shaderHeader=r,this._shaderMain=n,this._uniforms=o}_bit(e){return(this._key&1<<e)>>e}_getType(e){switch(e){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4"}throw new Error("Invalid count")}_encodeColor(e){const i=255*e[3];return t.i8888to32(e[0]*i,e[1]*i,e[2]*i,i)}_encodePattern(e,t,i){if(!i?.rect)return;const r=i.rect,n=i.width,a=i.height;t[e]=this._encodeShort(r.x+2,0),t[e]|=this._encodeShort(r.y+2+a,16),t[e+1]=this._encodeShort(r.x+2+n,0),t[e+1]|=this._encodeShort(r.y+2,16)}_encodeByte(e,t){return(255&e)<<t}_encodeShort(e,t){return(65535&e)<<t}}const o=e=>{switch(e){case r.DataType.FLOAT:case r.DataType.INT:case r.DataType.UNSIGNED_INT:return 4;case r.DataType.SHORT:case r.DataType.UNSIGNED_SHORT:case r.DataType.HALF_FLOAT:return 2;case r.DataType.BYTE:case r.DataType.UNSIGNED_BYTE:return 1}},s=(e,t,i)=>{const r=t/i;if(1===e)switch(r){case 0:return".x";case 1:return".y";case 2:return".z";case 3:return".w"}else if(2===e)switch(r){case 0:return".xy";case 1:return".yz";case 2:return".zw"}else if(3===e)switch(r){case 0:return".xyz";case 1:return".yzw"}return""};e.VTLMaterial=a,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/MemoryBuffer":function(){define(["../../../../core/has"],(function(e){"use strict";return class{constructor(e){this._array=[],this._stride=e}get array(){return this._array}get index(){return 4*this._array.length/this._stride}get itemSize(){return this._stride}get sizeInBytes(){return 4*this._array.length}reset(){this.array.length=0}toBuffer(){return new Uint32Array(this._array).buffer}static i1616to32(e,t){return 65535&e|t<<16}static i8888to32(e,t,i,r){return 255&e|(255&t)<<8|(255&i)<<16|r<<24}static i8816to32(e,t,i){return 255&e|(255&t)<<8|i<<16}}}))},"esri/views/2d/engine/vectorTiles/shaders/enums":function(){define(["exports"],(function(e){"use strict";var t,i;e.EncodingType=void 0,(t=e.EncodingType||(e.EncodingType={}))[t.R8_SIGNED=0]="R8_SIGNED",t[t.R8_UNSIGNED=1]="R8_UNSIGNED",t[t.R16_SIGNED=2]="R16_SIGNED",t[t.R16_UNSIGNED=3]="R16_UNSIGNED",t[t.R8G8_SIGNED=4]="R8G8_SIGNED",t[t.R8G8_UNSIGNED=5]="R8G8_UNSIGNED",t[t.R16G16_SIGNED=6]="R16G16_SIGNED",t[t.R16G16_UNSIGNED=7]="R16G16_UNSIGNED",t[t.R8G8B8A8_SIGNED=8]="R8G8B8A8_SIGNED",t[t.R8G8B8A8_UNSIGNED=9]="R8G8B8A8_UNSIGNED",t[t.R8G8B8A8_COLOR=10]="R8G8B8A8_COLOR",t[t.R16G16B16A16_DASHARRAY=11]="R16G16B16A16_DASHARRAY",t[t.R16G16B16A16_PATTERN=12]="R16G16B16A16_PATTERN",e.AttributeStatus=void 0,(i=e.AttributeStatus||(e.AttributeStatus={}))[i.UNIFORM=0]="UNIFORM",i[i.DATA_DRIVEN=1]="DATA_DRIVEN",i[i.INTERPOLATED_DATA_DRIVEN=2]="INTERPOLATED_DATA_DRIVEN",i[i.UNUSED=3]="UNUSED",Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLCircleMaterial":function(){define(["exports","./enums","./VTLMaterial","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r,n){"use strict";class a extends i.VTLMaterial{static{this.ATTRIBUTES=["circle-radius","circle-color","circle-opacity","circle-stroke-width","circle-stroke-color","circle-stroke-opacity","circle-blur"]}static{this.GEOMETRY_LAYOUT=[new n.VertexElementDescriptor("a_pos",2,r.DataType.SHORT,0,4)]}static{this.ATTRIBUTES_INFO={"circle-radius":{name:"radius",type:t.EncodingType.R8_UNSIGNED},"circle-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"circle-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"circle-stroke-width":{name:"stroke_width",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"circle-stroke-color":{name:"stroke_color",type:t.EncodingType.R8G8B8A8_COLOR},"circle-stroke-opacity":{name:"stroke_opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"circle-blur":{name:"blur",type:t.EncodingType.R8_UNSIGNED,precisionFactor:32}}}constructor(e){super(e)}geometryInfo(){return a.GEOMETRY_LAYOUT}opacityInfo(){return null}attributes(){return a.ATTRIBUTES}attributesInfo(){return a.ATTRIBUTES_INFO}}e.VTLCircleMaterial=a,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLFillMaterial":function(){define(["exports","./enums","./VTLMaterial","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r,n){"use strict";class a extends i.VTLMaterial{static{this.ATTRIBUTES=["fill-color","fill-opacity","fill-pattern"]}static{this.GEOMETRY_LAYOUT=[new n.VertexElementDescriptor("a_pos",2,r.DataType.SHORT,0,4)]}static{this.ATTRIBUTES_INFO={"fill-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"fill-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"fill-pattern":{name:"tlbr",type:t.EncodingType.R16G16B16A16_PATTERN,isOptional:!0}}}constructor(e){super(e)}geometryInfo(){return a.GEOMETRY_LAYOUT}opacityInfo(){return null}attributes(){return a.ATTRIBUTES}attributesInfo(){return a.ATTRIBUTES_INFO}}class o extends i.VTLMaterial{static{this.ATTRIBUTES_OUTLINE=["fill-outline-color","fill-opacity"]}static{this.ATTRIBUTES_FILL=["fill-color","fill-opacity"]}static{this.GEOMETRY_LAYOUT=[new n.VertexElementDescriptor("a_pos",2,r.DataType.SHORT,0,8),new n.VertexElementDescriptor("a_offset",2,r.DataType.BYTE,4,8),new n.VertexElementDescriptor("a_xnormal",2,r.DataType.BYTE,6,8)]}static{this.ATTRIBUTES_INFO_OUTLINE={"fill-outline-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"fill-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100}}}static{this.ATTRIBUTES_INFO_FILL={"fill-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"fill-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100}}}constructor(e,t){super(e),this._usefillColor=t}geometryInfo(){return o.GEOMETRY_LAYOUT}opacityInfo(){return null}attributes(){return this._usefillColor?o.ATTRIBUTES_FILL:o.ATTRIBUTES_OUTLINE}attributesInfo(){return this._usefillColor?o.ATTRIBUTES_INFO_FILL:o.ATTRIBUTES_INFO_OUTLINE}}e.VTLFillMaterial=a,e.VTLOutlineMaterial=o,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLLineMaterial":function(){define(["exports","./enums","./VTLMaterial","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r,n){"use strict";class a extends i.VTLMaterial{static{this.ATTRIBUTES=["line-blur","line-color","line-gap-width","line-offset","line-opacity","line-width","line-pattern","line-dasharray"]}static{this.GEOMETRY_LAYOUT=[new n.VertexElementDescriptor("a_pos",2,r.DataType.SHORT,0,16),new n.VertexElementDescriptor("a_extrude_offset",4,r.DataType.BYTE,4,16),new n.VertexElementDescriptor("a_dir_normal",4,r.DataType.BYTE,8,16),new n.VertexElementDescriptor("a_accumulatedDistance",2,r.DataType.UNSIGNED_SHORT,12,16)]}static{this.ATTRIBUTES_INFO={"line-width":{name:"width",type:t.EncodingType.R8_UNSIGNED,precisionFactor:2},"line-gap-width":{name:"gap_width",type:t.EncodingType.R8_UNSIGNED,precisionFactor:2},"line-offset":{name:"offset",type:t.EncodingType.R8_SIGNED,precisionFactor:2},"line-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"line-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"line-blur":{name:"blur",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"line-pattern":{name:"tlbr",type:t.EncodingType.R16G16B16A16_PATTERN,isOptional:!0},"line-dasharray":{name:"tlbr",type:t.EncodingType.R16G16B16A16_DASHARRAY,isOptional:!0}}}constructor(e){super(e)}geometryInfo(){return a.GEOMETRY_LAYOUT}opacityInfo(){return null}attributes(){return a.ATTRIBUTES}attributesInfo(){return a.ATTRIBUTES_INFO}}e.VTLLineMaterial=a,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/shaders/VTLSymbolMaterial":function(){define(["exports","./enums","./VTLMaterial","../../../../webgl/enums","../../../../webgl/VertexElementDescriptor"],(function(e,t,i,r,n){"use strict";const a=[new n.VertexElementDescriptor("a_pos",2,r.DataType.SHORT,0,16),new n.VertexElementDescriptor("a_vertexOffset",2,r.DataType.SHORT,4,16),new n.VertexElementDescriptor("a_texAngleRange",4,r.DataType.UNSIGNED_BYTE,8,16),new n.VertexElementDescriptor("a_levelInfo",4,r.DataType.UNSIGNED_BYTE,12,16)],o=[new n.VertexElementDescriptor("a_opacityInfo",1,r.DataType.UNSIGNED_BYTE,0,1)];class s extends i.VTLMaterial{static{this.ATTRIBUTES=["icon-color","icon-opacity","icon-halo-blur","icon-halo-color","icon-halo-width","icon-size"]}static{this.ATTRIBUTES_INFO={"icon-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"icon-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"icon-halo-color":{name:"halo_color",type:t.EncodingType.R8G8B8A8_COLOR},"icon-halo-width":{name:"halo_width",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"icon-halo-blur":{name:"halo_blur",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"icon-size":{name:"size",type:t.EncodingType.R8_UNSIGNED,precisionFactor:32,isLayout:!0}}}constructor(e){super(e)}geometryInfo(){return a}opacityInfo(){return o}attributes(){return s.ATTRIBUTES}attributesInfo(){return s.ATTRIBUTES_INFO}}class l extends i.VTLMaterial{static{this.ATTRIBUTES=["text-color","text-opacity","text-halo-blur","text-halo-color","text-halo-width","text-size"]}static{this.ATTRIBUTES_INFO={"text-color":{name:"color",type:t.EncodingType.R8G8B8A8_COLOR},"text-opacity":{name:"opacity",type:t.EncodingType.R8_UNSIGNED,precisionFactor:100},"text-halo-color":{name:"halo_color",type:t.EncodingType.R8G8B8A8_COLOR},"text-halo-width":{name:"halo_width",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"text-halo-blur":{name:"halo_blur",type:t.EncodingType.R8_UNSIGNED,precisionFactor:4},"text-size":{name:"size",type:t.EncodingType.R8_UNSIGNED,isLayout:!0}}}constructor(e){super(e)}geometryInfo(){return a}opacityInfo(){return o}attributes(){return l.ATTRIBUTES}attributesInfo(){return l.ATTRIBUTES_INFO}}e.VTLIconMaterial=s,e.VTLTextMaterial=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/style/Filter":function(){define(["../expression/expression","../expression/types"],(function(e,t){"use strict";class i{constructor(e){this._expression=e}filter(e,t){if(!this._expression)return!0;try{return this._expression.evaluate(e,t)}catch(e){return console.log(e.message),!0}}static createFilter(r){if(!r)return null;this.isLegacyFilter(r)&&(r=this.convertLegacyFilter(r));try{const n=e.createExpression(r,null,t.booleanType);return new i(n)}catch(e){return console.log(e.message),null}}static isLegacyFilter(e){if(!Array.isArray(e))return!0;if(0===e.length)return!0;switch(e[0]){case"==":case"!=":case">":case"<":case">=":case"<=":return 3===e.length&&"string"==typeof e[1]&&!Array.isArray(e[2]);case"in":return e.length>=3&&"string"==typeof e[1]&&!Array.isArray(e[2]);case"!in":case"none":case"!has":return!0;case"any":case"all":for(let t=1;t<e.length;t++)if(this.isLegacyFilter(e[t]))return!0;return!1;case"has":return 2===e.length&&("$id"===e[1]||"$type"===e[1]);default:return!1}}static convertLegacyFilter(e){if(!Array.isArray(e)||0===e.length)return!0;const t=e[0];if(1===e.length)return"any"!==t;switch(t){case"==":return i.convertComparison("==",e[1],e[2]);case"!=":return i.negate(i.convertComparison("==",e[1],e[2]));case">":case"<":case">=":case"<=":return i.convertComparison(t,e[1],e[2]);case"in":return i.convertIn(e[1],e.slice(2));case"!in":return i.negate(i.convertIn(e[1],e.slice(2)));case"any":case"all":case"none":return i.convertCombining(t,e.slice(1));case"has":return i.convertHas(e[1]);case"!has":return i.negate(i.convertHas(e[1]));default:throw new Error("Unexpected legacy filter.")}}static convertComparison(e,t,i){switch(t){case"$type":return[e,["geometry-type"],i];case"$id":return[e,["id"],i];default:return[e,["get",t],i]}}static convertIn(e,t){switch(e){case"$type":return["in",["geometry-type"],["literal",t]];case"$id":return["in",["id"],["literal",t]];default:return["in",["get",e],["literal",t]]}}static convertHas(e){switch(e){case"$type":return!0;case"$id":return["has-id"];default:return["has",e]}}static convertCombining(e,t){return[e].concat(t.map(this.convertLegacyFilter))}static negate(e){return["!",e]}}return i}))},"esri/views/2d/engine/vectorTiles/expression/expression":function(){define(["exports","../../../../../Color","../../../../../core/colorUtils","../../../../../geometry/support/TileClipper","../../../unitBezier","../GeometryUtils","./types"],(function(e,t,i,r,n,a,o){"use strict";class s{constructor(e){this._parent=e,this._vars={}}add(e,t){this._vars[e]=t}get(e){return this._vars[e]?this._vars[e]:this._parent?this._parent.get(e):null}}class l{constructor(){this.type=o.valueType}static parse(e){if(e.length>1)throw new Error('"id" does not expect arguments');return new l}evaluate(e,t){return e?.id}}class c{constructor(){this.type=o.stringType}static parse(e){if(e.length>1)throw new Error('"geometry-type" does not expect arguments');return new c}evaluate(e,t){if(!e)return null;switch(e.type){case r.GeometryType.Point:return"Point";case r.GeometryType.LineString:return"LineString";case r.GeometryType.Polygon:return"Polygon";default:return null}}}class u{constructor(){this.type=o.objectType}static parse(e){if(e.length>1)throw new Error('"properties" does not expect arguments');return new u}evaluate(e,t){return e?.values}}class h{constructor(){this.type=o.numberType}static parse(e){if(e.length>1)throw new Error('"zoom" does not expect arguments');return new h}evaluate(e,t){return t}}class p{constructor(e,t,i){this._lhs=e,this._rhs=t,this._compare=i,this.type=o.booleanType}static parse(e,t,i){if(3!==e.length&&4!==e.length)throw new Error(`"${e[0]}" expects 2 or 3 arguments`);if(4===e.length)throw new Error(`"${e[0]}" collator not supported`);return new p(te(e[1],t),te(e[2],t),i)}evaluate(e,t){return this._compare(this._lhs.evaluate(e,t),this._rhs.evaluate(e,t))}}class d extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e===t))}}class y extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e!==t))}}class f extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e<t))}}class g extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e<=t))}}class m extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e>t))}}class _ extends p{static parse(e,t){return p.parse(e,t,((e,t)=>e>=t))}}class v{constructor(e){this._arg=e,this.type=o.booleanType}static parse(e,t){if(2!==e.length)throw new Error('"!" expects 1 argument');return new v(te(e[1],t))}evaluate(e,t){return!this._arg.evaluate(e,t)}}class T{constructor(e){this._args=e,this.type=o.booleanType}static parse(e,t){const i=[];for(let r=1;r<e.length;r++)i.push(te(e[r],t));return new T(i)}evaluate(e,t){for(const i of this._args)if(!i.evaluate(e,t))return!1;return!0}}class w{constructor(e){this._args=e,this.type=o.booleanType}static parse(e,t){const i=[];for(let r=1;r<e.length;r++)i.push(te(e[r],t));return new w(i)}evaluate(e,t){for(const i of this._args)if(i.evaluate(e,t))return!0;return!1}}class b{constructor(e){this._args=e,this.type=o.booleanType}static parse(e,t){const i=[];for(let r=1;r<e.length;r++)i.push(te(e[r],t));return new b(i)}evaluate(e,t){for(const i of this._args)if(i.evaluate(e,t))return!1;return!0}}class x{constructor(e,t,i){this.type=e,this._args=t,this._fallback=i}static parse(e,t,i){if(e.length<4)throw new Error('"case" expects at least 3 arguments');if(e.length%2==1)throw new Error('"case" expects an odd number of arguments');let r;const n=[];for(let a=1;a<e.length-1;a+=2){const o=te(e[a],t),s=te(e[a+1],t,i);r||(r=s.type),n.push({condition:o,output:s})}const a=te(e[e.length-1],t,i);return r||(r=a.type),new x(r,n,a)}evaluate(e,t){for(const i of this._args)if(i.condition.evaluate(e,t))return i.output.evaluate(e,t);return this._fallback.evaluate(e,t)}}class S{constructor(e,t){this.type=e,this._args=t}static parse(e,t){if(e.length<2)throw new Error('"coalesce" expects at least 1 argument');let i;const r=[];for(let n=1;n<e.length;n++){const a=te(e[n],t);i||(i=a.type),r.push(a)}return new S(i,r)}evaluate(e,t){for(const i of this._args){const r=i.evaluate(e,t);if(null!==r)return r}return null}}class E{constructor(e,t,i,r,n){this.type=e,this._input=t,this._labels=i,this._outputs=r,this._fallback=n}static parse(e,t){if(e.length<3)throw new Error('"match" expects at least 3 arguments');if(e.length%2==0)throw new Error('"case" expects an even number of arguments');let i;const r=te(e[1],t),n=[],a={};let o;for(let r=2;r<e.length-1;r+=2){let s=e[r];Array.isArray(s)||(s=[s]);for(const e of s){const t=typeof e;if("string"!==t&&"number"!==t)throw new Error('"match" requires string or number literal as labels');if(o){if(t!==o)throw new Error('"match" requires labels to have the same type')}else o=t;a[e]=n.length}const l=te(e[r+1],t);i||(i=l.type),n.push(l)}return new E(i,r,a,n,te(e[e.length-1],t))}evaluate(e,t){const i=this._input.evaluate(e,t);return(this._outputs[this._labels[i]]||this._fallback).evaluate(e,t)}}class D{constructor(e,t,i,r,n){this._operator=e,this.type=t,this.interpolation=i,this.input=r,this._stops=n}static parse(e,t,i){const r=e[0];if(e.length<5)throw new Error(`"${r}" expects at least 4 arguments`);const n=e[1];if(!Array.isArray(n)||0===n.length)throw new Error(`"${n}" is not a valid interpolation`);switch(n[0]){case"linear":if(1!==n.length)throw new Error("Linear interpolation cannot have parameters");break;case"exponential":if(2!==n.length||"number"!=typeof n[1])throw new Error("Exponential interpolation requires one numeric argument");break;case"cubic-bezier":if(5!==n.length)throw new Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1");for(let e=1;e<5;e++){const t=n[e];if("number"!=typeof t||t<0||t>1)throw new Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1")}break;default:throw new Error(`"${e[0]}" unknown interpolation type "${n[0]}"`)}if(e.length%2!=1)throw new Error(`"${r}" expects an even number of arguments`);const a=te(e[2],t,o.numberType);let s;"interpolate-hcl"===r||"interpolate-lab"===r?s=o.colorType:i&&"value"!==i.kind&&(s=i);const l=[];for(let i=3;i<e.length;i+=2){const n=e[i];if("number"!=typeof n)throw new Error(`"${r}" requires stop inputs as literal numbers`);if(l.length&&l[l.length-1][0]>=n)throw new Error(`"${r}" requires strictly ascending stop inputs`);const a=te(e[i+1],t,s);s||(s=a.type),l.push([n,a])}if(s&&s!==o.colorType&&s!==o.numberType&&("array"!==s.kind||s.itemType!==o.numberType))throw new Error(`"${r}" cannot interpolate type ${o.typeToString(s)}`);return new D(r,s,n,a,l)}evaluate(e,r){const n=this._stops;if(1===n.length)return n[0][1].evaluate(e,r);const s=this.input.evaluate(e,r);if(s<=n[0][0])return n[0][1].evaluate(e,r);if(s>=n[n.length-1][0])return n[n.length-1][1].evaluate(e,r);let l=0;for(;++l<n.length&&!(s<n[l][0]););const c=n[l-1][0],u=n[l][0],h=D.interpolationRatio(this.interpolation,s,c,u),p=n[l-1][1].evaluate(e,r),d=n[l][1].evaluate(e,r);if("interpolate"===this._operator){if("array"===this.type.kind&&Array.isArray(p)&&Array.isArray(d))return p.map(((e,t)=>a.interpolate(e,d[t],h)));if("color"===this.type.kind&&p instanceof t&&d instanceof t){const e=new t(p),i=new t(d);return new t([a.interpolate(e.r,i.r,h),a.interpolate(e.g,i.g,h),a.interpolate(e.b,i.b,h),a.interpolate(e.a,i.a,h)])}if("number"===this.type.kind&&"number"==typeof p&&"number"==typeof d)return a.interpolate(p,d,h);throw new Error(`"${this._operator}" cannot interpolate type ${o.typeToString(this.type)}`)}if("interpolate-hcl"===this._operator){const e=i.toLCH(p),r=i.toLCH(d),n=r.h-e.h,o=i.toRGB({h:e.h+h*(n>180||n<-180?n-360*Math.round(n/360):n),c:a.interpolate(e.c,r.c,h),l:a.interpolate(e.l,r.l,h)});return new t({a:a.interpolate(p.a,d.a,h),...o})}if("interpolate-lab"===this._operator){const e=i.toLAB(p),r=i.toLAB(d),n=i.toRGB({l:a.interpolate(e.l,r.l,h),a:a.interpolate(e.a,r.a,h),b:a.interpolate(e.b,r.b,h)});return new t({a:a.interpolate(p.a,d.a,h),...n})}throw new Error(`Unexpected operator "${this._operator}"`)}interpolationUniformValue(e,t){const i=this._stops;if(1===i.length)return 0;if(e>=i[i.length-1][0])return 0;let r=0;for(;++r<i.length&&!(e<i[r][0]););const n=i[r-1][0],a=i[r][0];return D.interpolationRatio(this.interpolation,t,n,a)}getInterpolationRange(e){const t=this._stops;if(1===t.length){const e=t[0][0];return[e,e]}const i=t[t.length-1][0];if(e>=i)return[i,i];let r=0;for(;++r<t.length&&!(e<t[r][0]););return[t[r-1][0],t[r][0]]}static interpolationRatio(e,t,i,r){let a=0;return"linear"===e[0]?a=D._exponentialInterpolationRatio(t,1,i,r):"exponential"===e[0]?a=D._exponentialInterpolationRatio(t,e[1],i,r):"cubic-bezier"===e[0]&&(a=n.unitBezier(e[1],e[2],e[3],e[4])(D._exponentialInterpolationRatio(t,1,i,r),1e-5)),a<0?a=0:a>1&&(a=1),a}static _exponentialInterpolationRatio(e,t,i,r){const n=r-i;if(0===n)return 0;const a=e-i;return 1===t?a/n:(t**a-1)/(t**n-1)}}class P{constructor(e,t,i){this.type=e,this._input=t,this._stops=i}static parse(e,t){if(e.length<5)throw new Error('"step" expects at least 4 arguments');if(e.length%2!=1)throw new Error('"step" expects an even number of arguments');const i=te(e[1],t,o.numberType);let r;const n=[];n.push([-1/0,te(e[2],t)]);for(let i=3;i<e.length;i+=2){const a=e[i];if("number"!=typeof a)throw new Error('"step" requires stop inputs as literal numbers');if(n.length&&n[n.length-1][0]>=a)throw new Error('"step" requires strictly ascending stop inputs');const o=te(e[i+1],t);r||(r=o.type),n.push([a,o])}return new P(r,i,n)}evaluate(e,t){const i=this._stops;if(1===i.length)return i[0][1].evaluate(e,t);const r=this._input.evaluate(e,t);let n=0;for(;++n<i.length&&!(r<i[n][0]););return this._stops[n-1][1].evaluate(e,t)}}class L{constructor(e,t){this.type=e,this._output=t}static parse(e,t,i){if(e.length<4)throw new Error('"let" expects at least 3 arguments');if(e.length%2==1)throw new Error('"let" expects an odd number of arguments');const r=new s(t);for(let i=1;i<e.length-1;i+=2){const n=e[i];if("string"!=typeof n)throw new Error(`"let" requires a string to define variable names - found ${n}`);r.add(n,te(e[i+1],t))}const n=te(e[e.length-1],r,i);return new L(n.type,n)}evaluate(e,t){return this._output.evaluate(e,t)}}class I{constructor(e,t){this.type=e,this.output=t}static parse(e,t,i){if(2!==e.length||"string"!=typeof e[1])throw new Error('"var" requires just one literal string argument');const r=t.get(e[1]);if(!r)throw new Error(`${e[1]} must be defined before being used in a "var" expression`);return new I(i||o.valueType,r)}evaluate(e,t){return this.output.evaluate(e,t)}}class R{constructor(e,t,i){this.type=e,this._index=t,this._array=i}static parse(e,t){if(3!==e.length)throw new Error('"at" expects 2 arguments');const i=te(e[1],t,o.numberType),r=te(e[2],t);return new R(r.type.itemType,i,r)}evaluate(e,t){const i=this._index.evaluate(e,t),r=this._array.evaluate(e,t);if(i<0||i>=r.length)throw new Error('"at" index out of bounds');if(i!==Math.floor(i))throw new Error('"at" index must be an integer');return r[i]}}class M{constructor(e,t){this._key=e,this._obj=t,this.type=o.valueType}static parse(e,t){let i,r;switch(e.length){case 2:return i=te(e[1],t),new M(i);case 3:return i=te(e[1],t),r=te(e[2],t),new M(i,r);default:throw new Error('"get" expects 1 or 2 arguments')}}evaluate(e,t){const i=this._key.evaluate(e,t);return this._obj?this._obj.evaluate(e,t)[i]:e?.values[i]}}class A{constructor(e,t){this._key=e,this._obj=t,this.type=o.booleanType}static parse(e,t){let i,r;switch(e.length){case 2:return i=te(e[1],t),new A(i);case 3:return i=te(e[1],t),r=te(e[2],t),new A(i,r);default:throw new Error('"has" expects 1 or 2 arguments')}}evaluate(e,t){const i=this._key.evaluate(e,t);return this._obj?i in this._obj.evaluate(e,t):!!e?.values[i]}}class N{constructor(e,t){this._key=e,this._vals=t,this.type=o.booleanType}static parse(e,t){if(3!==e.length)throw new Error('"in" expects 2 arguments');return new N(te(e[1],t),te(e[2],t))}evaluate(e,t){const i=this._key.evaluate(e,t);return this._vals.evaluate(e,t).includes(i)}}class U{constructor(e,t,i){this._item=e,this._array=t,this._from=i,this.type=o.numberType}static parse(e,t){if(e.length<3||e.length>4)throw new Error('"index-of" expects 3 or 4 arguments');const i=te(e[1],t),r=te(e[2],t);if(4===e.length){const n=te(e[3],t,o.numberType);return new U(i,r,n)}return new U(i,r)}evaluate(e,t){const i=this._item.evaluate(e,t),r=this._array.evaluate(e,t);if(this._from){const n=this._from.evaluate(e,t);if(n!==Math.floor(n))throw new Error('"index-of" index must be an integer');return r.indexOf(i,n)}return r.indexOf(i)}}class C{constructor(e){this._arg=e,this.type=o.numberType}static parse(e,t){if(2!==e.length)throw new Error('"length" expects 2 arguments');const i=te(e[1],t);return new C(i)}evaluate(e,t){const i=this._arg.evaluate(e,t);if("string"==typeof i)return i.length;if(Array.isArray(i))return i.length;throw new Error('"length" expects string or array')}}class V{constructor(e,t,i,r){this.type=e,this._array=t,this._from=i,this._to=r}static parse(e,t){if(e.length<3||e.length>4)throw new Error('"slice" expects 2 or 3 arguments');const i=te(e[1],t),r=te(e[2],t,o.numberType);if(r.type!==o.numberType)throw new Error('"slice" index must return a number');if(4===e.length){const n=te(e[3],t,o.numberType);if(n.type!==o.numberType)throw new Error('"slice" index must return a number');return new V(i.type,i,r,n)}return new V(i.type,i,r)}evaluate(e,t){const i=this._array.evaluate(e,t);if(!Array.isArray(i)&&"string"!=typeof i)throw new Error('"slice" input must be an array or a string');const r=this._from.evaluate(e,t);if(r<0||r>=i.length)throw new Error('"slice" index out of bounds');if(r!==Math.floor(r))throw new Error('"slice" index must be an integer');if(this._to){const n=this._to.evaluate(e,t);if(n<0||n>=i.length)throw new Error('"slice" index out of bounds');if(n!==Math.floor(n))throw new Error('"slice" index must be an integer');return i.slice(r,n)}return i.slice(r)}}class O{constructor(){this.type=o.booleanType}static parse(e){if(1!==e.length)throw new Error('"has-id" expects no arguments');return new O}evaluate(e,t){return void 0!==e?.id}}class B{constructor(e,t){this._args=e,this._calculate=t,this.type=o.numberType}static parse(e,t,i){const r=e.slice(1).map((e=>te(e,t)));return new B(r,i)}evaluate(e,t){let i;return this._args&&(i=this._args.map((i=>i.evaluate(e,t)))),this._calculate(i)}}class k extends B{static parse(e,t){switch(e.length){case 2:return B.parse(e,t,(e=>-e[0]));case 3:return B.parse(e,t,(e=>e[0]-e[1]));default:throw new Error('"-" expects 1 or 2 arguments')}}}class z extends B{static parse(e,t){return B.parse(e,t,(e=>{let t=1;for(const i of e)t*=i;return t}))}}class G extends B{static parse(e,t){if(3===e.length)return B.parse(e,t,(e=>e[0]/e[1]));throw new Error('"/" expects 2 arguments')}}class F extends B{static parse(e,t){if(3===e.length)return B.parse(e,t,(e=>e[0]%e[1]));throw new Error('"%" expects 2 arguments')}}class H extends B{static parse(e,t){if(3===e.length)return B.parse(e,t,(e=>e[0]**e[1]));throw new Error('"^" expects 1 or 2 arguments')}}class W extends B{static parse(e,t){return B.parse(e,t,(e=>{let t=0;for(const i of e)t+=i;return t}))}}class ${constructor(e,t){this._args=e,this._calculate=t,this.type=o.numberType}static{this.ops={abs:e=>Math.abs(e[0]),acos:e=>Math.acos(e[0]),asin:e=>Math.asin(e[0]),atan:e=>Math.atan(e[0]),ceil:e=>Math.ceil(e[0]),cos:e=>Math.cos(e[0]),e:()=>Math.E,floor:e=>Math.floor(e[0]),ln:e=>Math.log(e[0]),ln2:()=>Math.LN2,log10:e=>Math.log(e[0])/Math.LN10,log2:e=>Math.log(e[0])/Math.LN2,max:e=>Math.max(...e),min:e=>Math.min(...e),pi:()=>Math.PI,round:e=>Math.round(e[0]),sin:e=>Math.sin(e[0]),sqrt:e=>Math.sqrt(e[0]),tan:e=>Math.tan(e[0])}}static parse(e,t){const i=e.slice(1).map((e=>te(e,t)));return new $(i,$.ops[e[0]])}evaluate(e,t){let i;return this._args&&(i=this._args.map((i=>i.evaluate(e,t)))),this._calculate(i)}}class Y{constructor(e){this._args=e,this.type=o.stringType}static parse(e,t){return new Y(e.slice(1).map((e=>te(e,t))))}evaluate(e,t){return this._args.map((i=>i.evaluate(e,t))).join("")}}class j{constructor(e,t){this._arg=e,this._calculate=t,this.type=o.stringType}static{this.ops={downcase:e=>e.toLowerCase(),upcase:e=>e.toUpperCase()}}static parse(e,t){if(2!==e.length)throw new Error(`${e[0]} expects 1 argument`);const i=te(e[1],t);return new j(i,j.ops[e[0]])}evaluate(e,t){return this._calculate(this._arg.evaluate(e,t))}}class q{constructor(e){this._args=e,this.type=o.colorType}static parse(e,t){if(4!==e.length)throw new Error('"rgb" expects 3 arguments');const i=e.slice(1).map((e=>te(e,t)));return new q(i)}evaluate(e,i){const r=this._validate(this._args[0].evaluate(e,i)),n=this._validate(this._args[1].evaluate(e,i)),a=this._validate(this._args[2].evaluate(e,i));return new t({r,g:n,b:a})}_validate(e){if("number"!=typeof e||e<0||e>255)throw new Error(`${e}: invalid color component`);return Math.round(e)}}class K{constructor(e){this._args=e,this.type=o.colorType}static parse(e,t){if(5!==e.length)throw new Error('"rgba" expects 4 arguments');const i=e.slice(1).map((e=>te(e,t)));return new K(i)}evaluate(e,i){const r=this._validate(this._args[0].evaluate(e,i)),n=this._validate(this._args[1].evaluate(e,i)),a=this._validate(this._args[2].evaluate(e,i)),o=this._validateAlpha(this._args[3].evaluate(e,i));return new t({r,g:n,b:a,a:o})}_validate(e){if("number"!=typeof e||e<0||e>255)throw new Error(`${e}: invalid color component`);return Math.round(e)}_validateAlpha(e){if("number"!=typeof e||e<0||e>1)throw new Error(`${e}: invalid alpha color component`);return e}}class X{constructor(e){this._color=e,this.type=o.arrayType(o.numberType,4)}static parse(e,t){if(2!==e.length)throw new Error('"to-rgba" expects 1 argument');const i=te(e[1],t);return new X(i)}evaluate(e,i){return new t(this._color.evaluate(e,i)).toRgba()}}class Q{constructor(e,t){this.type=e,this._args=t}static parse(e,t){const i=e[0];if(e.length<2)throw new Error(`${i} expects at least one argument`);let r,n=1;if("array"===i){if(e.length>2){switch(e[1]){case"string":r=o.stringType;break;case"number":r=o.numberType;break;case"boolean":r=o.booleanType;break;default:throw new Error('"array" type argument must be string, number or boolean')}n++}else r=o.valueType;let t;if(e.length>3){if(t=e[2],null!==t&&("number"!=typeof t||t<0||t!==Math.floor(t)))throw new Error('"array" length argument must be a positive integer literal');n++}r=o.arrayType(r,t)}else switch(i){case"string":r=o.stringType;break;case"number":r=o.numberType;break;case"boolean":r=o.booleanType;break;case"object":r=o.objectType}const a=[];for(;n<e.length;n++){const i=te(e[n],t);a.push(i)}return new Q(r,a)}evaluate(e,t){let i;for(const r of this._args){const n=r.evaluate(e,t);if(i=o.getType(n),o.matchType(i,this.type))return n}throw new Error(`Expected ${o.typeToString(this.type)} but got ${o.typeToString(i)}`)}}class Z{static{this.types={"to-boolean":o.booleanType,"to-color":o.colorType,"to-number":o.numberType,"to-string":o.stringType}}constructor(e,t){this.type=e,this._args=t}static parse(e,t){const i=e[0],r=Z.types[i];if(r===o.booleanType||r===o.stringType){if(2!==e.length)throw new Error(`${i} expects one argument`)}else if(e.length<2)throw new Error(`${i} expects at least one argument`);const n=[];for(let i=1;i<e.length;i++){const r=te(e[i],t);n.push(r)}return new Z(r,n)}evaluate(e,i){if(this.type===o.booleanType)return Boolean(this._args[0].evaluate(e,i));if(this.type===o.stringType)return o.valueToString(this._args[0].evaluate(e,i));if(this.type===o.numberType){for(const t of this._args){const r=Number(t.evaluate(e,i));if(!isNaN(r))return r}return null}if(this.type===o.colorType){for(const r of this._args)try{const n=Z.toColor(r.evaluate(e,i));if(n instanceof t)return n}catch{}return null}}static toBoolean(e){return Boolean(e)}static toString(e){return o.valueToString(e)}static toNumber(e){const t=Number(e);if(isNaN(t))throw new Error(`"${e}" is not a number`);return t}static toColor(e){if(e instanceof t)return e;if("string"==typeof e){const i=t.fromString(e);if(i)return i;throw new Error(`"${e}" is not a color`)}if(Array.isArray(e))return t.fromArray(e);throw new Error(`"${e}" is not a color`)}}class J{constructor(e){this._val=e,this.type=o.getType(e)}static parse(e){if(2!==e.length)throw new Error('"literal" expects 1 argument');return new J(e[1])}evaluate(e,t){return this._val}}class ee{constructor(e){this._arg=e,this.type=o.stringType}static parse(e,t){if(2!==e.length)throw new Error('"typeof" expects 1 argument');return new ee(te(e[1],t))}evaluate(e,t){return o.typeToString(o.getType(this._arg.evaluate(e,t)))}}function te(e,t,i){const r=typeof e;if("string"===r||"boolean"===r||"number"===r||null===e){if(i)switch(i.kind){case"string":"string"!==r&&(e=Z.toString(e));break;case"number":"number"!==r&&(e=Z.toNumber(e));break;case"color":e=Z.toColor(e)}e=["literal",e]}if(!Array.isArray(e)||0===e.length)throw new Error("Expression must be a non empty array");const n=e[0];if("string"!=typeof n)throw new Error("First element of expression must be a string");const a=ie[n];if(void 0===a)throw new Error(`Invalid expression operator "${n}"`);if(!a)throw new Error(`Unimplemented expression operator "${n}"`);return a.parse(e,t,i)}const ie={array:Q,boolean:Q,collator:null,format:null,image:null,literal:J,number:Q,"number-format":null,object:Q,string:Q,"to-boolean":Z,"to-color":Z,"to-number":Z,"to-string":Z,typeof:ee,accumulated:null,"feature-state":null,"geometry-type":c,id:l,"line-progress":null,properties:u,at:R,get:M,has:A,in:N,"index-of":U,length:C,slice:V,"!":v,"!=":y,"<":f,"<=":g,"==":d,">":m,">=":_,all:T,any:w,case:x,coalesce:S,match:E,within:null,interpolate:D,"interpolate-hcl":D,"interpolate-lab":D,step:P,let:L,var:I,concat:Y,downcase:j,"is-supported-script":null,"resolved-locale":null,upcase:j,rgb:q,rgba:K,"to-rgba":X,"-":k,"*":z,"/":G,"%":F,"^":H,"+":W,abs:$,acos:$,asin:$,atan:$,ceil:$,cos:$,e:$,floor:$,ln:$,ln2:$,log10:$,log2:$,max:$,min:$,pi:$,round:$,sin:$,sqrt:$,tan:$,zoom:h,"heatmap-density":null,"has-id":O,none:b};e.ALL=T,e.ANY=w,e.Add=W,e.Assert=Q,e.At=R,e.Calculate=$,e.Case=x,e.Coalesce=S,e.Coerce=Z,e.Concat=Y,e.Div=G,e.EQ=d,e.GE=_,e.GT=m,e.GeomType=c,e.Get=M,e.Has=A,e.HasID=O,e.ID=l,e.In=N,e.IndexOf=U,e.Interpolate=D,e.LE=g,e.LT=f,e.Length=C,e.Let=L,e.Literal=J,e.Match=E,e.Mod=F,e.Mul=z,e.NE=y,e.NONE=b,e.NOT=v,e.Pow=H,e.Properties=u,e.Rgb=q,e.Rgba=K,e.Slice=V,e.Step=P,e.String=j,e.Sub=k,e.ToRgba=X,e.TypeOf=ee,e.Var=I,e.Zoom=h,e.createExpression=te,e.ops=ie,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/expression/types":function(){define(["exports","../../../../../Color"],(function(e,t){"use strict";const i={kind:"null"},r={kind:"number"},n={kind:"string"},a={kind:"boolean"},o={kind:"color"},s={kind:"object"},l={kind:"value"};function c(e,t){return{kind:"array",itemType:e,n:t}}const u=[i,r,n,a,o,s,c(l)];e.arrayType=c,e.booleanType=a,e.colorType=o,e.getType=function e(u){if(null===u)return i;if("string"==typeof u)return n;if("boolean"==typeof u)return a;if("number"==typeof u)return r;if(u instanceof t)return o;if(Array.isArray(u)){let t;for(const i of u){const r=e(i);if(t){if(t!==r){t=l;break}}else t=r}return c(t||l,u.length)}return"object"==typeof u?s:l},e.matchType=function e(t,i){if("array"===i.kind)return"array"===t.kind&&(0===t.n&&"value"===t.itemType.kind||e(t.itemType,i.itemType))&&("number"!=typeof i.n||i.n===t.n);if("value"===i.kind)for(const i of u)if(e(t,i))return!0;return i.kind===t.kind},e.nullType=i,e.numberType=r,e.objectType=s,e.stringType=n,e.typeToString=function e(t){if("array"===t.kind){const i=e(t.itemType);return"number"==typeof t.n?`array<${i}, ${t.n}>`:"value"===t.itemType.kind?"array":`array<${i}>`}return t.kind},e.valueToString=function(e){if(null===e)return"";const i=typeof e;return"string"===i?e:"number"===i||"boolean"===i?String(e):e instanceof t?e.toString():JSON.stringify(e)},e.valueType=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}))},"esri/views/2d/engine/vectorTiles/style/StyleProperty":function(){define(["../../../../../Color","../../../../../colorUtils","../GeometryUtils","../expression/expression","../expression/types"],(function(e,t,i,r,n){"use strict";class a{constructor(e,t){let i;switch(this.isDataDriven=!1,this.interpolator=null,e.type){case"number":case"color":i=!0;break;case"array":i="number"===e.value;break;default:i=!1}if((null==t||""===t&&"color"===e.type)&&(t=e.default),Array.isArray(t)&&t.length>0&&r.ops[t[0]]){const i={number:n.numberType,color:n.colorType,string:n.stringType,boolean:n.booleanType,enum:n.stringType};try{const a="array"===e.type?n.arrayType(i[e.value]||n.valueType,e.length):i[e.type],o=r.createExpression(t,null,a);this.getValue=this._buildExpression(o,e),this.isDataDriven=!0,o instanceof r.Interpolate&&o.input instanceof r.Zoom&&(this.interpolator=o)}catch(t){console.log(t.message),this.getValue=this._buildSimple(e.default)}return}i&&"interval"===t.type&&(i=!1);const a=t?.stops&&t.stops.length>0;if(a)for(const i of t.stops)i[1]=this._validate(i[1],e);if(this.isDataDriven=!!t&&!!t.property,this.isDataDriven)if(void 0!==t.default&&(t.default=this._validate(t.default,e)),a)switch(t.type){case"identity":this.getValue=this._buildIdentity(t,e);break;case"categorical":this.getValue=this._buildCategorical(t,e);break;default:this.getValue=i?this._buildInterpolate(t,e):this._buildInterval(t,e)}else this.getValue=this._buildIdentity(t,e);else a?this.getValue=i?this._buildZoomInterpolate(t):this._buildZoomInterval(t):(t=this._validate(t,e),this.getValue=this._buildSimple(t))}_validate(e,t){if("number"===t.type){if(null!=t.minimum&&e<t.minimum)return t.minimum;if(null!=t.maximum&&e>t.maximum)return t.maximum}else"color"===t.type?e=a._parseColor(e):"enum"===t.type?"string"==typeof e&&(e=t.values.indexOf(e)):"array"===t.type&&"enum"===t.value?e=e.map((e=>"string"==typeof e?t.values.indexOf(e):e)):"string"===t.type&&(e=n.valueToString(e));return e}_buildSimple(e){return()=>e}_buildExpression(e,t){return(i,r)=>{try{const n=e.evaluate(r,i);return void 0===n?t.default:this._validate(n,t)}catch(e){return console.log(e.message),t.default}}}_buildIdentity(e,t){return(i,r)=>{let n;return r&&(n=r.values[e.property]),void 0!==n&&(n=this._validate(n,t)),null!=n?n:void 0!==e.default?e.default:t.default}}_buildCategorical(e,t){return(i,r)=>{let n;return r&&(n=r.values[e.property]),n=this._categorical(n,e.stops),void 0!==n?n:void 0!==e.default?e.default:t.default}}_buildInterval(e,t){return(i,r)=>{let n;return r&&(n=r.values[e.property]),"number"==typeof n?this._interval(n,e.stops):void 0!==e.default?e.default:t.default}}_buildInterpolate(e,t){return(i,r)=>{let n;return r&&(n=r.values[e.property]),"number"==typeof n?this._interpolate(n,e.stops,e.base||1):void 0!==e.default?e.default:t.default}}_buildZoomInterpolate(e){return t=>this._interpolate(t,e.stops,e.base||1)}_buildZoomInterval(e){return t=>this._interval(t,e.stops)}_categorical(e,t){const i=t.length;for(let r=0;r<i;r++)if(t[r][0]===e)return t[r][1]}_interval(e,t){const i=t.length;let r=0;for(let n=0;n<i&&t[n][0]<=e;n++)r=n;return t[r][1]}_interpolate(e,t,r){let n,a;const o=t.length;for(let i=0;i<o;i++){const r=t[i];if(!(r[0]<=e)){a=r;break}n=r}if(n&&a){const t=a[0]-n[0],o=e-n[0],s=1===r?o/t:(r**o-1)/(r**t-1);if(Array.isArray(n[1])){const e=n[1],t=a[1],r=[];for(let n=0;n<e.length;n++)r.push(i.interpolate(e[n],t[n],s));return r}return i.interpolate(n[1],a[1],s)}return n?n[1]:a?a[1]:void 0}static _isEmpty(e){for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}static _parseColor(i){return Array.isArray(i)?i:"string"==typeof i?t.parseToUnitRgba(i)??void 0:i instanceof e&&!this._isEmpty(i)?e.toUnitRGBA(i):void 0}}return a}))},"*noref":1}}),define(["../../../chunks/tslib.es6","../../../core/Error","../../../core/has","../../../core/maybe","../../../core/promiseUtils","../../../core/reactiveUtils","../../../core/accessorSupport/decorators/property","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../2d/engine/vectorTiles/SchemaHelper","../../2d/engine/vectorTiles/TileHandler3D","../../2d/engine/vectorTiles/VTLPainter3D","../../2d/engine/vectorTiles/style/StyleRepository","./LayerView3D","./TiledLayerView3D","../terrain/terrainUtils","../../layers/LayerView"],(function(e,t,i,r,n,a,o,s,l,c,u,h,p,d,y,f,g,m){"use strict";let _=class extends(f.TiledLayerView3D(y.LayerView3D(m))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=i("disable-feature:vtl-level-shift")?0:1}initialize(){if(null==this.layer.fullExtent)return void this.addResolvingPromise(Promise.reject(new t("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:e,spatialReference:i,state:r,viewingMode:o}=this.view,s="local"===o&&!g.vtlAssumes256PixelSizeAsDefault(i)||g.test.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),l=this._getTileInfoSupportError(s,this.layer.fullExtent);if(null!=l)return this.addResolvingPromise(Promise.reject(l));const c=a.whenOnce((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const t=e.tilingScheme,i=t.pixelSize,r=256===i?1:2,n=e.spatialReference?.isGeographic&&256===i?1:0,a=e.spatialReference?.isGeographic||256!==i?0:1;let o;this.schemaHelper=new u.SchemaHelper(r,n,this.levelShift+a),o=256===i||512===i?this.layer.tileInfo.getCompatibleForVTL(i):this.layer.tileInfo;const s=this._getTileInfoCompatibilityError(o,t);if(s)throw s;this.tileInfo=o}));this._tileHandlerController=new AbortController;const y=this.view.resourceController;this._memCache=y.memoryController.newCache(`vtl-${this.layer.uid}`,(e=>e.release())),this.addHandles(a.watch((()=>this.view.qualitySettings.memoryLimit),(e=>this._memCache.maxSize=Math.ceil(e/10*1048576)),a.syncAndInitial));const f=new d(this.layer.currentStyleInfo.style);this._tileHandler=new h(this.layer,f,r.contentPixelRatio,this._memCache);const m=this._tileHandlerController.signal,_=function(e){return t=>e.immediate.schedule(t)}(y),v=this._tileHandler.start({signal:m,schedule:_}),T=this._tileHandler.spriteMosaic;T.then((e=>{!n.isAborted(m)&&this._tileHandler&&(this.painter=new p(e,this._tileHandler.glyphMosaic))})),v.then((()=>this._tileHandlerController=null));const w=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const e=this.layer.currentStyleInfo.style,t=this.view.state?.contentPixelRatio??1,i=new d(e),r=new h(this.layer,i,t,this._memCache),n=r.start({signal:this._tileHandlerController.signal,schedule:_}),a=r.spriteMosaic;n.then((()=>this._tileHandlerController=null)),this._updatingHandles.addPromise(Promise.all([n,a]).then((([,e])=>{const t=this._tileHandler,i=this.painter;this.painter=new p(e,r.glyphMosaic),this._tileHandler=r,this.emit("data-changed"),t.destroy(),i&&i.dispose()})))};this._updatingHandles.add((()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio})),w),this.addHandles([this.layer.on("paint-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-change",w),this.layer.on("delete-style-layer",w),this.layer.on("spriteSource-change",(()=>this.emit("data-changed"))),this.layer.on("layout-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-visibility-change",(()=>this.emit("data-changed")))]);const b=Promise.all([c,v,T]);this.addResolvingPromise(b)}destroy(){this.painter=r.disposeMaybe(this.painter),this._tileHandlerController=r.abortMaybe(this._tileHandlerController),this._tileHandler=r.destroyMaybe(this._tileHandler),this._memCache=r.destroyMaybe(this._memCache)}get contentZoom(){return i("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const e=this.tileInfo.lods,t=this.layer.minScale||e[0].scale,i=this.layer.maxScale||e[e.length-1].scale,r=this.levelRangeFromScaleRange(t,i);return this.layer.maxScale?r.maxLevel++:r.maxLevel+=this.levelShift,r}get dataScaleRange(){const e=this.tileInfo.lods;return{minScale:e[0].scale,maxScale:e[e.length-1].scale}}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange,i=this.levelRangeFromScaleRange(e,t);return 1===i.minLevel&&256===this.tileInfo.size[0]&&(i.minLevel=0),i.maxLevel+=this.levelShift,i}async fetchTile(e,t){const i=this.schemaHelper.getLevelRowColumn(e);return this._tileHandler.getVectorTile(i,t)}get hasVisibleFeatures(){return!0}};return e.__decorate([o.property()],_.prototype,"layer",void 0),e.__decorate([o.property()],_.prototype,"levelShift",void 0),e.__decorate([o.property()],_.prototype,"contentZoom",null),e.__decorate([o.property()],_.prototype,"displayLevelRange",null),e.__decorate([o.property()],_.prototype,"tileInfo",void 0),e.__decorate([o.property()],_.prototype,"dataScaleRange",null),e.__decorate([o.property()],_.prototype,"dataLevelRange",null),e.__decorate([o.property()],_.prototype,"updatingProgressValue",void 0),_=e.__decorate([c.subclass("esri.views.3d.layers.VectorTileLayerView3D")],_),_}));