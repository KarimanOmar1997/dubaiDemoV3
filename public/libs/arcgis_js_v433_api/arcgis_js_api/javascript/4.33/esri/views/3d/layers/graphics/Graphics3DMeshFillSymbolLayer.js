// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../Color","../../../../core/has","../../../../core/mathUtils","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/projectionUtils","../../../../geometry/projection/computeTranslationToOriginAndRotation","../../../../geometry/projection/projectBuffer","../../../../geometry/projection/projectVectorToPoint","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/FloatArray","../../../../geometry/support/Indices","../../../../geometry/support/MeshComponent","../../../../geometry/support/MeshMaterialMetallicRoughness","../../../../geometry/support/MeshTextureTransform","../../../../geometry/support/meshVertexSpaceUtils","../../../../geometry/support/spatialReferenceUtils","../../../../chunks/vec3","../../../../geometry/support/meshUtils/projection","../../../../geometry/support/meshUtils/projectMeshVertexPositions","../../../../layers/graphics/dehydratedPoint","../../../../layers/graphics/sources/interfaces","../../../../symbols/support/materialUtils","../../../ViewingMode","../../glTF/internal/resourceUtils","../../glTF/internal/TextureTransformUtils","./defaultSymbolComplexity","./ElevationAligners","./elevationAlignmentUtils","./Graphics3DMeshObject3DGraphicLayer","./Graphics3DObject3DGraphicLayer","./Graphics3DSymbolLayer","./MeshFastUpdateProcessor","./SymbolComplexity","../support/edgeUtils","../support/symbolColorUtils","../../support/debugFlags","../../webgl-engine/lib/Attribute","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/Texture","../../webgl-engine/lib/VertexAttribute","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/NativeLineMaterial","../../webgl-engine/materials/pbrUtils","../../../webgl/enums","../../webgl-engine/lib/IntersectableGeometry"],(function(e,t,r,a,o,n,s,i,l,c,u,m,h,p,f,d,g,x,T,y,b,_,M,A,v,w,C,R,P,E,O,N,S,V,I,U,F,D,j,B,G,L,$,k,H,q,z,W,Y,Z,J,K,Q,X,ee,te,re){"use strict";const ae=["mesh"];class oe extends G.Graphics3DSymbolLayer{constructor(e,t,r,a){super(e,t,r,a,function(e){return 1===(e.material?.color?.a??1)}(t)),this._materialInfoCache=new L.MaterialInfoCache,this._fastUpdateProcessor=new L.MeshFastUpdateProcessor,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){q.debugFlags.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new X.NativeLineMaterial({color:[1,0,1,1]}),this._debugTangentNormalMaterial=new X.NativeLineMaterial({color:[1,.5,0,1]}),this._debugFaceNormalMaterial=new X.NativeLineMaterial({color:[0,1,1,1]})),this.updateComplexity()}destroy(){super.destroy(),this._textures.forEach((e=>e.unload())),this._context.stage.removeTextures(Array.from(this._textures.values())),this._materialInfoCache.clear(),this._textures.clear(),this._fastUpdateProcessor.destroy()}get materials(){return this._materialInfoCache.materials}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,ae,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t),a=e.renderingInfo;return this._createAs3DShape(t,a,r,t.uid)}onRemoveGraphic(e){this._fastUpdateProcessor.onRemoveGraphic(e,this._materialInfoCache)}layerOpacityChanged(e,t){const r=this._getLayerOpacity();this._updateMaterialParameters((e=>{e.material.setParameters({layerOpacity:r});const t=e.material.parameters;this._setMaterialTextureAlphaMode(t,e)})),e?.forEach((e=>t(e)?.layerOpacityChanged(r,this._context.isAsync)))}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,D.needsElevationUpdates3D)}slicePlaneEnabledChanged(e,t){return this._updateMaterialParameters((({material:e})=>{e.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e?.forEach((e=>t(e)?.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync))),!0}physicalBasedRenderingChanged(){const e=this._usePBR();return this._updateMaterialParameters((({material:t})=>t.setParameters({usePBR:e}))),!0}updateTransform(e,t,r,a){if(!e.fastTransformUpdatesAllowed)return!1;const o=e.fastTransformUpdatesEnabled;switch(a){case O.MeshTransformUpdateAction.EnableFastUpdates:if(o)return!0;break;case O.MeshTransformUpdateAction.DisableFastUpdates:if(!o)return!0;break;default:if(!o)return!!this.updateTransform(e,t,r,O.MeshTransformUpdateAction.EnableFastUpdates)&&(e.autoDisableFastTransformUpdates((()=>this.updateTransform(e,t,r,O.MeshTransformUpdateAction.DisableFastUpdates))),!0)}const n=this._context.renderCoordsHelper.spatialReference,s=Ae,{origin:i,transform:l}=r;if(!d.computeTranslationToOriginAndRotation(t,m.set(Te,i.x,i.y,i.z??0),s,n))return!1;switch(a){case O.MeshTransformUpdateAction.EnableFastUpdates:this._fastUpdateProcessor.enable(e,this._materialInfoCache,this._context);break;case O.MeshTransformUpdateAction.DisableFastUpdates:this._fastUpdateProcessor.disable(e,this._materialInfoCache);break;case O.MeshTransformUpdateAction.UpdateFastLocalOrigin:e.updateFastLocalOrigin(s,l,this._context.localOriginFactory)}const{elevationContext:c}=e;c.centerPointInElevationSR=this._getCenterPointInElevationSR(s);const{elevationProvider:u,renderCoordsHelper:h}=this._context;return e.alignedSampledElevation=F.perObjectElevationAligner(e,c,u.spatialReference,((e,t)=>D.evaluateElevationInfoAtPoint(e,u,c,h,t)),h,s),e.updateTransform(s,l,this._context.isAsync),e.updateAutoDisableFastTransformUpdates((()=>this.updateTransform(e,t,r,O.MeshTransformUpdateAction.DisableFastUpdates))),!0}computeComplexity(){if(!this._textures||0===this._textures.size)return super.computeComplexity();let e=0;for(const t of this._textures.values())e+=t.usedMemory;const t={...U.defaultSymbolLayerMemoryComplexity(this.symbol,this.symbolLayer),resourceBytes:e},r=k.hasEdges(this.symbolLayer)?2:0;return new $.SymbolComplexity({drawCallsPerFeature:r,memory:t})}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),a=!!e.vertexAttributes.color,o=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:a,hasVertexTangents:o,uid:`vc:${a},vt:${o},vct${t},svc:${r}`}}_materialProperties(e,t,r){const a=this._materialPropertiesDefault(e,r);if(!t.material)return a;const{color:o,colorTexture:n,colorTextureTransform:s,normalTexture:i,normalTextureTransform:l,doubleSided:c,alphaCutoff:u,alphaMode:m}=t.material,h=fe(o),p=fe(n),f=de(s),d=fe(i),g=de(l);if(a.color=o,a.colorTexture=n,a.normalTexture=i,a.uid=`${a.uid},cmuid:${h},ctmuid:${p},cttuid:${f},ntmuid:${d},nttuid:${g},ds:${c},ac:${u},am:${m}`,t.material instanceof M){const{metallic:e,roughness:r,metallicRoughnessTexture:o,metallicRoughnessTextureTransform:n,emissiveColor:i,emissiveTexture:c,emissiveTextureTransform:u,occlusionTexture:m,occlusionTextureTransform:h}=t.material,p=fe(o),f=de(n),d=fe(i),g=fe(c),x=de(u),T=fe(m),y=de(h);a.metallic=e,a.roughness=r,a.metallicRoughnessTexture=o,a.emissiveColor=i,a.emissiveTexture=c,a.occlusionTexture=m,a.colorTextureTransform=me(s),a.normalTextureTransform=me(l),a.emissiveTextureTransform=me(u),a.occlusionTextureTransform=me(h),a.metallicRoughnessTextureTransform=me(n),a.uid=`${a.uid},mrm:${e},mrr:${r},mrt:${p},mrtt:${f},emuid:${d},etmuid:${g},ett:${x},otmuid:${T},ott:${y}`}return a}_getInternalTexture(e,t=!1,r=W.AlphaDiscardMode.Opaque){const a=(s=e).data??s.url;var s;if(!a)return null;const i=`${e.contentHash}/${r}`;let l=this._textures.get(i);if(l){const e=this._context.stage.renderView.textures;let t=null;const r=e.acquire(l.id);return null==r||n.isPromiseLike(r)||(l.events.on("unloaded",(()=>t=o.releaseMaybe(t))),t=r),l}let c=null;const u=this._context.stage.renderView.renderingContext.parameters.maxMaxAnisotropy,m={wrap:he(e.wrap),noUnpackFlip:!0,maxAnisotropy:u,mipmap:u>1};return V.isEncodedMeshTexture(a)?(c=a.data,m.preMultiplyAlpha=!1,m.encoding=a.encoding):(c=a,m.preMultiplyAlpha=r!==W.AlphaDiscardMode.Opaque,m.compressionOptions=t?{compressionTracker:this._context.compressionTracker,compressionCallback:()=>this.updateComplexity()}:void 0),l=new J.Texture(c,m),this._textures.set(i,l),l.events.on("loaded",(()=>this.updateComplexity())),l.load(this._context.stage.renderView.renderingContext),this._context.stage.addTexture(l),l.events.on("unloaded",(()=>{this._textures.delete(i)})),l}_setInternalMaterialTextureParameters(e,r){if(null!=e.colorTexture){const t=r.textureAlphaMode!==W.AlphaDiscardMode.Opaque,a=this._getInternalTexture(e.colorTexture,t,r.textureAlphaMode);a?(r.textureId=a.id,r.textureAlphaPremultiplied=!!a.parameters.preMultiplyAlpha):r.textureId=void 0}e.normalTexture&&(r.normalTextureId=this._getInternalTexture(e.normalTexture)?.id),e.emissiveColor&&(r.emissiveBaseColor=t.toUnitRGB(e.emissiveColor)),e.emissiveTexture&&(r.emissiveTextureId=this._getInternalTexture(e.emissiveTexture)?.id),e.occlusionTexture&&(r.occlusionTextureId=this._getInternalTexture(e.occlusionTexture,!0)?.id),e.metallicRoughnessTexture&&(r.metallicRoughnessTextureId=this._getInternalTexture(e.metallicRoughnessTexture,!0)?.id)}_setInternalMaterialParameters(e,r,a){null!=e.color&&function(e,r,a){r.diffuse=t.toUnitRGB(e),r.opacity="opaque"===a.alphaMode?1:e.a}(e.color,r,a),this._setInternalMaterialTextureParameters(e,r),r.colorTextureTransformMatrix=I.getTransformMatrix(e.colorTextureTransform),r.normalTextureTransformMatrix=I.getTransformMatrix(e.normalTextureTransform);const o=null!=e.normalTextureTransform?.scale?e.normalTextureTransform?.scale:u.ONES;r.scale=[o[0],o[1]],r.occlusionTextureTransformMatrix=I.getTransformMatrix(e.occlusionTextureTransform),r.emissiveTextureTransformMatrix=I.getTransformMatrix(e.emissiveTextureTransform),r.metallicRoughnessTextureTransformMatrix=I.getTransformMatrix(e.metallicRoughnessTextureTransform)}_setExternalMaterialParameters(e,r=this.symbolLayer?.material?.color){const a=this._drivenProperties.color,o=this._drivenProperties.opacity;let n=this.symbolLayer.material?.colorMixMode??null;if(a)e.externalColor=p.ONES;else{const a=r??null;if(a){const r=t.toUnitRGBA(a);o&&(r[3]=1),e.externalColor=r}else n=null,e.externalColor=p.ONES}n&&(e.colorMixMode=n),e.castShadows=!!this.symbolLayer.castShadows,e.emissiveStrength=this.symbolLayer?.material?.emissive?.strength??1,e.emissiveSource=N.getEmissiveMode(this.symbolLayer?.material?.emissive?.source??"emissive")}_getOrCreateMaterial(e,r){const a=r.material?.color,o=r.material?.colorTexture,n=r.material?.alphaMode,s="blend"===n,i=!("opaque"===n)&&(function(e){const t=e.vertexAttributes.color;if(null==t)return!1;for(let e=3;e<t.length;e+=4)if(255!==t[e])return!0;return!1}(e)||null!=a&&a.a<1||o?.transparent||s),l=this._materialProperties(e,r,i),c=this._materialInfoCache.byUid(l.uid);if(c)return this._setInternalMaterialTextureParameters(l,c.material.parameters),c.material;const u={uid:l.uid,material:null,isComponentTransparent:i,alphaMode:r.material?r.material.alphaMode:"opaque"},m=ee.useSchematicPBR({normalTexture:l.normalTexture,metallicRoughnessTexture:l.metallicRoughnessTexture,metallicFactor:l.metallic,roughnessFactor:l.roughness,emissiveTexture:l.emissiveTexture,emissiveFactor:t.toUnitRGB(l.emissiveColor),occlusionTexture:l.occlusionTexture}),p={usePBR:this._usePBR(),isSchematic:m,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:h.ZEROS,diffuse:h.ONES,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:W.CullFaceOptions.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,drivenOpacity:this.needsDrivenTransparentPass||u.isComponentTransparent};p.mrrFactors=m?ee.schematicMRRFactors:[l.metallic,l.roughness,ee.advancedMRRFactors[2]],r.material&&(p.doubleSided=r.material.doubleSided,p.cullFace=r.material.doubleSided?W.CullFaceOptions.None:W.CullFaceOptions.Back,p.textureAlphaCutoff=r.material.alphaCutoff),this._setExternalMaterialParameters(p),this._setMaterialTextureAlphaMode(p,u),this._setInternalMaterialParameters(l,p,u);const f=new Q.DefaultMaterial(p,this._context);return u.material=f,this._materialInfoCache.set(l.uid,u),f}prepareSymbolLayerPatch(e){if("partial"!==e.diff.type)return;const t=e.diff.diff;this._preparePatchColor(e,t)}_preparePatchColor(e,t){if(!t.material||"partial"!==t.material.type)return;const r=t.material.diff;if(!r.color||"complete"!==r.color.type||null==r.color.newValue||null==r.color.oldValue)return;const a=r.color.newValue;delete r.color,e.symbolLayerStatePatches.push((()=>{this._updateMaterialParameters((e=>{const t=e.material.parameters;this._setExternalMaterialParameters(t,a),this._setMaterialTextureAlphaMode(t,e),e.material.setParameters({externalColor:t.externalColor})}))}))}_usePBR(){return this._context.physicalBasedRenderingEnabled}_setMaterialTextureAlphaMode(e,t){if("auto"===t.alphaMode){const r=this.needsDrivenTransparentPass||t.isComponentTransparent||(e.layerOpacity??1)<1||(e.opacity??1)<1||(e.externalColor?.[3]??1)<1;e.textureAlphaMode=r?W.AlphaDiscardMode.MaskBlend:W.AlphaDiscardMode.Opaque}else e.textureAlphaMode="opaque"===t.alphaMode?W.AlphaDiscardMode.Opaque:"mask"===t.alphaMode?W.AlphaDiscardMode.Mask:W.AlphaDiscardMode.Blend}_createFaceDebugNormals(e,t){const r=t.length,a=e.spatialReference.isGeographic?20015077/180:1,o=.1*Math.max(e.extent.width*a,e.extent.height*a,e.extent.zmax-e.extent.zmin),n=[],l=[],c=t[0].transformation,u=s.normalFromMat4(i.create(),c);for(let e=0;e<r;e++){const r=t[e].attributes.get(K.VertexAttribute.POSITION);if(!r)continue;const a=r.data,s=r.indices;for(let e=0;e<s.length;e+=3)ue(a,s,e,_e),ce(a,s,e,Te,ye,be),m.add(Te,Te,ye),m.add(Te,Te,be),m.scale(Te,Te,1/3),m.transformMat4(Te,Te,c),n.push(...Te),m.transformMat3(_e,_e,u),m.normalize(_e,_e),m.scaleAndAdd(Te,Te,_e,o),n.push(...Te),l.push(l.length),l.push(l.length)}return n.length?new Y.Geometry(this._debugFaceNormalMaterial,[[K.VertexAttribute.POSITION,new z.Attribute(n,l,3,!0)]],null,re.GeometryType.Line):null}_createPerVertexDebugVectors(e,t,r,a,o){const n=t.length,l=e.spatialReference.isGeographic?20015077/180:1,c=.1*o*Math.max(e.extent.width*l,e.extent.height*l,e.extent.zmax-e.extent.zmin),u=[],h=[],p=t[0].transformation,f=s.normalFromMat4(i.create(),p);r===K.VertexAttribute.TANGENT&&s.fromMat4(f,p);for(let e=0;e<n;e++){const a=t[e],o=a.attributes.get(K.VertexAttribute.POSITION),n=a.attributes.get(r);if(!o||!n)continue;const s=o.data,i=o.indices,l=n.data,d=n.indices;for(let e=0;e<i.length;e++){const t=3*i[e],r=d[e]*n.stride;m.set(Te,s[t+0],s[t+1],s[t+2]),m.transformMat4(Te,Te,p),u.push(...Te),m.set(ye,l[r+0],l[r+1],l[r+2]),m.transformMat3(ye,ye,f),m.normalize(ye,ye),m.scaleAndAdd(Te,Te,ye,c),u.push(...Te),h.push(h.length),h.push(h.length)}}return u.length?new Y.Geometry(a,[[K.VertexAttribute.POSITION,new z.Attribute(u,h,3,!0)]],null,re.GeometryType.Line):null}_createAs3DShape(e,t,r,a){const o=e.geometry;if("mesh"!==o.type)return null;const n=this._createGeometryInfo(o,t,a);if(null==n)return null;const{geometries:s,objectTransformation:i}=n;if(q.debugFlags.DRAW_MESH_GEOMETRY_NORMALS){const e=this._createPerVertexDebugVectors(o,s,K.VertexAttribute.NORMAL,this._debugVertexNormalMaterial,1),t=this._createPerVertexDebugVectors(o,s,K.VertexAttribute.TANGENT,this._debugTangentNormalMaterial,.5),r=this._createFaceDebugNormals(o,s);e&&s.push(e),t&&s.push(t),r&&s.push(r)}const l=this._context.layerViewUid,c=new Z.Object3D({geometries:s,layerViewUid:l,graphicUid:a,isElevationSource:!0});c.transformation=i;const u=k.createMaterial(this.symbolLayer,{opacity:this._getLayerOpacity()}),m=u?new B.Object3DEdgeState(s[0].material,u,this._context.slicePlaneEnabled):null,h=new j.Graphics3DMeshObject3DGraphicLayer(this,c,null,F.perObjectElevationAligner,r,m);this._fastUpdateProcessor.onAddGraphic(),h.needsElevationUpdates=D.needsElevationUpdates3D(r.mode),h.useObjectOriginAsAttachmentOrigin=!0,h.fastTransformUpdatesAllowed=this._fastTransformUpdatesAllowed(o),r.centerPointInElevationSR=this._getCenterPointInElevationSR(c.transformation);const{elevationProvider:p,renderCoordsHelper:f}=this._context;return h.alignedSampledElevation=F.perObjectElevationAligner(h,r,p.spatialReference,((e,t)=>D.evaluateElevationInfoAtPoint(e,p,r,f,t)),f),h}_fastTransformUpdatesAllowed(e){const{vertexSpace:t,spatialReference:r}=e;if(!v.isRelativeVertexSpace(t))return!1;const{type:a}=t,{view:o}=this._context.graphicsCoreOwner,{viewingMode:n}=o.state,s=o.spatialReference;return n===S.ViewingMode.Global&&"local"===a||n===S.ViewingMode.Local&&w.equals(s,r)&&"georeferenced"===a&&!r.isGeographic}_getCenterPointInElevationSR(e){const t=E.makeDehydratedPoint(0,0,0,this._context.elevationProvider.spatialReference??null);return x.projectVectorToPoint([e[12],e[13],e[14]],this._context.renderCoordsHelper.spatialReference,t),t}_passthroughReprojectionInfo(e){return e.reprojection===Ce.NONE&&!!e.objectTransformation}_createPositionBuffer(e,t){const r=e.vertexAttributes.position;let a,o=r;if(t.reprojection===Ce.NONE)return{position:o,georeferencedPositionBuffer:a};const n=t.reprojection===Ce.RENDER?t.transformBeforeProject:null;n&&(o=C.transformMat4(new Float64Array(o.length),o,n));const{normal:s,tangent:i}=e.vertexAttributes;this._passthroughReprojectionInfo(t)||!s&&!i||(a=o);const l=o===r||o===a?new Float64Array(o.length):o;return g.projectBuffer(o,e.spatialReference,0,l,this._context.renderCoordsHelper.spatialReference,0),{position:l,georeferencedPositionBuffer:a}}_createNormalBuffer(e,t,r,a){const o=e.vertexAttributes.normal;if(null==o)return null;let n=o;const s=a.reprojection===Ce.RENDER?a.transformBeforeProject:null;s&&(n=R.transformNormal(n,new Float32Array(n.length),s));const i=this._context.graphicsCoreOwner.view.viewingMode;if(a.reprojection===Ce.NONE)return n;if("local"===i){if(!w.isPlateCarree(this._context.renderCoordsHelper.spatialReference))return n;if(null==r)return null;if(e.spatialReference.isGeographic){const e=n===o?new Float32Array(n.length):n;return R.transformVectorENUPlateCarree(n,R.VectorType.NORMAL,r,e)}if(e.spatialReference.isWebMercator){const e=n===o?new Float32Array(n.length):n;return R.transformVectorWMPlateCarree(n,R.VectorType.NORMAL,r,e)}return n}if(null==r)return null;const l=n===o?new Float32Array(n.length):n,c=this._context.renderCoordsHelper.spatialReference;return R.projectNormalToPCPF(n,r,e.spatialReference,t,c,l)}_createTangentBuffer(e,t,r,a){const o=e.vertexAttributes.tangent;if(null==o)return null;let n=o;const s=a.reprojection===Ce.RENDER?a.transformBeforeProject:null;s&&(n=R.transformTangent(n,new Float32Array(n.length),s));const i=this._context.graphicsCoreOwner.view.viewingMode;if(a.reprojection===Ce.NONE)return n;if("local"===i){if(!w.isPlateCarree(this._context.renderCoordsHelper.spatialReference))return n;if(null==r)return null;if(e.spatialReference.isGeographic){const e=n===o?new Float32Array(n.length):n;return R.transformVectorENUPlateCarree(n,R.VectorType.TANGENT,r,e)}if(e.spatialReference.isWebMercator){const e=n===o?new Float32Array(n.length):n;return R.transformVectorWMPlateCarree(n,R.VectorType.TANGENT,r,e)}return n}if(null==r)return null;const l=n===o?new Float32Array(n.length):n,c=this._context.renderCoordsHelper.spatialReference;return R.projectTangentToPCPF(n,r,e.spatialReference,t,c,l)}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e,this._getFallbackOpacityAndColor()),r=H.parseColorMixMode(this.symbolLayer?.material?.colorMixMode),a=new Uint8Array(4);return H.encodeSymbolColor(t,r,a),a}return null}_createBuffers(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const a=e.vertexAttributes.normal,o=e.vertexAttributes.uv,n=e.vertexAttributes.tangent;if(a&&a.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(n&&n.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(o&&o.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const s=this._computeReprojectionInfo(e),{position:i,georeferencedPositionBuffer:l}=this._createPositionBuffer(e,s),u=function(e){return e.vertexAttributes.color}(e),m=this._createSymbolColorBuffer(t),h=this._createNormalBuffer(e,i,l,s),p=this._createTangentBuffer(e,i,l,s),f=o,{transformation:d,position:g,normal:x,tangent:T}=this._passthroughReprojectionInfo(s)?{transformation:s.objectTransformation,position:i,normal:h,tangent:p}:this._transformOriginLocal(e,i,h,p);return{positionBuffer:g,normalBuffer:x,tangentBuffer:T,uvBuffer:f,colorBuffer:u,symbolColorBuffer:m,objectTransformation:d,geometryTransformation:s.reprojection===Ce.NONE&&s.geometryTransformation?s.geometryTransformation:c.create()}}_computeReprojectionInfo(e){const{vertexSpace:t}=e,r="georeferenced"===t.type?w.equals(this._context.renderCoordsHelper.spatialReference,e.spatialReference)?Ce.NONE:Ce.RENDER:Ce.NONE;if(v.isAbsoluteVertexSpace(t))return{reprojection:r};const a=t.origin,o=c.create(),n=e.transform?.localMatrix??c.IDENTITY;if(r===Ce.NONE)return d.computeTranslationToOriginAndRotation(e.spatialReference,a,o,this._context.renderCoordsHelper.spatialReference),{reprojection:r,objectTransformation:o,geometryTransformation:c.clone(n)};const s=l.fromTranslation(c.create(),a);return l.multiply(s,s,n),{reprojection:r,transformBeforeProject:s}}_transformOriginLocal(e,t,r,a){const o=this._context.renderCoordsHelper.spatialReference,n=e.origin;xe[0]=n.x,xe[1]=n.y,xe[2]=n.z??0;const s=c.create();d.computeTranslationToOriginAndRotation(e.spatialReference,xe,s,o),l.invert(Me,s);const{position:i,normal:u,tangent:m}=e.vertexAttributes,h=t===i?new Float64Array(t.length):t;C.transformMat4(h,t,Me);const p=r?r===u?new Float32Array(r.length):r:null,f=a?a===m?new Float32Array(a.length):a:null;return r&&p&&R.transformNormal(r,p,Me),a&&f&&R.transformTangent(a,f,Me),{transformation:s,position:h,normal:p,tangent:f}}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,a=t.faces;if(a){let e=-1;for(let t=0;t<a.length;t++){const r=a[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes?.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference,a=P.projectMeshVertexPositions(e,r??e.spatialReference);return!!a&&(T.fromBuffer(a,ve),!T.intersectsClippingArea(ve,this._context.clippingExtent))}_createGeometryInfo(e,t,r){if(!f.canProjectWithoutEngine(e.spatialReference,this._context.renderCoordsHelper.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(!this._validateVertexSpace(e))return null;if(this._isOutsideClippingArea(e))return null;const a=this._createBuffers(e,t);if(null==a)return null;const{positionBuffer:o,uvBuffer:n,colorBuffer:s,symbolColorBuffer:i,normalBuffer:c,tangentBuffer:u,objectTransformation:m,geometryTransformation:h}=a,p=e.components??we,d=new Array;let g=!1;const x=l.getTranslation(Te,m),T=this._context.localOriginFactory.getOrigin(x);for(const t of p){if(!this._validateFaces(e,t))return null;const a=se(e,t);if(0===a.length)continue;const l=ie(o,c,t,a);l.didFlipNormals&&(g=!0);const m=[[K.VertexAttribute.POSITION,new z.Attribute(o,a,3,!0)],[K.VertexAttribute.NORMAL,new z.Attribute(l.normals,l.indices,3,!0)]];s&&m.push([K.VertexAttribute.COLOR,new z.Attribute(s,a,4,!0)]),i&&m.push([K.VertexAttribute.SYMBOLCOLOR,new z.Attribute(i,b.getZeroIndexArray(a.length),4,!0)]),n&&m.push([K.VertexAttribute.UV0,new z.Attribute(n,a,2,!0)]),u&&m.push([K.VertexAttribute.TANGENT,new z.Attribute(u,a,4,!0)]);const p=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:r,layerViewUid:this._context.layerViewUid}),f=this._getOrCreateMaterial(e,t),x=new Y.Geometry(f,m,null,re.GeometryType.Mesh,p);x.transformation=h,x.localOrigin=T,d.push(x)}return g&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:d,objectTransformation:m}}_updateMaterialParameters(e){this._materialInfoCache.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachClonedMaterial(((e,t)=>{t.setParameters(e.parameters)}))}_validateVertexSpace(e){const{_context:{graphicsCoreOwner:{view:{state:{viewingMode:t}}}}}=this,{vertexSpace:r}=e;return t!==S.ViewingMode.Local||"local"!==r.type||(this.logger.warn("Displaying a mesh with a local vertex space in a view in local viewing mode is not supported."),!1)}test(){return{...super.test(),materials:this._materialInfoCache.materials}}_getFallbackOpacityAndColor(){const e=this.symbolLayer?.material?.color;return t.toUnitRGBA(e)??p.ZEROS}}class ne{constructor(e,t,r){this.normals=e,this.indices=t,this.didFlipNormals=r}}function se(e,t){return t.faces??b.getContinuousIndexArray(e.vertexAttributes.position.length/3)}function ie(e,t,r,a){switch(r.shading||"flat"){default:case"source":return function(e,t,r,a){if(null==t)return le(e,a);let o=!1;if(!r.trustSourceNormals)for(let r=0;r<a.length;r+=3){ue(e,a,r,_e);for(let e=0;e<3;e++){const n=3*a[r+e];Te[0]=t[n],Te[1]=t[n+1],Te[2]=t[n+2],m.dot(_e,Te)<0&&(t[n]=-t[n],t[n+1]=-t[n+1],t[n+2]=-t[n+2],o=!0)}}return new ne(t,a,o)}(e,t,r,a);case"flat":return le(e,a);case"smooth":return function(e,t){const r={};for(let a=0;a<t.length;a+=3){const o=ue(e,t,a,_e);for(let e=0;e<3;e++){const n=t[a+e];let s=r[n];s||(s={normal:h.create(),count:0},r[n]=s),m.add(s.normal,s.normal,o),s.count++}}const a=y.newFloatArray(3*t.length),o=new Array(3*t.length);for(let e=0;e<t.length;e++){const n=r[t[e]];1!==n.count&&(m.normalize(n.normal,n.normal),n.count=1);for(let t=0;t<3;t++)a[3*e+t]=n.normal[t];o[e]=e}return new ne(a,o,!1)}(e,a)}}function le(e,t){const r=y.newFloatArray(t.length),a=new Array(3*t.length);for(let o=0;o<t.length;o+=3){const n=ue(e,t,o,_e);for(let e=0;e<3;e++)r[o+e]=n[e],a[o+e]=o/3}return new ne(r,a,!1)}function ce(e,t,r,a,o,n){const s=3*t[r],i=3*t[r+1],l=3*t[r+2];a[0]=e[s],a[1]=e[s+1],a[2]=e[s+2],o[0]=e[i],o[1]=e[i+1],o[2]=e[i+2],n[0]=e[l],n[1]=e[l+1],n[2]=e[l+2]}function ue(e,t,r,a){return ce(e,t,r,Te,ye,be),m.subtract(ye,ye,Te),m.subtract(be,be,Te),m.cross(Te,ye,be),m.normalize(a,Te),a}function me(e){if(!e)return null;const{scale:t,offset:r,rotation:o}=e;return{scale:t,offset:r,rotation:a.deg2rad(o)}}function he(e="repeat"){if("string"==typeof e){const t=pe(e);return{s:t,t}}return{s:pe(e.horizontal),t:pe(e.vertical)}}function pe(e){switch(e){case"clamp":return te.TextureWrapMode.CLAMP_TO_EDGE;case"mirror":return te.TextureWrapMode.MIRRORED_REPEAT;default:return te.TextureWrapMode.REPEAT}}function fe(e){return null==e?"-":e instanceof t?e.toHex():e.contentHash}function de(e){const{offset:t,scale:r,rotation:a}=e??ge;return`${t[0]},${t[1]},${a},${r[0]},${r[1]}`}const ge=new A,xe=h.create(),Te=h.create(),ye=h.create(),be=h.create(),_e=h.create(),Me=c.create(),Ae=c.create(),ve=T.create(),we=[new _];var Ce;!function(e){e[e.NONE=0]="NONE",e[e.RENDER=1]="RENDER"}(Ce||(Ce={})),e.Graphics3DMeshFillSymbolLayer=oe,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));