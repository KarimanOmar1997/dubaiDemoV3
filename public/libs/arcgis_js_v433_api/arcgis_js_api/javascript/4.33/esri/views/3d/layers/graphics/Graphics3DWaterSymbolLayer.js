// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../Color","../../../../core/unitUtils","../../../../chunks/earcut","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec42","../../../../core/libs/gl-matrix-2/math/common","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/FloatArray","./ElevationAligners","./elevationAlignmentUtils","./Graphics3DDrapedGraphicLayer","./Graphics3DObject3DGraphicLayer","./Graphics3DSymbolLayer","./polygonUtils","../../support/renderInfoUtils/polygon","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/RenderGeometry","../../webgl-engine/materials/WaterMaterial","../../webgl-engine/materials/internal/waterMaterialUtils"],(function(e,t,r,n,o,a,i,s,l,c,h,d,p,u,y,g,m,v,b,x,f,D){"use strict";const _=["polyline","polygon","extent"];class S extends g.Graphics3DSymbolLayer{static{this.unitSizeOfTexture=100}static{this.elevationModeChangeTypes={definedChanged:p.SymbolUpdateType.RECREATE,staysOnTheGround:p.SymbolUpdateType.NONE,onTheGroundChanged:p.SymbolUpdateType.RECREATE}}constructor(e,t,r,n){super(e,t,r,n)}async doLoad(){}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,_,this.symbolLayer.type))return null;const r=this.setGraphicElevationContext(t);return this.ensureDrapedStatus("on-the-ground"===r.mode),this.ensureMaterial(),this.draped?this._createAsOverlay(t):this._createAs3DShape(t,r,t.uid)}ensureMaterial(){if(this._materials[0])return;const e=new f.Parameters,r=this.symbolLayer.color;null!=r&&(e.color=t.toUnitRGBA(r));const n=this._getCombinedOpacity(r,{hasIntrinsicColor:!0});e.color=[e.color[0],e.color[1],e.color[2],n],e.transparent=n<1||this.needsDrivenTransparentPass,e.waveDirection=null!=this.symbolLayer.waveDirection?C(this.symbolLayer.waveDirection):a.fromValues(0,0);const o=this.symbolLayer.waveStrength+"-"+this.symbolLayer.waterbodySize,i=D.wavePresets[o];e.waveStrength=i.waveStrength,e.waveTextureRepeat=i.textureRepeat,e.waveVelocity=i.waveVelocity,e.flowStrength=i.perturbationStrength,e.hasSlicePlane=this._context.slicePlaneEnabled,e.draped=this.draped,this._materials[0]=new f.WaterMaterial(e,this._context)}layerOpacityChanged(){if(null==this._materials[0])return;const e=this._materials[0].parameters.color,t=this._getCombinedOpacity(this.symbolLayer.color,{hasIntrinsicColor:!0}),r=t<1||this.needsDrivenTransparentPass;this._materials[0].setParameters({color:[e[0],e[1],e[2],t],transparent:r})}layerElevationInfoChanged(e,t,r){const n=this._elevationContext.mode,o=p.elevationModeChangeUpdateType(S.elevationModeChangeTypes,r,n);if(o!==p.SymbolUpdateType.UPDATE)return o;const a=p.needsElevationUpdates2D(n);return this.updateGraphics3DGraphicElevationInfo(e,t,(()=>a))}slicePlaneEnabledChanged(){return this._materials[0]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return!0}_createAs3DShape(e,t,r){const n=m.geometryAsPolygon(e.geometry);if(null==n)return null;const o=v.geometryToRenderInfo(n,this._context.elevationProvider,this._context.renderCoordsHelper,t),a=o.position.length/3,i=h.newFloatArray(2*a);w(i,o.mapPositions,a,this._context.elevationProvider.spatialReference);const s=new L(o,i,this._context.layerViewUid,e.uid);if(s.objectAndLayerIdColor=this._context.stage.renderView?.getObjectAndLayerIdColor(s),this._create3DShapeGeometries(s),this._logGeometryCreationWarnings(s.renderData,n.rings,"rings","WaterSymbol3DLayer"),0===s.outGeometries.length)return null;const l=new b.Object3D({geometries:s.outGeometries,castShadow:!1,layerViewUid:this._context.layerViewUid,graphicUid:r}),c=new y.Graphics3DObject3DGraphicLayer(this,l,null,d.perVertexElevationAligner,t);return c.alignedSampledElevation=s.renderData.sampledElevation,c.needsElevationUpdates=p.needsElevationUpdates2D(t.mode),c}_create3DShapeGeometries(e){const t=e.renderData.polygons,r=e.uvCoords;for(const{count:o,index:a,position:i,mapPositions:s,holeIndices:c}of t){if(null!=this._context.clippingExtent&&(l.fromBuffer(s,E),!l.intersectsClippingArea(E,this._context.clippingExtent)))continue;const t=n.earcut(s,c,3);if(0===t.length)continue;const d=h.floatSubArray(r,2*a,2*o),p=m.createWaterGeometry({material:this._materials[0],indices:t,mapPositions:s,attributeData:{position:i,uv0:d}},e.objectAndLayerIdColor);e.outGeometries.push(p)}}_createAsOverlay(e){const t=m.geometryAsPolygon(e.geometry);if(null==t)return null;this._materials[0].renderPriority=this._renderPriority;const r=v.geometryToRenderInfoDraped(t,this._context.overlaySR),n=r.position.length/3,o=h.newFloatArray(2*n);w(o,r.position,n,this._context.overlaySR);const a=new T(r,o,this._context.layerViewUid,e.uid);return a.objectAndLayerIdColor=this._context.stage.renderView?.getObjectAndLayerIdColor(a),a.outBoundingBox=l.empty(),this._createAsOverlayWater(a),this._logGeometryCreationWarnings(a.renderData,t.rings,"rings","WaterSymbol3DLayer"),0===a.outGeometries.length?null:new u.Graphics3DDrapedGraphicLayer(this,a.outGeometries,a.outBoundingBox,this._context.drapeSourceRenderer)}_createAsOverlayWater(e){const t=e.uvCoords,r=e.renderData.polygons;for(const{position:o,holeIndices:a,index:i,count:s}of r){if(l.fromBuffer(o,E),!l.intersectsClippingArea(E,this._context.clippingExtent))continue;l.expandWithAABB(e.outBoundingBox,E);const r=n.earcut(o,a,3);if(0===r.length)continue;const c=h.floatSubArray(t,2*i,2*s),d=m.createWaterGeometry({material:this._materials[0],indices:r,attributeData:{position:o,uv0:c}},e.objectAndLayerIdColor);e.outGeometries.push(new x.RenderGeometry(d,e))}}test(){return{...super.test(),create3DShape:e=>this._createAs3DShape(e.graphic,e.elevationContext,e.graphicUid),ensureMaterial:()=>this.ensureMaterial()}}}function C(e){const t=a.create(),r=s.toRadian(e);return t[0]=Math.sin(r),t[1]=Math.cos(r),t}function w(e,t,n,a){const s=r.getMetersPerUnitForSR(a);c.empty(A);for(let e=0;e<n;e++)o.set(P,t[3*e],t[3*e+1]),c.expandPointInPlace(A,P);i.scale(A,A,s);const l=A[0]%S.unitSizeOfTexture,h=A[1]%S.unitSizeOfTexture;G[0]=A[0]-l,G[1]=A[1]-h;for(let r=0;r<n;r++)e[2*r]=(t[3*r]*s-G[0])/S.unitSizeOfTexture,e[2*r+1]=(t[3*r+1]*s-G[1])/S.unitSizeOfTexture}const G=a.create(),A=c.create(),P=a.create(),E=l.create();class L extends m.PolygonCreationDataBase{constructor(e,t,r,n){super(e,r,n),this.uvCoords=t}}class T extends m.PolygonCreationDataBase{constructor(e,t,r,n){super(e,r,n),this.uvCoords=t}}e.Graphics3DWaterSymbolLayer=S,e.headingVectorFromAngle=C,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));