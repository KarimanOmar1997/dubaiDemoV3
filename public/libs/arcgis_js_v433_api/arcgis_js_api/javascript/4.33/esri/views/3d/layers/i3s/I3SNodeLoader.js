// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../core/asyncUtils","../../../../core/has","../../../../core/lang","../../../../core/promiseUtils","../../../../core/urlUtils","./enums","./I3SBinaryReader","./I3SMaterialUtil"],(function(e,t,r,i,n,s,o,a){"use strict";class u{constructor(e,t,r,i,n,s){if(this._streamDataController=t,this._logger=r,this._defaultGeometrySchema=i,this._requiredAttributes=n,this._options=s,this._logLayer=e,this._layerUrl=e.parsedUrl.path,this._geometryDefinitions=e.geometryDefinitions,e.materialDefinitions){const t=e.textureSetDefinitions;this._materialAndTextures=e.materialDefinitions.map((r=>a.getMaterialAndTextures(t,r,"integrated-mesh"===e.type)))}}_load(e,t,r){return this._streamDataController.request(e,t,r)}_loadAttribute(e,t,r){const i=`${this._layerUrl}/nodes/${e.resources.attributes}/attributes/${t.key}/0`;return this._load(i,"binary",r).then((e=>o.readBinaryAttribute(t,e)))}async loadAttributes(e,t,r){const n=await Promise.allSettled(t.map((t=>this._loadAttribute(e,t.attributeStorageInfo,r)))),s={};for(let r=0;r<t.length;++r){const o=n[r],a=t[r];if("fulfilled"===o.status){const e=o.value;s[a.name]=e}else{const t=o.reason;i.throwIfAbortError(t),this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${a.name}' on node '${e.id}'`,t)}}return s}async loadNodeData(i,n){const s=null!=this._requiredAttributes&&i.resources.attributes?e.result(this.loadAttributes(i,this._requiredAttributes,n)):null,{bufferDefinition:u,bufferIndex:l}=function(e,r){const i={bufferDefinition:null,bufferIndex:0},n=r.resources.geometryDefinition;if(null==e||null==n||n<0)return i;const s=n>=0?e[n].geometryBuffers:null;if(null==s)return i;for(let e=0;e<s.length;e++){const r=s[e];if(null==r.compressedAttributes)i.bufferIndex=e,i.bufferDefinition=s[e];else if("draco"===r.compressedAttributes.encoding&&!t("disable-feature:i3s-draco"))return i.bufferIndex=e,i.bufferDefinition=r,i}return i}(this._geometryDefinitions,i),d=!!i.resources.geometry,f=d?e.result(this._loadGeometry(i.resources.geometry,l,n)):null,c=i.resources.hasSharedResource?await this._loadShared(i,n):null,h=i.resources.materialDefinition,g=this._materialAndTextures&&null!=h&&h>=0?this._materialAndTextures[h]:null!=c?a.getMaterialAndTexturesFromShared(c):null,m=g?.material,_=g?.textures??[],y=`${i.id}`,b=!d&&this._options.loadFeatureData,D=b?await this._loadFeatureData(y,n):null,x=b?function(e){if(!e)return null;for(const t of e.featureData){const e=t.geometries;if(null!=e)for(const r of e)return{featureIds:[t.id],featureDataPosition:t.position,geometries:[r]}}return null}(D):function(e){return{featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:e}}],featureDataPosition:[0,0,0]}}(m),A=null==x?function(e){if(!e)return null;const t=new Array;for(const r of e.featureData)null!=r.position&&t.push({featureIds:[r.id],featureDataPosition:r.position,geometries:[]});return t}(D):null,p=_.length>0?e.result(this.loadTextures(i,_,n)):null;let T=null,$=null;if(f){T=e.assertResult(await f);const t=function(e,t){if(!e||!t?.materialDefinitions)return e;const i=Object.keys(t.materialDefinitions)[0];return!t.materialDefinitions[i].params.vertexRegions&&e.vertexAttributes.region&&delete(e=r.clone(e)).vertexAttributes.region,e}(this._defaultGeometrySchema,c);$=o.createGeometryDescriptor(u,t)}const w=p?e.assertResult(await p):null,I=s?e.assertResult(await s):{},S=I?{attributeData:I,loadedAttributes:this._requiredAttributes}:null;if(null!=x)return{geometryData:x,attributeDataInfo:S,geometryBuffer:T,geometryDescriptor:$,requiredTextures:_,textureData:w};if(null!=A)return{pointData:A,attributeDataInfo:S,geometryBuffer:T,geometryDescriptor:$,requiredTextures:_,textureData:w};throw new Error}static _addAbsoluteHrefTexture(e,t){const r=e.textureDefinitions;if(null!=r)for(const e of Object.keys(r))for(const i of r[e].images)Array.isArray(i.href)?i.hrefConcat=i.href.map((e=>n.makeAbsolute(e,t))):i.hrefConcat=n.makeAbsolute(i.href,t)}static _fixTextureEncodings(e){const t=e.textureDefinitions;if(null!=t)for(const e in t){const r=t[e];if(Array.isArray(r.encoding))for(let e=0;e<r.encoding.length;e++){const t=r.encoding[e];"data:"===t.slice(0,5)&&(r.encoding[e]=t.slice(5))}else{const e=r.encoding;"data:"===e.slice(0,5)&&(r.encoding=e.slice(5))}}}async _loadShared(e,t){if(null==e.resources.geometry)return{};const r=`${this._layerUrl}/nodes/${e.resources.geometry}/shared`,i=await this._load(r,"json",t);return u._fixTextureEncodings(i),u._addAbsoluteHrefTexture(i,r),i}_loadTexture(e,t,r,i,n){return i===s.TextureEncoding.DDS_S3TC||i===s.TextureEncoding.KTX2||i===s.TextureEncoding.Basis?this._load(e,"binary",n).then((e=>({id:t,usage:r,data:e,encoding:i}))):this._load(e,"image",n).then((e=>({id:t,usage:r,data:e,encoding:i})))}loadTextures(e,t,r){const i=this._options.textureUsageMask;return Promise.all(t.map((t=>{if(0===(t.usage&i))return null;const n=a.selectEncoding(t.encodings,this._options.textureEncodings);if(null==n)return this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${e.id}`),Promise.reject();const s=e.resources.texture||e.id,o=`${this._layerUrl}/nodes/${s}/textures/${n.name}`;return this._loadTexture(o,t.id,t.usage,n.encoding,r)})))}_loadFeatureData(e,t){const r=`${this._layerUrl}/nodes/${e}/features/0`;return this._load(r,"json",t)}_loadGeometry(e,t,r){const i=`${this._layerUrl}/nodes/${e}/geometries/${t}`;return this._load(i,"binary",r)}}return u}));