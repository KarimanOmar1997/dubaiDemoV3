// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/has","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/vec42","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../renderers/support/lengthUtils","../../../../support/guards","../../support/debugFlags","../../webgl-engine/effects/geometry/olidUtils","../../../webgl/NoParameters"],(function(e,t,o,i,n,s,r,a,l,u,c,f,p,d,z,S){"use strict";var m,y;e.FastSizeType=void 0,(m=e.FastSizeType||(e.FastSizeType={}))[m.Undefined=0]="Undefined",m[m.DefinedSize=1]="DefinedSize",m[m.DefinedScale=2]="DefinedScale",e.FastRotationType=void 0,(y=e.FastRotationType||(e.FastRotationType={}))[y.Undefined=0]="Undefined",y[y.DefinedAngle=1]="DefinedAngle";class v{constructor(e){this.field=e}}class h extends v{constructor(t){super(t),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[e.FastSizeType.Undefined,e.FastSizeType.Undefined,e.FastSizeType.Undefined],this.fallback=[0,0,0]}}class b extends v{constructor(e){super(e),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0],this.fallback=[0,0,0,0]}}class g extends v{constructor(e,t=0){super(e),this.fallback=t,this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class x{}function F(e){return null!=e}function T(e,t){e&&e.push(t)}function C(t,o,i,n,s){const r=t.minSize,a=t.maxSize;if(t.useSymbolValue){const t=n.symbolSize[i];return o.minSize[i]=t,o.maxSize[i]=t,o.offset[i]=o.minSize[i],o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0}if(F(t.field))return F(t.stops)?2===t.stops.length&&p.isNumber(t.stops[0].size)&&p.isNumber(t.stops[1].size)?(k(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,o,i),o.type[i]=e.FastSizeType.DefinedSize,!0):(T(s,"Could not convert size info: stops only supported with 2 elements"),!1):p.isNumber(r)&&p.isNumber(a)&&F(t.minDataValue)&&F(t.maxDataValue)?(k(r,a,t.minDataValue,t.maxDataValue,o,i),o.type[i]=e.FastSizeType.DefinedSize,!0):"unknown"===t.valueUnit?(T(s,"Could not convert size info: proportional size not supported"),!1):null!=f.meterIn[t.valueUnit]?(o.minSize[i]=-1/0,o.maxSize[i]=1/0,o.offset[i]=0,o.factor[i]=1/f.meterIn[t.valueUnit],o.type[i]=e.FastSizeType.DefinedSize,!0):(T(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!F(t.field)){if(t.stops?.[0]&&p.isNumber(t.stops[0].size))return o.minSize[i]=t.stops[0].size,o.maxSize[i]=t.stops[0].size,o.offset[i]=o.minSize[i],o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0;if(p.isNumber(r))return o.minSize[i]=r,o.maxSize[i]=r,o.offset[i]=r,o.factor[i]=0,o.type[i]=e.FastSizeType.DefinedSize,!0}return T(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function k(e,t,o,i,n,s){const r=Math.abs(i-o)>0?(t-e)/(i-o):0;n.minSize[s]=r>0?e:t,n.maxSize[s]=r>0?t:e,n.offset[s]=e-o*r,n.factor[s]=r}function U(e,t,o){e[4*t]=o.r/255,e[4*t+1]=o.g/255,e[4*t+2]=o.b/255,e[4*t+3]=o.a}function V(e,t,o){const i=2===o&&"arithmetic"===e.rotationType;t.offset[o]=i?90:0,t.factor[o]=i?-1:1,t.type[o]=1}function D(t,o,i){if(!t)return null;const n=t.reduce(((e,t)=>{if(!e)return e;if(t.valueExpression)return T(i,"Could not convert visual variables: arcade expressions not supported"),null;switch(t.type){case"size":return o.supports.size?function(e,t,o,i){if(e.normalizationField||e.valueRepresentation)return T(i,"Could not convert size info: unsupported property"),null;if(!p.isStringOrNull(e.field))return T(i,"Could not convert size info: field is not a string"),null;if(t.size){if(e.field)if(t.size.field){if(e.field!==t.size.field)return T(i,"Could not convert size info: multiple fields in use"),null}else t.size.field=e.field}else t.size=new h(e.field),a.copy(t.size.fallback,o.fallbackSize);let n;switch(e.axis){case"width":return n=C(e,t.size,0,o,i),n?t:null;case"height":return n=C(e,t.size,2,o,i),n?t:null;case"depth":return n=C(e,t.size,1,o,i),n?t:null;case"width-and-depth":return n=C(e,t.size,0,o,i),n&&C(e,t.size,1,o,i),n?t:null;case null:case void 0:case"all":return n=C(e,t.size,0,o,i),n=n&&C(e,t.size,1,o,i),n=n&&C(e,t.size,2,o,i),n?t:null;default:return T(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}(t,e,o,i):e;case"color":return o.supports.color?function(e,t,o,i){if(e.normalizationField)return T(i,"Could not convert color info: unsupported property"),null;if(p.isString(e.field)){if(!e.stops)return T(i,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return T(i,"Could not convert color info: too many color stops"),null;t.color=new b(e.field);const n=e.stops;for(let e=0;e<8;++e){const o=n[Math.min(e,n.length-1)];t.color.values[e]=o.value,U(t.color.colors,e,o.color)}u.copy(t.color.fallback,o.fallbackColor)}}else{if(!(e.stops&&e.stops.length>=0))return T(i,"Could not convert color info: no field and no colors/stops"),null;{const i=e.stops&&e.stops.length>=0&&e.stops[0].color;t.color=new b(null);for(let e=0;e<8;e++)t.color.values[e]=1/0,U(t.color.colors,e,i);u.copy(t.color.fallback,o.fallbackColor)}}return t}(t,e,o,i):e;case"opacity":return o.supports.opacity?function(e,t,o,i){if(e.normalizationField)return T(i,"Could not convert opacity info: unsupported property"),null;if(p.isString(e.field)){if(!e.stops)return T(i,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return T(i,"Could not convert opacity info: too many opacity stops"),null;t.opacity=new g(e.field,o.fallbackColor[3]);const n=e.stops;for(let e=0;e<8;++e){const o=n[Math.min(e,n.length-1)];t.opacity.values[e]=o.value,t.opacity.opacityValues[e]=o.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return T(i,"Could not convert opacity info: no field and no opacities/stops"),null;{const i=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;t.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0],fallback:o.fallbackColor[3]};for(let e=0;e<8;e++)t.opacity.values[e]=1/0,t.opacity.opacityValues[e]=i}}return t}(t,e,o,i):null;case"rotation":return o.supports.rotation?function(e,t,o){if(!p.isString(e.field))return T(o,"Could not convert rotation info: field is not a string"),null;if(t.rotation){if(e.field)if(t.rotation.field){if(e.field!==t.rotation.field)return T(o,"Could not convert rotation info: multiple fields in use"),null}else t.rotation.field=e.field}else t.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return V(e,t.rotation,0),t;case"roll":return V(e,t.rotation,1),t;case null:case void 0:case"heading":return V(e,t.rotation,2),t;default:return T(o,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}(t,e,i):e;default:return null}}),new x);return!(t.length>0&&n)||n.size||n.color||n.opacity||n.rotation?n?.size&&!function(t,o,i){for(let i=0;i<3;++i){let n=o.unitInMeters;t.type[i]===e.FastSizeType.DefinedSize&&(n*=o.modelSize[i],t.type[i]=e.FastSizeType.DefinedScale),t.minSize[i]=t.minSize[i]/n,t.maxSize[i]=t.maxSize[i]/n,t.offset[i]=t.offset[i]/n,t.factor[i]=t.factor[i]/n}let n;if(t.type[0]!==e.FastSizeType.Undefined)n=0;else if(t.type[1]!==e.FastSizeType.Undefined)n=1;else{if(t.type[2]===e.FastSizeType.Undefined)return T(i,"No size axis contains a valid size or scale"),!1;n=2}for(let o=0;o<3;++o)t.type[o]===e.FastSizeType.Undefined&&(t.minSize[o]=t.minSize[n],t.maxSize[o]=t.maxSize[n],t.offset[o]=t.offset[n],t.factor[o]=t.factor[n],t.type[o]=t.type[n]);return!0}(n.size,o,i)?null:n:null}class w{constructor(e,t,o){this.visualVariables=e,this.materialParameters=t,this.requiresShaderTransformation=o}}function M(e,t,o){if(!!e!=!!t)return!1;if(e&&e.field!==t?.field)return!1;if(e&&"rotation"===o){const o=e,i=t;for(let e=0;e<3;e++)if(o.type[e]!==i.type[e]||o.offset[e]!==i.offset[e]||o.factor[e]!==i.factor[e])return!1}return!0}class N extends S.NoParameters{constructor(e){super(),this.vvSize=e?.size??null,this.vvColor=e?.color??null,this.vvOpacity=e?.opacity??null}}function I(e,t){const o=new N(e);return o.vvSize&&(o.vvSymbolAnchor=t.anchor,s.identity(E),function(e,t,o,i=r.create()){const n=e||0,a=t||0,l=o||0;0!==n&&s.rotateZ(i,i,-n/180*Math.PI),0!==a&&s.rotateX(i,i,a/180*Math.PI),0!==l&&s.rotateY(i,i,l/180*Math.PI)}(t.rotation[2],t.rotation[0],t.rotation[1],E),o.vvSymbolRotationMatrix=o.vvSymbolRotationMatrix||n.create(),i.fromMat4(o.vvSymbolRotationMatrix,E)),o}function P(e,t,i){if(!t.vvSize)return a.set(e,1,1,1),e;if(Number.isNaN(i[0]))return a.copy(e,t.vvSize.fallback);for(let n=0;n<3;++n){const s=t.vvSize.offset[n]+i[0]*t.vvSize.factor[n];e[n]=o.clamp(s,t.vvSize.minSize[n],t.vvSize.maxSize[n])}return e}const R=r.create(),A=l.create(),E=r.create();e.ConvertOptions=class{constructor({supports:e,modelSize:t,symbolSize:o,unitInMeters:i,anchor:n,scale:s,rotation:r,fallbackColor:a,fallbackSize:u}){this.supports=e,this.modelSize=t??l.ones(),this.symbolSize=o??l.ones(),this.unitInMeters=i??1,this.anchor=n??l.zeros(),this.scale=s??l.ones(),this.rotation=r??l.zeros(),this.fallbackColor=a??c.ones(),this.fallbackSize=u??l.ones()}},e.FastColorInfo=b,e.FastOpacityInfo=g,e.FastRotationInfo=class extends v{constructor(e){super(e),this.offset=[0,0,0],this.factor=[1,1,1],this.type=[0,0,0]}},e.FastSizeInfo=h,e.FastSymbolUpdatesState=w,e.FastVisualVariables=x,e.VisualVariablesParameters=N,e.convertVisualVariables=D,e.evaluateModelTransform=function(e,t,o){if(!e.vvSize)return o;s.copy(R,o);const i=e.vvSymbolRotationMatrix;return s.set(E,i[0],i[1],i[2],0,i[3],i[4],i[5],0,i[6],i[7],i[8],0,0,0,0,1),s.multiply(R,R,E),P(A,e,t),s.scale(R,R,A),s.translate(R,R,e.vvSymbolAnchor),R},e.evaluateModelTransformScale=P,e.getAttributeValue=function(e,t){const o=null==e?0:t.attributes[e];return"number"==typeof o&&isFinite(o)?o:NaN},e.getMaterialParameters=I,e.initFastSymbolUpdatesState=function(e,t){if(!e)return null;if(z.olidEnabled())return null;if(d.debugFlags.TESTS_DISABLE_FAST_UPDATES)return null;const o=D(e.visualVariables,t);return o?new w(o,I(o,t),!!o.size):null},e.updateFastSymbolUpdatesState=function(e,t,o){if(!t||!e)return!1;const i=e.visualVariables,n=D(t.visualVariables,o);return!!n&&!!(M(i.size,n.size,"size")&&M(i.color,n.color,"color")&&M(i.rotation,n.rotation,"rotation")&&M(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=I(n,o),e.requiresShaderTransformation=!!n.size,!0)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));