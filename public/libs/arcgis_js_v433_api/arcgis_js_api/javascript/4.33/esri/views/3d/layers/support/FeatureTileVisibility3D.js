// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/ellipsoidUtils","../../../../geometry/spatialReferenceEllipsoidUtils","../../../../geometry/projection/projectBuffer","../../../../geometry/projection/projectVec3Array","../../../../geometry/support/frustum","../../../../geometry/support/plane","../../../ViewingMode","../../state/Frustum"],(function(e,t,r,n,s,o,i,c,a,u,f){"use strict";function l(e,r,n){return t.cross(e,r,n),t.normalize(e,e),e}function d(e,r,n){return t.sub(e,r,n),t.normalize(e,e),e}function h(e,r){return t.scale(e,e,r/t.len(e)),e}const m=[c.PlaneIndex.LEFT,c.PlaneIndex.RIGHT,c.PlaneIndex.BOTTOM,c.PlaneIndex.TOP,c.PlaneIndex.FAR];function p(e,t,r){for(let n=0;n<r;++n)if(a.signedDistance(e,t[n])<=0)return!1;return!0}function _(e,t,r){for(const n of m)if(p(e[n],t,r))return!0;return!1}function g(e,t,r=t.length){for(let n=0;n<r;++n){const r=t[n];let s=!0;for(const t of e)if(a.signedDistance(t,r)>0){s=!1;break}if(s)return!0}return!1}function b(e,r,n){for(const s of r)if(t.dot(s,e)<n)return!1;return!0}const F=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],M=[0,0,0,0,0,0],S=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],z=r.create(),R=r.create(),V=r.create(),v=r.create(),y=r.create(),x=r.create(),G=r.create(),I=r.create(),A=r.create(),P=r.create(),B=r.create(),T=r.freeze(0,0,0),w=r.create(),D=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],j=[r.create(),r.create(),r.create(),r.create(),r.create()],q=r.create(),C=r.create(),E=r.create(),O=r.create(),L=r.create(),k=r.create(),H=r.create(),Y=r.create(),U=r.create(),W=r.create(),J=[0,1,2,3],K=[0,1,2,3],N=[0,1,3],Q=[0,1,3],X=[1,2,3],Z=[1,2,3],$=r.create(),ee=[0,0];function te(e,r,n,s){const o=n.length,i=s.length;if(0===o||0===i)return!0;const c=W;l(c,e,r);const a=i<o,u=a?n:s,f=ee;return function(e,r,n){let s=1/0,o=-1/0;for(const e of n){const n=t.dot(r,e);s=Math.min(s,n),o=Math.max(o,n)}e[0]=s,e[1]=o}(f,c,a?s:n),function(e,r,n,s){let o=1/0,i=-1/0;for(const c of s){const s=t.dot(n,c);if(o=Math.min(o,s),i=Math.max(i,s),o<=r&&i>=e)return!1}return!0}(f[0],f[1],c,u)}const re=430,ne=r.create(),se=r.create(),oe=Math.cos(.25*Math.PI),ie=r.fromValues(0,0,1),ce=r.create();function ae(e,t,r){const n={t0:0,t1:1};for(const s of m)if(!fe(e[s],t,r,n))return!1;return n.t0<n.t1}function ue(e,t,r){const n={t0:0,t1:1};for(const s of e)if(!fe(s,t,r,n))return!1;return n.t0<n.t1}function fe(e,t,r,n){let{t0:s,t1:o}=n;const i=a.signedDistance(e,t),c=a.signedDistance(e,r);if(i>=0&&c>=0)return!1;if(i<0&&c>=0){const e=-i/(c-i);if(e<s)return!1;e<o&&(o=e)}else if(i>=0&&c<0){const e=i/(i-c);if(e>o)return!1;e>s&&(s=e)}return n.t0=s,n.t1=o,!0}const le=[a.fromValues(-1,0,0,1),a.fromValues(1,0,0,-1),a.fromValues(0,-1,0,1),a.fromValues(0,1,0,-1),a.fromValues(0,0,-1,1),a.fromValues(0,0,1,-1)],de=r.freeze(0,0,1);e.FeatureTileVisibility3D=class{constructor(e,t){this._renderCoordsHelper=e,this.opaqueGround=t,this._cache=new Map,this._cameraForward=r.create(),this._cameraEye=r.create(),this._cameraFovY=55*Math.PI/180,this._frustumBoundingSphereCenter=r.create(),this._frustumBoundingSphereRadius=0,this._frustum=new f.Frustum(e),this._renderSR=e.spatialReference;const o=s.getSphericalPCPF(this._renderSR);this._renderSREllipsoidRadius=n.getReferenceEllipsoid(o).radius}setup(e){this._aboveGround=e.aboveGround,this._frustum.update(e),t.normalize(this._cameraForward,e.viewForward),t.copy(this._cameraEye,e.eye),this._cameraFovY=e.fovY,this._updateFrustumBoundingSphere()}done(){this._cache.clear()}compute(e){if(this._cache.has(e.id))return this._cache.get(e.id);const t=this._isVisibleInFrustum(e);return this._cache.set(e.id,t),t}_isVisibleInFrustum(e){return this._renderCoordsHelper.viewingMode===u.ViewingMode.Local?this._isTileVisibleInFrustumLocal(e):this._isTileVisibleInFrustumGlobal(e)}_updateFrustumBoundingSphere(){const e=this._frustum,r=e.origin,n=I;t.normalize(n,e.direction);const s=e.points,o=A;t.sub(o,s[4],r);const i=.5*t.dot(o,o)/t.dot(n,o),c=this._frustumBoundingSphereCenter;t.scaleAndAdd(c,r,n,i);const a=1+i;this._frustumBoundingSphereRadius=a}_isTileVisibleInFrustumLocal(e){const r=e.spatialReference,n=e.extent,s=this._renderSR;if(M[0]=n[0],M[1]=n[1],M[2]=0,M[3]=n[2],M[4]=n[3],M[5]=0,!o.projectBuffer(M,r,0,M,s,0))return!1;t.set(S[0],M[0],M[1],0),t.set(S[1],M[3],M[1],0),t.set(S[2],M[3],M[4],0),t.set(S[3],M[0],M[4],0),t.set(z,.5*(M[0]+M[3]),.5*(M[1]+M[4]),.5*(M[2]+M[5]));const i=ie,c=.5*t.dist(S[0],S[2]),a=this._frustum,u=this._frustumBoundingSphereRadius,f=this._frustumBoundingSphereCenter,l=B;t.sub(l,f,z);const d=t.dot(i,l),h=P;if(t.scaleAndAdd(h,z,i,d),t.dist(h,f)>c+u)return!1;const m=this._cameraForward,p=ie,b=t.dot(m,p),R=this._cameraFovY,V=this._cameraEye;if(Math.abs(b)<Math.abs(Math.cos(.5*R))){let e=!0;const r=t.set(ce,m[0],m[1],0),n=t.dot(V,r);for(let s=0;s<4;++s){const o=S[s];if(t.dot(o,r)-n>0){e=!1;break}}if(e)return!1}{const e=S[0],t=S[2];if(e[0]<=V[0]&&V[0]<=t[0]&&e[1]<=V[1]&&V[1]<=t[1])return!0}const v=F,y=this.opaqueGround&&this._aboveGround,x=this.opaqueGround&&!this._aboveGround,G=Math.min(x?re:1/0,d+u),I=Math.max(y?-430:-1/0,d-u);for(let e=0;e<4;++e)t.scaleAndAdd(v[e],S[e],i,G),t.scaleAndAdd(v[e+4],S[e],i,I);if(_(a.planes,v,8))return!1;if(g(a.planes,v,8))return!0;for(let e=0;e<4;++e){const t=v[e],r=v[e+4];if(ae(a.planes,t,r))return!0;const n=v[(e+1)%4];if(ae(a.planes,t,n))return!0;const s=v[4+(e+1)%4];if(ae(a.planes,r,s))return!0}if(le[0][3]=+S[0][0],le[1][3]=-S[2][0],le[2][3]=+S[0][1],le[3][3]=-S[2][1],le[4][3]=+I,le[5][3]=-G,g(le,a.points))return!0;if(g(le,a.points))return!0;for(let e=0;e<4;++e){const t=V,r=a.points[e+4];if(ue(le,t,r))return!0;const n=a.points[4+(e+1)%4];if(ue(le,r,n))return!0}return!1}_isTileVisibleInFrustumGlobal(e){if(e.level<2)return!0;const n=e.spatialReference,s=e.extent,o=this.opaqueGround&&this._aboveGround,c=this.opaqueGround&&!this._aboveGround,u=S,f=.5*(s[0]+s[2]);if(t.set(u[0],s[0],s[1],0),t.set(u[1],s[2],s[1],0),t.set(u[2],s[2],s[3],0),t.set(u[3],s[0],s[3],0),t.set(u[4],f,s[1],0),t.set(u[5],f,s[3],0),!i.projectVec3Array(u,n,0,u,this._renderSR,0,6))return!1;const m=u[0][2]>0,p=u[3][2]<0,g=m||p,F=this._renderSREllipsoidRadius;if(g){const e=V;l(e,de,u[0]);const r=v;if(l(r,de,u[1]),m){const n=R,s=u[4],o=y;l(o,s,de),l(n,o,s);const i=u[0];t.cross(i,e,n),h(i,F);const c=u[1];t.cross(c,r,n),h(c,F)}else if(p){const n=R,s=u[5],o=y;l(o,s,de),l(n,s,o);const i=u[3];t.cross(i,n,e),h(i,F);const c=u[2];t.cross(c,n,r),h(c,F)}}const M=z,I=t.sub(q,u[3],u[0]);t.normalize(I,I);const A=t.add(C,u[0],u[3]);t.scale(A,A,.5);const P=-t.dot(A,I),B=t.add(E,u[0],u[1]);t.scale(B,B,.5);const W=t.add(O,u[2],u[3]);t.scale(W,W,.5);const ee=t.sub(L,W,B);t.normalize(ee,ee);const ie=-(P+t.dot(I,B))/t.dot(I,ee);t.scaleAndAdd(M,B,ee,ie),h(M,F);const ce=this._frustumBoundingSphereRadius,ae=this._frustumBoundingSphereCenter,ue=this._frustum,fe=ue.planes,le=x;t.normalize(le,M);const he=t.dot(u[0],le)/t.len(u[0]),me=ue.origin,pe=ue.points;let _e=!1;if(o){{_e=!0;const e=t.normalize(ne,me);for(let n=0;n<4;++n){const s=pe[4+n],o=t.sub(r.create(),s,me);t.normalize(o,o);const i=t.cross(r.create(),e,o);t.normalize(i,i);const c=t.cross(r.create(),o,i);if(t.normalize(c,c),t.dot(me,c)>F){_e=!1;break}}}if(_e&&t.dot(me,le)<F*he-re)return!1;const e=t.normalize(ne,ue.origin);if(t.dot(e,le)<0)return!1;{const e=t.normalize(se,ue.direction);if(t.dot(e,le)>oe)return!1}}const ge=Math.sqrt(1-he*he);if(ge>.9)return!0;let be=!1;const Fe=t.dot(le,ae),Me=t.len(ae);if(Me<=ce&&!fe.some((e=>a.signedDistance(e,T)>0))){if(!o)return!0;be=!0}const Se=Fe/Me;if(!be&&Fe<=0&&-Fe>ce)return!1;const ze=ce/Me;if(Math.sqrt(1-Se*Se)*Math.sqrt(1-ze*ze)-ze*Se>ge)return!1;if(!_e){if(u.some((e=>ue.intersectsPoint(e))))return!0;if(ue.intersectsPoint(M))return!0}const Re=w;t.sub(Re,ae,T);const Ve=t.dot(Re,le),ve=G;t.scale(ve,le,Ve);const ye=t.dist(ve,ae),xe=n.isWGS84,Ge=e.lij,Ie=xe&&Ge[2]===2**Ge[0]-1,Ae=xe&&0===Ge[2],Pe=Ae?X:Ie?N:J,Be=Ae?Z:Ie?Q:K;if(!be){const e=u,t=$,r=k,n=H,s=T;for(const o of Pe){const i=e[o];if(d(r,e[(o+1)%4],i),d(n,s,i),l(t,n,r),b(t,pe,1))return!1}}let Te=null;if(!o&&Ve<1.01*ce){const e=2.5*ce;if(ye>he*e+ce)return!1;const r=j,n=e/he;for(let e=0;e<4;++e)t.scale(r[e],u[e],n/F);t.set(r[4],0,0,0),Te=r}else{const e=(c?F+re:Ve+ce)/he,r=o?F-re:(Ve-ce)/he,n=D;for(let s=0;s<4;++s){const o=u[s];t.scale(n[s],o,r/F),t.scale(n[s+4],o,e/F)}Te=n}if(_(fe,Te,Te.length))return!1;const we=ue.lines,De=Y,je=U;for(const e of we){t.normalize(je,e.direction);for(const e of Be){const r=Te[e];if(t.normalize(De,r),te(je,De,Te,pe))return!1;const n=(e+1)%4;if(o){const e=Te[n];if(t.sub(De,e,r),t.normalize(De,De),te(je,De,Te,pe))return!1}if(c){const r=Te[4+e],s=Te[4+n];if(t.sub(De,s,r),t.normalize(De,De),te(je,De,Te,pe))return!1}}}return!0}},e.isAnyVertexInPolyhedron=g,e.isConvexHullOutsideOfFrustum=_,e.maxLODLevelDelta=4,e.minTileLOD=2,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));