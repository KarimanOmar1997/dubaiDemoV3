// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../Camera","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/promiseUtils","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/Extent","../../../geometry/Geometry","../../../geometry/Multipoint","../../../geometry/Point","../../../geometry/projectionUtils","../../../geometry/SpatialReference","../../../geometry/projection/computeTranslationToOriginAndRotation","../../../geometry/projection/projectPointToVector","../../../geometry/projection/projectVectorToPoint","../../../geometry/projection/projectVectorToVector","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider"],(function(e,t,n,a,o,r,i,c,s,l,u,m,f,g,p,y,h,d,w,x,v,T,b,R,S,A,z,j,C,M,G){"use strict";function O(e){return 360-i.cyclicalDegrees.normalize(e)}function V(e){return i.cyclicalDegrees.normalize(360-e)}async function D(e,t,n,a){const o=t.camera;if(null!=o)return async function(e,t,n){const a=e.position,o=await w.projectWithZConversion(a,t,{signal:n});s.throwIfAborted(n);const r=e.clone();return r.position=o.clone(),r}(o,M.getViewSR(e),a);const{targetGeometry:r}=t;if(null==r)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:c}=P(e,t.rotation,n);if("point"===r.type)return async function(e,t,n,a,o,r){const i=e.spatialReference,c=await w.projectWithZConversion(n.clone(),i,{signal:r});s.throwIfAborted(r);const l=null!=t.scale?M.scaleToDistance(e,t.scale):e.state.camera.distance;return M.fromCenterDistanceAsync(e,c,l,a,o,r)}(e,t,r,i,c,a);const l=r.extent;if(null==l)throw new Error("Target geometry has no extent!");return M.fromExtentAsync(e,l,i.heading,i.tilt,c,a)}function P(e,t,n){const a=M.internalToExternal(e,e.state.camera);let o=M.OrientationMode.ADJUST;return null!=t&&(a.heading=O(t),o=M.OrientationMode.LOCKED),null!=n&&(a.tilt=n),{camera:a,mode:o}}function E(e,t){return null==t.scale&&null!=t.zoom?M.zoomToScale(e,t.zoom):t.scale}function Z(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=O(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function B(e,t,n,a){const o=e.spatialReference||x.WGS84;if(t??=M.externalToInternal(e,n),null==t)return a;const r=new d({spatialReference:o});return b.projectVectorToPoint(t.center,e.renderSpatialReference,r)?(a.targetGeometry=r,a.scale=M.distanceToScale(e,t.distance),a.rotation=V(n.heading),a.camera=n,a):a}async function W(e,t,n,a){const o=()=>new c("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw o();"mesh"===t.type&&(t=t.extent);const r=e.basemapTerrain.spatialReference;if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}null!=n&&r&&e.elevationProvider?(n=await w.projectWithZConversion(n,r,{signal:a}),K[2]=G.getElevationAtPoint(e.elevationProvider,n)??0):K[2]=0}const i=ee[t.type],s=new Array;if(i(t,t.hasZ?e=>{s.push([e[0],e[1],e[2]])}:e=>{s.push([e[0],e[1]])},K),0===s.length)throw o();const l=t.spatialReference,u=e.spatialReference,m=await w.projectWithZConversion(new h({spatialReference:l,hasZ:t.hasZ,hasM:!1,points:s}),u,{signal:a});if(t.hasZ&&(n.hasZ=!0),t.hasZ)for(const[e,t,a]of m.points)K[0]=e,K[1]=t,K[2]=a,S.expandWithVec3(n.boundingBox,K);else for(const[e,t]of m.points)K[0]=e,K[1]=t,S.expandWithVec3(n.boundingBox,K)}async function F(e,t,a,r,i){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return $.x=n,$.y=a,$.z=void 0,$.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:x.WGS84,void await W(e,$,r,i)}t&&"map"in t&&"function"==typeof t.map?await Promise.allSettled(t.map((t=>F(e,t,a,r,i)))):t instanceof y?await W(e,t,r,i):t instanceof n&&await async function(e,t,n,a,r){const i=await o.result(e.whenViewForGraphic(t));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await W(e,t.geometry,a,r);const c=i.value,s=await o.result(c.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok||!s.value)return void await W(e,t.geometry,a,r);const{screenSpaceObjects:l,boundingBox:u}=s.value;S.expandWithAABB(a.boundingBox,u),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(u[2])&&(a.hasZ=!0)}(e,t,a,r,i)}async function U(e,t,n,a){const o=e.spatialReference,r=await w.projectWithZConversion(t.position,o,{signal:n}),i=t.clone();return i.position=r,B(e,null,i,a)}async function I(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=C.cameraOnContentAlongViewDirection(e);if(t.position)return async function(e,t,n,a,o,r,i){const c=e.renderSpatialReference;return await T.projectPointToVectorAsync(t,_,c,0,{signal:i}),await T.projectPointToVectorAsync(n,X,c,0,{signal:i}),r.targetGeometry=new d(t),o.position=new d(n),f.subtract(q,_,X),M.directionToHeadingTilt(e,X,q,a.up,o),r.scale=M.distanceToScale(e,f.distance(X,_)),r.rotation=V(o.heading),r.camera=o,r}(e,r.targetGeometry,t.position,i,a,r,o);if(t.zoomFactor){const n=i.distance/t.zoomFactor,a=f.scale(K,i.viewForward,-n);i.eye=f.add(K,i.center,a),r.scale=M.distanceToScale(e,n)}M.internalToExternal(e,i,a);const c=Z(a,t)?M.OrientationMode.LOCKED:M.OrientationMode.ADJUST;if(!t.zoomFactor){const n=E(e,t);if(null==n){await T.projectPointToVectorAsync(r.targetGeometry,K,e.renderSpatialReference,0,{signal:o});const t=z.intersectsPoint(i.frustum,K)?f.distance(i.eye,K):i.distance;r.camera=await M.fromCenterDistanceAsync(e,r.targetGeometry,t,a,c),r.scale=M.distanceToScale(e,t)}else r.scale=n,r.camera=await M.fromCenterScale(e,r.targetGeometry,r.scale,a,c,o)}return r}function k(e){return null!=e?.camera&&(e.rotation=V(e.camera.heading)),e}class J{constructor(){this.hasZ=!1,this.boundingBox=S.empty(),this.screenSpaceObjects=new Array}}const K=g.create(),L=m.create(),N=u.create(),H=S.create(),Y=A.create(),q=g.create(),X=g.create(),_=g.create(),Q={heading:0,tilt:0},$=new d,ee={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let o=0;o<e.rings.length;o++){const r=e.rings[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let o=0;o<e.paths.length;o++){const r=e.paths[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,o=e.hasZ;for(let e=0;e<a.length;e++)n[0]=a[e][0],n[1]=a[e][1],o&&(n[2]=a[e][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(f.set(n,e.xmin,e.ymin,e.zmin)),t(f.set(n,e.xmax,e.ymin,e.zmin)),t(f.set(n,e.xmin,e.ymax,e.zmin)),t(f.set(n,e.xmax,e.ymax,e.zmin)),t(f.set(n,e.xmin,e.ymin,e.zmax)),t(f.set(n,e.xmax,e.ymin,e.zmax)),t(f.set(n,e.xmin,e.ymax,e.zmax)),t(f.set(n,e.xmax,e.ymax,e.zmax))):(t(f.set(n,e.xmin,e.ymin,n[2])),t(f.set(n,e.xmax,e.ymin,n[2])),t(f.set(n,e.xmin,e.ymax,n[2])),t(f.set(n,e.xmax,e.ymax,n[2])))}};e.create=async function(e,n,o){const r=function(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),!n.target&&"center"in t&&t.center&&(n.target=t.center)),n}(e,n);if(!r)throw new c("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new t({fov:e.camera.fov}),s=new a({camera:i});if(r.target instanceof a){const t=await async function(e,t,n,a,o){if(t.camera)return U(e,t.camera,a,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=V(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const r=E(e,n);return null!=r&&(o.scale=r),o.camera=await D(e,o,n.tilt,a),o}(e,r.target,r,o,s);return k(t)}if(r.target instanceof t)return k(await U(e,r.target,o,s));const u=null!=r.scale||null!=r.zoom;if(r.target instanceof p){const t=r.target.xmin===r.target.xmax||r.target.ymin===r.target.ymax;return k(u||t?await I(e,r,r.target.center,i,o,s):await async function(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=C.cameraOnContentAlongViewDirection(e);M.internalToExternal(e,i,a);const c=Z(a,t)?M.OrientationMode.LOCKED:M.OrientationMode.ADJUST;return r.camera=await M.fromExtentAsync(e,n,a.heading,a.tilt,c,o),r}(e,r,r.target,i,o,s))}const m=new J,g=u?function(e,t){const n=E(e,t);return n?j.getResolutionInMetersForScale(n):void 0}(e,r):void 0;if(await F(e,r.target,g,m,o),isFinite(m.boundingBox[0])){let t;if(S.center(m.boundingBox,K),$.x=K[0],$.y=K[1],$.z=K[2],$.spatialReference=e.spatialReference,isFinite($.z)&&m.hasZ?t=S.isPoint(m.boundingBox):($.z=void 0,t=A.isPoint(S.toRect(m.boundingBox,Y))),u||t)return k(await I(e,r,$,i,o,s));const n=function(e,t){if(!t.length)return.66;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const a=t[e].screenSpaceBoundingRect;n=Math.max(n,Math.abs(a[0]),Math.abs(a[1]),Math.abs(a[2]),Math.abs(a[3]))}return.66-n/Math.min(e.width,e.height)*2}(e,m.screenSpaceObjects);return k(await async function(e,t,n,a,o,r,i,c){c.targetGeometry=n.clone();const s=C.cameraOnContentAlongViewDirection(e),u=function(e,t,n,a,o){let r=0;null!=n.z?r=n.z:e.basemapTerrain&&e.elevationProvider&&(r=G.getElevationAtPoint(e.elevationProvider,n)),f.set(K,n.x,n.y,r),v.computeTranslationToOriginAndRotation(e.spatialReference,K,L,e.renderSpatialReference),l.fromMat4(N,L),l.transpose(N,N),S.empty(H);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<i.length;t++){const n=i[t];let o=a[n[2]];isFinite(o)||(o=r),f.set(K,a[n[0]],a[n[1]],o),R.projectVectorToVector(K,e.spatialReference,K,e.renderSpatialReference),S.expandWithVec3(H,f.transformMat3(K,K,N))}const c=S.width(H),s=S.height(H),u=S.depth(H),m=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(c*c+u*u)*Math.max(g,m)+.5*s,y=.5*s*g+.5*Math.max(c,u);return Math.max(p,y)/o}(e,s,n,a,o);M.internalToExternal(e,s,r);const m=Z(r,t)?M.OrientationMode.LOCKED:M.OrientationMode.ADJUST;return c.camera=await M.fromCenterDistanceAsync(e,c.targetGeometry,u,r,m,i),c.scale=M.distanceToScale(e,u),c}(e,r,$,m.boundingBox,n,i,o,s))}return r.position?k(await async function(e,t,n,a,o){const r=C.cameraOnContentAlongViewDirection(e);f.copy(q,r.viewForward),M.directionToHeadingTilt(e,r.eye,q,r.up,Q);const i=e.spatialReference,{position:c}=t;if(c){const e=await w.projectWithZConversion(c,i,{signal:o});n.position=e}else n.position=new d;return n.heading=null!=t.heading?t.heading:Q.heading,n.tilt=null!=t.tilt?t.tilt:Q.tilt,B(e,null,n,a)}(e,r,i,s,o)):k(await async function(e,t,n,a,o){if(null!=t.heading||null!=t.rotation||null!=t.scale||null!=t.tilt||null!=t.zoom||null!=t.zoomFactor){const r=C.cameraOnContentAlongViewDirection(e),{spatialReference:i,renderSpatialReference:c}=e,s=new d({spatialReference:i});return b.projectVectorToPoint(r.center,c,s)?I(e,t,s,n,a,o):o}return o.scale=e.scale,o.camera=e.camera.clone(),Z(o.camera,t),o}(e,r,i,o,s))},e.fromCamera=function(e,t,n=null){return null==n&&(n=new a),B(e,null,t.clone(),n)},e.toCameraAsync=D,e.toCameraSync=function(e,t,n){const a=t.camera;if(null!=a)return function(e,t){const n=e.position;let a;try{a=w.tryProjectWithZConversion(n,t)}catch(e){return null}if(!a)return null;const o=e.clone();return o.position=a.clone(),o}(a,M.getViewSR(e));const{targetGeometry:o}=t;if(null==o)return null;const{camera:r,mode:i}=P(e,t.rotation,n);if("point"===o.type)return function(e,t,n,a,o){const r=e.spatialReference;let i;try{i=w.tryProjectWithZConversion(n.clone(),r)}catch(e){return null}if(!i)return null;const c=null!=t.scale?M.scaleToDistance(e,t.scale):e.state.camera.distance;return M.fromCenterDistanceSync(e,i,c,a,o)}(e,t,o,r,i);const c=o.extent;return null==c?null:M.fromExtentSync(e,c,r.heading,r.tilt,i)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));