// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/mathUtils","../../../core/typedArrayUtil","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./interfaces","./NeighborIndex","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/Normals"],(function(e,t,n,o,s,r,i,a,l,c,u,d,m,f){"use strict";function p(e){e.tile.intersectsClippingArea&&(h(e),g(e))}function g(e,o=!1){const{geometry:s,geometryState:i,tile:a,localOrigin:l}=e,{level:d,extent:f,extentInRadians:p,ellipsoid:g}=a,h=g.radius,x=p[0],v=p[2],y=p[1],S=p[3],{samplerData:E}=i,A=f[0],b=f[2],V=f[1],I=f[3],T=M(e),{boundingBox:P,vertexAttributes:C}=s,L=l[0],U=l[1],O=l[2],{position:D,uv0:R}=C,N=D.typedBuffer,w=D.typedBufferStride;for(let l=0;l<4;++l){const p=1===l||3===l,g=i.edgeResolutions[l];u.internalAssert(t.isPowerOfTwo(g));const M=g+1,C=c.neighborTileIfLoadedOrSelf(a,i.edgePeerNeighbors[l]);if(F(a,C,l)){B(e,l,C);continue}const D=null!=C;u.internalAssert(!D||C.level===a.level),u.internalAssert(!D||m.compareTilesByLij(a,C)<=0);const q=C?.renderData,H=q?.geometryState;if(u.enableTerrainInternalChecks){const e=a.surface;if(!C&&e&&!e.updatingRootTiles){const t=u.neighborEdgeIndices[l],n=a.findNeighborTile(t,(e=>e.loaded||e.leaf||e.level===a.level));n?n.intersectsClippingArea&&(u.internalAssert(!n.loaded),u.internalAssert(!n.leaf),u.internalAssert(n.level===d)):u.internalAssert(null==e?.rootTiles||!a.shouldHaveNeighbor(t))}}const _=1===l?f[2]:f[0],W=C?.extent,k=W&&p?1===l?W[0]:W[2]:_,G=0===l?f[3]:f[1],z=1===l?1:0,J=0===l?1:0,K=1===l?v:x,Q=0===l?S:y,X=Math.sin(K),Y=Math.cos(K),Z=Math.sin(Q),$=Math.cos(Q),ee=H?.samplerData,te=D?(e,t,n)=>.5*(r.sampleElevation(e,t,E)+r.sampleElevation(n,t,ee)):(e,t,n)=>r.sampleElevation(e,t,E),ne=s.outerEdgesOffsetAndLength[2*l+0],oe=o&&M>3?M-3:1,se=null!=E&&E.some((e=>null!=e)),re=null!=ee&&ee.some((e=>null!=e)),ie=se||re,ae=1/g,le=ne;u.internalAssert(!W||u.almostEquals(W[2]-W[0],f[2]-f[0])),(()=>{const e=1===l?-1:3===l?1:0,t=0===l?-1:2===l?1:0,o=(f[2]-f[0])*ae,i=e*o,a=t*o,c=p?e*((v-x)*ae):0,u=p?0:t*ae,d=J,m=p?K+c:K,g=p?Math.sin(m):X,y=p?Math.cos(m):Y,S=p?K-c:K,B=p?Math.sin(S):X,C=p?Math.cos(S):Y,F=p?Q:T(d+u),q=p?Z:Math.sin(F),H=p?$:Math.cos(F),W=p?Q:T(d-u),ne=p?Z:Math.sin(W),se=p?$:Math.cos(W);let re=0,ce=0,ue=0;{const e=0*ae,t=p?_:A*(1-e)+b*e,n=p?k:t,o=p?V*(1-e)+I*e:G,s=p?K:x*(1-e)+v*e,r=p?X:Math.sin(s),i=p?Y:Math.cos(s),a=p?T(e):Q,l=p?Math.sin(a):Z,c=p?Math.cos(a):$,u=h+te(t,o,n);re=i*c*u,ce=r*c*u,ue=l*u}let de=0,me=0,fe=0;{const e=1*ae,t=p?_:A*(1-e)+b*e,n=p?k:t,o=p?V*(1-e)+I*e:G,s=p?K:x*(1-e)+v*e,r=p?X:Math.sin(s),i=p?Y:Math.cos(s),a=p?T(e):Q,l=p?Math.sin(a):Z,c=p?Math.cos(a):$,u=h+te(t,o,n);de=i*c*u,me=r*c*u,fe=l*u}for(let e=1;e<M-1;e+=oe){let t=0,o=0,c=0;{const n=(e+1)*ae,s=p?_:A*(1-n)+b*n,r=p?k:s,i=p?V*(1-n)+I*n:G,a=p?K:x*(1-n)+v*n,l=p?X:Math.sin(a),u=p?Y:Math.cos(a),d=p?T(n):Q,m=p?Math.sin(d):Z,f=p?Math.cos(d):$,g=h+te(s,i,r);t=u*f*g,o=l*f*g,c=m*g}const u=t,d=o,m=c,f=de,M=me,S=fe;de=u,me=d,fe=m;{const t=le+e,o=t*w,s=f-L,r=M-U,i=S-O;N[o]=s,N[o+1]=r,N[o+2]=i,j(s,r,i,P);const a=e*ae,l=p?z:a,c=p?a:J;R.setValues(t,Math.round(l*n.maxUint16),Math.round(c*n.maxUint16))}const F=re,W=ce,oe=ue;re=f,ce=M,ue=S;const pe=f,ge=M,he=S,xe=1/Math.sqrt(pe*pe+ge*ge+he*he),Me=he*xe;let ve=0,ye=0,Se=0;if(ie&&Me*Me<.999){let t=0,n=0,o=0;{const e=0===l?-1:1;t=e*(u-F),n=e*(d-W),o=e*(m-oe)}{const s=e*ae,c=p?_:A*(1-s)+b*s,u=p?k:c,d=p?V*(1-s)+I*s:G,m=p?K:x*(1-s)+v*s,f=p?X:Math.sin(m),M=p?Y:Math.cos(m),S=p?T(s):Q,P=p?Math.sin(S):Z,L=p?Math.cos(S):$;let U=pe,O=ge,R=he;if(D){const e=u-i,t=d-a,n=h+r.sampleElevation(e,t,ee),o=p?L:se;U=(p?C:M)*o*n,O=(p?B:f)*o*n,R=(p?P:ne)*n}{const e=c+i,s=d+a,u=h+r.sampleElevation(e,s,E),m=p?L:H,x=(p?y:M)*m*u,v=(p?g:f)*m*u,S=(p?P:q)*u;D||(U=2*pe-x,O=2*ge-v,R=2*he-S);const A=3===l?-1:1,b=A*(U-x),V=A*(O-v),I=A*(R-S);ve=o*V-n*I,ye=t*I-o*b,Se=n*b-t*V;const T=1/Math.sqrt(ve*ve+ye*ye+Se*Se);ve*=T,ye*=T,Se*=T}}}else ve=pe*xe,ye=ge*xe,Se=he*xe;s.setEdgeNormalFromValues(l,e,ve,ye,Se)}})()}}function h(e){P(e)}function x(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function M(e){const{tile:t}=e;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius,o=t=>function(e,t,n,o){return x(e*(1-o)+t*o,n)}(e[1],e[3],n,t);return o}const n=t.extentInRadians;return e=>function(e,t,n){return e*(1-n)+t*n}(n[1],n[3],e)}function v(e,t){e.tile.intersectsClippingArea&&(S(e),y(e,!1))}function y(e,n){const{geometry:o,geometryState:s,localOrigin:i}=e,a=e.tile,{surface:l,extent:d}=a,{clippingArea:f,samplerData:p}=s,g=null!=f?f:N,h=d[0],x=d[2],M=d[1],v=d[3],y=[v>g[3],x>g[2],M<g[1],h<g[0]],S=a.horizontalScale,A=E(l.isWebMercatorOnPlateCarree,a.ellipsoid.radius,S),{minu:b,minv:V,maxu:I,maxv:T,boundingBox:P}=o,C=Math.max(h,g[0]),L=Math.min(x,g[2]),U=Math.max(M,g[1]),O=Math.min(v,g[3]),D=i[0],R=i[1],w=i[2];for(let i=0;i<4;++i){const d=1===i||3===i,f=s.edgeResolutions[i];u.internalAssert(t.isPowerOfTwo(f));const g=f+1,E=y[i],N=c.neighborTileIfLoadedOrSelf(a,s.edgePeerNeighbors[i]);if(!E&&F(a,N,i)){B(e,i,N);continue}const q=null!=N&&!E,H=N?.renderData,_=H?.geometryState;if(u.enableTerrainInternalChecks&&(u.internalAssert(!q||N.level===a.level),u.internalAssert(!q||m.compareTilesByLij(a,N)<=0),a&&!N&&!l.updatingRootTiles)){const e=u.neighborEdgeIndices[i],t=a.findNeighborTile(e,(e=>e.loaded||e.leaf||e.level===a.level));l.updatingRootTiles||(t?t.intersectsClippingArea&&(u.internalAssert(!t.loaded),u.internalAssert(!t.leaf),u.internalAssert(t.level===a.level)):u.internalAssert(null==l?.rootTiles||!a.shouldHaveNeighbor(e)))}const W=t.clamp(1===i?x:h,C,L),k=t.clamp(0===i?v:M,U,O),G=_?.samplerData,z=n&&g>3?g-3:1,J=t.clamp(1===i?1:0,b,I),K=t.clamp(0===i?1:0,V,T),Q=q?(e,t)=>.5*(r.sampleElevation(e,t,G)+r.sampleElevation(e,t,p)):(e,t)=>r.sampleElevation(e,t,p),X=(x-h)/f,Y=d?1===i?X:-X:0,Z=d?0:0===i?X:-X,$=-Y,ee=-Z;let te=0,ne=0,oe=0;{const e=0/f,n=d?W:t.clamp(h*(1-e)+x*e,C,L),o=d?t.clamp(M*(1-e)+v*e,U,O):k,s=Q(n,o);te=n*S,ne=A(o),oe=s}let se=0,re=0,ie=0;{const e=1/f,n=d?W:t.clamp(h*(1-e)+x*e,C,L),o=d?t.clamp(M*(1-e)+v*e,U,O):k,s=Q(n,o);se=n*S,re=A(o),ie=s}for(let e=1;e<g-1;e+=z){const n=e/f,s=se,a=re,l=ie;{const r=d?J:t.clamp(n,b,I),c=d?t.clamp(n,V,T):K,u=s-D,m=a-R,f=l-w;j(s,m,f,P),o.setEdgeVertexFromValuesRawPositionUV(i,e,u,m,f,r,c)}{const n=(e+1)/f,o=d?W:t.clamp(h*(1-n)+x*n,C,L),s=d?t.clamp(M*(1-n)+v*n,U,O):k,r=Q(o,s);se=o*S,re=A(s),ie=r}const c=se,u=ie,m=te,g=ne,y=oe;te=s,ne=a,oe=l;let E=0,B=0,N=0;if(d){const e=re-a,o=u-l,c=g-a,d=y-l,m=t.clamp(M*(1-n)+v*n,U,O),f=W+$,h=m,x=f*S-s,A=r.sampleElevation(f,h,p)-l,b=3===i?-1:1;if(E=b*(-c+e)*A,B=b*x*(-d+o),N=-b*x*(-c+e),q){const t=W+Y,n=m,i=t*S-s;E=(-c+e)*(A-(r.sampleElevation(t,n,G)-l)),B=(x-i)*(-d+o),N=-(x-i)*(-c+e)}}else{const e=c-s,o=u-l,d=m-s,f=y-l,g=t.clamp(h*(1-n)+x*n,C,L),M=g,v=k+ee,S=r.sampleElevation(M,v,p)-l,b=A(v)-a,V=2===i?-1:1;if(E=V*b*(-f+o),B=V*(-d+e)*S,N=-V*b*(-d+e),q){const t=g,n=k+Z,s=A(n)-a;E=(-b+s)*(-f+o),B=(-d+e)*(-S+(r.sampleElevation(t,n,G)-l)),N=-(-b+s)*(-d+e)}}const F=1/Math.sqrt(E*E+B*B+N*N);o.setEdgeNormalFromValues(i,e,E*F,B*F,N*F)}}}function S(e,t){P(e)}function E(e,t,n){return e?e=>function(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}(e,t):e=>function(e,t){return e*t}(e,n)}function A(e,t,n){const{numVerticesPerSide:o,vertexAttributes:s,maxEdgeVertexCount:r}=e,i=o-1,a=s.count,l=2*(o-3)*(o-3),u=4*(i+r-3),d=c.zeroToFour.reduce(((t,n)=>t+(i+e.getEdgeCount(n)-3)),0),m=t.reduce(((e,t)=>e+i*(2*(t.latitudeResolution-1)+1)),0),f=3*(n?2:1),p=(l+u+m)*f,g=a>=65536?new Uint32Array(p):new Uint16Array(p);for(let e=0;e<p;++e)g[e]=0;e.indices=g,e.indexCount=(l+d+m)*f,e.poleIndicesStartIndex=l*f,e.edgeIndicesStartIndex=(l+m)*f,n?(function(e){const{indices:t,numVerticesPerSide:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=n-2;let l=0;for(let e=0;e<n-3;++e){const o=e*a;for(let s=0;s<n-3;++s){const n=e*a+s,c=n+1,u=c+a,d=u-1,m=o+s,f=m+1,p=f+a;W(m,f,p,p-1,i,r)?(k(t,l,n,c,u),l+=6,k(t,l,u,d,n)):(k(t,l,n,c,d),l+=6,k(t,l,d,u,c)),l+=6}}}(e),function(e,t){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:s}=e,r=o-1;let i=s;for(const s of t){const t=s.connectedOuterEdgeOffset;let a=e.getEdgeVertexIndex(t,0),l=1;for(let e=0;e<s.latitudeResolution;++e){const t=0===e?s.rowOffset:a+o;for(let o=0;o<r;o++)k(n,i,a,a+1,t+o),i+=6,e<s.latitudeResolution-1&&(k(n,i,a+1,t+o+1,t+o),i+=6),a+=l;a=t,l=1}}}(e,t),V(e)):(function(e){const{numVerticesPerSide:t,indices:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=t-2,l=t-3,c=t-3;let u=0;for(let e=0;e<l;++e){const t=e*a;for(let e=0;e<c;++e){const o=t+e,s=o+1,l=s+a,c=l-1;W(o,s,l,c,i,r)?(n[u]=o,n[u+1]=s,n[u+2]=l,n[u+3]=l,n[u+4]=c,n[u+5]=o):(n[u]=o,n[u+1]=s,n[u+2]=c,n[u+3]=c,n[u+4]=s,n[u+5]=l),u+=6}}}(e),function(e,t){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:s}=e,r=n-1;let i=s;for(const s of t){const t=s.isNorth?1:2,a=s.isNorth?2:1,l=s.isNorth?3:4,c=s.isNorth?4:3;let u=e.getEdgeVertexIndex(s.connectedOuterEdgeOffset,0),d=1;for(let e=0;e<s.latitudeResolution;++e){const m=0===e?s.rowOffset:u+n;for(let n=0;n<r;n++){const r=m+n;o[i]=u,o[i+t]=u+1,o[i+a]=r,e<s.latitudeResolution-1?(o[i+l]=u+1,o[i+c]=r+1,o[i+5]=r,i+=6):i+=3,u+=d}u=m,d=1}}}(e,t),b(e))}function b(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let n=0;n<4;++n){const o=H[n];let a=0,l=0;const c=e.getEdgeCount(n),d=o.count;u.internalAssert(d===s-1);const m=1===n||2===n,f=m?1:2,p=m?2:1,g=e.getEdgeFirstVertexIndex(n),h=1,x=o.vertex0Index,M=o.stride;for(;a<c-1||l<d-1;){const e=x+l*M,n=g+a*h,o=a<c-1,u=l<d-1,m=o&&(!u||(o?0+s*(a+.5)/(c-1):0)<=(u?1+r*(l+.5)/(d-1):0));m?++a:++l;const v=m?n+h:e+M;t[i]=e,t[i+f]=n,t[i+p]=v,i+=3}}e.indexCount=i}function V(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let n=0;n<4;++n){const o=H[n];let a=0,l=0;const c=e.getEdgeCount(n),d=o.count;u.internalAssert(d===s-1);const m=1===n||2===n,f=m?1:3,p=m?3:1,g=e.getEdgeFirstVertexIndex(n),h=1,x=o.vertex0Index,M=o.stride;for(;a<c-1||l<d-1;){const e=x+l*M,n=g+a*h,o=a<c-1,u=l<d-1,m=o&&(!u||(o?0+s*(a+.5)/(c-1):0)<=(u?1+r*(l+.5)/(d-1):0));m?++a:++l;const v=m?n+h:e+M;t[i]=e,t[i+f]=n,t[i+f+1]=n,t[i+p]=v,t[i+p+1]=v,t[i+5]=e,i+=6}}e.indexCount=i}function I(e){const{geometry:t,geometryState:n}=e,{edgeResolutions:o}=n,{numVerticesPerSide:s,edgeVerticesStartIndex:r}=t,i=s-2;let a=r;for(let e=0;e<4;++e){{const t=0===e||2===e,n=(0===e?i-1:0)*i+(1===e?i-1:0),o=(t?0:1)*i+(t?1:0),s=H[e];s.vertex0Index=n,s.stride=o,s.count=i}{const n=o[e]+1;t.outerEdgesOffsetAndLength[2*e+0]=a,t.outerEdgesOffsetAndLength[2*e+1]=n,a+=n}}}function T(e){I(e),e.geometryState.wireframe?V(e.geometry):b(e.geometry)}function B(e,o,s){const{geometryState:r,geometry:i,tile:a,localOrigin:l}=e,c=1===o||3===o,d=r.edgeResolutions[o];u.internalAssert(t.isPowerOfTwo(d));const m=d+1,{boundingBox:f,minu:p,minv:g,maxu:h,maxv:x,vertexAttributes:M}=i,v=t.clamp(1===o?1:0,p,h),y=t.clamp(0===o?1:0,g,x),S=s.renderData,E=S.geometryState,A=S.geometry,b=(o+2)%4,V=A.getEdgeCount(b),I=a.getNeighborEdgeStartVertexIndex(o,s)*d,T=d*2**(a.level-s.level);u.internalAssert(E.edgeResolutions[b]===T),u.internalAssert(V-1===T);const B=S.localOrigin[0]-l[0],P=S.localOrigin[1]-l[1],C=S.localOrigin[2]-l[2],L=i.getEdgeFirstVertexIndex(o),{position:U,uv0:O}=M,D=U.typedBuffer,R=U.typedBufferStride,N=M.normalCompressed,w=N.typedBuffer,F=N.typedBufferStride,q=A.vertexAttributes,H=A.getEdgeFirstVertexIndex(b),_=q.position.typedBuffer,W=q.position.typedBufferStride,k=q.normalCompressed.typedBuffer,G=q.normalCompressed.typedBufferStride;for(let e=1;e<m-1;++e){const o=L+e,s=H+(I+e),r=o*R,i=s*W,a=_[i]+B,l=_[i+1]+P,u=_[i+2]+C;D[r]=a,D[r+1]=l,D[r+2]=u,j(a,l,u,f);const m=o*F,M=s*G;w[m]=k[M],w[m+1]=k[M+1];const S=e/d,E=c?v:t.clamp(S,p,h),A=c?t.clamp(S,g,x):y;O.setValues(o,Math.round(E*n.maxUint16),Math.round(A*n.maxUint16))}}function P(e){const{geometry:o,geometryState:s,localOrigin:i}=e,{clippingArea:a,samplerData:l}=s,{minu:c,minv:d,maxu:f,maxv:p,boundingBox:g,vertexAttributes:h}=o,x=e.tile,{surface:v,ellipsoid:y,extent:S,extentInRadians:A,horizontalScale:b}=x,V="local"===v.view?.viewingMode,I=y.radius;let T=0,B=0,P=0;const L=V?(()=>{const e=a,n=null!=e&&(S[3]>e[3]||S[2]>e[2]||S[1]<e[1]||S[0]<e[0]),o=E(v.isWebMercatorOnPlateCarree,I,b);return(s,r,i)=>{const a=0===s?S[0]:S[2],l=0===r?S[1]:S[3],c=n?t.clamp(a,e[0],e[2]):a,u=n?t.clamp(l,e[1],e[3]):l,d=i;T=c*b,B=o(u),P=d}})():(e,t,n)=>{const o=A[0===t?1:3],s=A[0===e?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=I+n;T=l*r*c,B=a*r*c,P=i*c};let U=0,O=0,R=0,F=0,q=0,H=0,_=0,W=0,k=0;const G=V&&v.isWebMercatorOnPlateCarree,z=(e,t,n,o,s)=>{let r=0,i=0,a=0;if(V){const e=t*b,s=G?(Math.PI/2-2*Math.atan(Math.exp(-n/I)))*I:n*b;r=e-T,i=s-B,a=o-P}else{const s=M(e),l=e.tile,c=l.extent,u=l.extentInRadians,d=(t-c[0])/(c[2]-c[0]),m=(n-c[1])/(c[3]-c[1]),f=u[0]*(1-d)+u[2]*d,p=s(m),g=Math.cos(p),h=Math.sin(p),x=Math.sin(f),v=Math.cos(f),y=I+o;r=v*g*y-T,i=x*g*y-B,a=h*y-P}switch(s){case 0:_+=r,W+=i,k+=a;break;case 1:F-=r,q-=i,H-=a;break;case 2:_-=r,W-=i,k-=a;break;case 3:F+=r,q+=i,H+=a}},J=a??N,K=S[0],Q=S[2],X=S[1],Y=S[3],Z=[Y>J[3],Q>J[2],X<J[1],K<J[0]],$=Math.max(K,J[0]),ee=Math.min(Q,J[2]),te=Math.max(X,J[1]),ne=Math.min(Y,J[3]),oe=e=>Math.max(J[0],Math.min(J[2],e)),se=e=>Math.max(J[1],Math.min(J[3],e)),re=e=>{const t=s.cornerNeighborCornerTiles;U=0,O=0,R=1,F=0,q=0,H=0,_=0,W=0,k=0;let n=1/0;for(let o=0;o<4;++o){const s=t[4*e+o];n=Math.min(n,s?.level??1/0)}for(let o=0;o<4;++o){const s=t[4*e+o];w[o]=s?.level===n?s:null}let o=1,i=0;for(let e=0;e<4;++e){const t=w[e];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),i=t.extent[2]-t.extent[0])}const a=i,l=o;u.internalAssert(l>1);const c=a/l;for(let e=0;e<4;++e){const t=w[(e+3)%4],n=w[e%4];if(!t&&!n)continue;const o=0===e?1:1===e?2:2===e?3:0,s=0===e?2:1===e?3:2===e?0:1;if(t&&n){const i=D[e][0]*c,a=D[e][1]*c,l=t.extent,u=oe(l[0===o||1===o?2:0]+i),d=se(l[0===o||3===o?3:1]+a),m=n.extent,f=oe(m[0===s||1===s?2:0]+i),p=se(m[0===s||3===s?3:1]+a),g=t.renderData,h=n.renderData,x=r.sampleElevation(u,d,g.geometryState.samplerData),M=r.sampleElevation(f,p,h.geometryState.samplerData);z(g,u,d,.5*(x+M),e)}else{const i=t??n,a=t?o:s,l=i.extent,u=D[e],d=oe(l[0===a||1===a?2:0]+u[0]*c),m=se(l[0===a||3===a?3:1]+u[1]*c),f=i.renderData,p=r.sampleElevation(d,m,f.geometryState.samplerData);z(f,d,m,p,e)}}if(!V){const e=Math.sqrt(T*T+B*B+P*P);U=T/e,O=B/e,R=P/e}if(V||R*R<.999){const e=Math.sqrt(F*F+q*q+H*H);F/=e,q/=e,H/=e;const t=Math.sqrt(_*_+W*W+k*k);_/=t,W/=t,k/=t,U=H*W-q*k,O=F*k-H*_,R=q*_-F*W;const n=1/Math.sqrt(U*U+O*O+R*R);U*=n,O*=n,R*=n}},ie=s.cornerNeighborCornerTiles;for(let e=0;e<4;++e){const a=e,M=(e+1)%4,v=0===e||1===e?1:0,y=0===e||3===e?1:0,S=t.clamp(v,c,f),E=t.clamp(y,d,p),A=o.getEdgeFirstVertexIndex(a),b=o.getEdgeCount(a),V=0===e||3===e?b-1:0,I=o.getEdgeFirstVertexIndex(M),D=o.getEdgeCount(M),N=0===e||1===e?D-1:0;let w=-1;for(let t=0;t<4;++t){const n=ie[4*e+t],o=ie[4*e+w];n&&(-1===w||m.compareTilesByLij(o,n)>0)&&(w=t)}const F=w,q=ie[4*e+F];if(q!==x){const t=x.level-q.level,o=2**t,r=[q.lij[0]+t,q.lij[1]*o,q.lij[2]*o],a=[r[1]+o===x.lij[1],0===e&&(1===F||0===F&&q!==ie[4*e+3])||1===e&&(0===F||1===F&&q!==ie[4*e+2]),r[1]===x.lij[1]+1,2===e&&(3===F||2===F&&q!==ie[4*e+1])||3===e&&(2===F||3===F&&q!==ie[4*e+0])],l=a.reduce(((e,t)=>e+(t?1:0)),0);u.internalAssert(1===l||2===l);let c=-1,d=-1;const m=q.renderData;if(1===l){const t=a.findIndex((e=>e));u.internalAssert(0<=t&&t<=3),c=(t+2)%4;const n=s.edgeResolutions[t];d=x.getNeighborEdgeStartVertexIndex(t,q)*n+n*(0===t&&0===e||1===t&&0===e||2===t&&1===e||3===t&&3===e?1:0)}else{u.internalAssert(a[1]||a[3]),c=a[1]?3:1;const t=m.geometryState.edgeResolutions[c];d=0===e||3===e?0:t}const f=m.geometry;{const e=A+V,t=I+N,o=f.getEdgeFirstVertexIndex(c)+d,s=f.vertexAttributes,r=m.localOrigin,a=s.position,l=a.typedBuffer,u=o*a.typedBufferStride,p=l[u]+r[0]-i[0],x=l[u+1]+r[1]-i[1],M=l[u+2]+r[2]-i[2];j(p,x,M,g);const v=h.position,y=v.typedBuffer,b=e*v.typedBufferStride;y[b]=p,y[b+1]=x,y[b+2]=M;const T=t*v.typedBufferStride;y[T]=p,y[T+1]=x,y[T+2]=M;const B=h.uv0;B.setValues(e,Math.round(S*n.maxUint16),Math.round(E*n.maxUint16)),B.setValues(t,Math.round(S*n.maxUint16),Math.round(E*n.maxUint16));{const n=s.normalCompressed.typedBuffer,r=o*s.normalCompressed.typedBufferStride,i=h.normalCompressed,a=i.typedBuffer;{const t=e*i.typedBufferStride;a[t]=n[r],a[t+1]=n[r+1]}{const e=t*i.typedBufferStride;a[e]=n[r],a[e+1]=n[r+1]}}}}else{let n;if(Z[a]||Z[M]){const e=t.clamp(K*(1-v)+Q*v,$,ee),o=t.clamp(X*(1-y)+Y*y,te,ne);n=r.sampleElevation(e,o,l)}else n=C(ie,e);L(v,y,n),re(e);const s=T-i[0],c=B-i[1],u=P-i[2];j(s,c,u,g),o.setEdgeVertexFromValuesRawPositionUVNormal(a,V,s,c,u,S,E,U,O,R),o.setEdgeVertexFromValuesRawPositionUVNormal(M,N,s,c,u,S,E,U,O,R)}}for(let e=0;e<4;++e)w[e]=null}function C(e,t){const n=4*t,o=c.zeroToFour.reduce(((t,o)=>Math.min(t,e[n+o]?.level??1/0)),1/0);u.enableTerrainInternalChecks&&(u.internalAssert(!e[n+0]||!e[n+2]||d.isCornerNeighbor(e[n+0],e[n+2],a.NeighborIndex.SOUTH_WEST)),u.internalAssert(!e[n+1]||!e[n+3]||d.isCornerNeighbor(e[n+1],e[n+3],a.NeighborIndex.NORTH_WEST)));let s=0,i=0;for(let t=0;t<4;++t){const a=e[n+t];if(a&&a.level===o){const e=0===t||1===t,n=0===t||3===t,o=a.extent,l=o[e?0:2],c=o[n?1:3],u=a.renderData?.geometryState?.samplerData;i+=r.sampleElevation(l,c,u),s++}}const l=s?i/s:0;return u.internalAssert(null!=l),l}function L(e){const{vao:t,geometry:n}=e,{vertexAttributes:o,edgeVerticesStartIndex:s}=n,r=o.position.typedBuffer;t.vertexBuffers.get("geometry").setSubData(r,s,s,r.length)}function U(e){const{vao:t,geometry:n}=e,{indices:o,indexCount:s,edgeIndicesStartIndex:r}=n;t.indexBuffer.setSubData(o,r,r,s)}class O{constructor(e,t,n,o,s){this.isNorth=e,this.connectedRowOffset=t,this.connectedOuterEdgeOffset=n,this.rowOffset=o,this.latitudeResolution=s}}const D=[[0,1],[1,0],[0,-1],[-1,0]],R=new l.PatchGeometryLUT,N=s.fromValues(-1/0,-1/0,1/0,1/0),w=[null,null,null,null];function F(e,t,n){if(!t)return!1;const o=m.compareTilesByLij(e,t);return o>0||0===o&&n>=2}class q{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(e){return u.internalAssert(0<=e&&e<this.count),this.vertex0Index+this.stride*e}}const H=[new q,new q,new q,new q];function j(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function _(e){const{edgeResolutions:t,numVerticesPerSide:n}=e,o=1+Math.max(...t);return Math.max(n,o)}function W(e,t,n,o,s,r){const i=e*s,a=r[i],l=r[i+1],c=r[i+2],u=t*s,d=r[u],m=r[u+1],f=r[u+2],p=n*s,g=r[p],h=r[p+1],x=r[p+2],M=o*s,v=r[M],y=r[M+1],S=r[M+2];return(d-v)*(d-v)+(m-y)*(m-y)+(f-S)*(f-S)>(a-g)*(a-g)+(l-h)*(l-h)+(c-x)*(c-x)}function k(e,t,n,o,s){e[t]=n,e[t+1]=o,e[t+2]=o,e[t+3]=s,e[t+4]=s,e[t+5]=n}e.createPlanarGlobePatch=function(e,s){const{tile:i,geometryState:a,geometry:l}=e,{extent:c,surface:u}=i,{wireframe:d}=a,m=c[0],p=c[1],g=c[2]-m,h=c[3]-p,{numVerticesPerSide:x,clippingArea:M}=a,y=null!=M?Math.max(0,(M[0]-m)/g):0,S=null!=M?Math.max(0,(M[1]-p)/h):0,E=null!=M?Math.min(1,(M[2]-m)/g):1,b=null!=M?Math.min(1,(M[3]-p)/h):1,V=(x-2)**2,T=_(a),B=V+4*T,P=u.renderer.tileGeometryCache.acquire(B),{boundingBox:C}=l;o.empty(C),l.numVerticesPerSide=x,l.vertexAttributes=P,l.maxEdgeVertexCount=T,l.minu=y,l.minv=S,l.maxu=E,l.maxv=b,function(e){const o=e.tile;if(!o.intersectsClippingArea)return;const{geometry:s,geometryState:i,localOrigin:a}=e,{samplerData:l,clippingArea:c,numVerticesPerSide:u}=i,{surface:d,extent:m,ellipsoid:p}=o,{isWebMercatorOnPlateCarree:g}=d,h=null!=c?c:N,x=m[0],M=m[1],v=m[2],y=m[3],S=Math.max(x,h[0]),E=Math.min(v,h[2]),A=Math.max(M,h[1]),b=Math.min(y,h[3]),V=p.radius,I=o.horizontalScale,T=u-1,B=u-2,{minu:P,minv:C,maxu:L,maxv:U,boundingBox:O,vertexAttributes:D}=s,{position:R,uv0:w}=D,{typedBuffer:F,typedBufferStride:q}=D.normalCompressed,H=a[0],_=a[1],W=a[2],k=R.typedBuffer,G=R.typedBufferStride;let z=0;const J=t.clamp(M,A,b),K=g?(Math.PI/2-2*Math.atan(Math.exp(-J/V)))*V:J*I,Q=1/T,X=t.clamp(M*(1-Q)+y*Q,A,b);let Y=K,Z=g?(Math.PI/2-2*Math.atan(Math.exp(-X/V)))*V:X*I;for(let e=1;e<=B;e++){const o=e/T,s=t.clamp(M*(1-o)+y*o,A,b),i=t.clamp(o,C,U),a=Z,c=(e-1)/T,u=t.clamp(M*(1-c)+y*c,A,b),d=Y,m=(e+1)/T,p=t.clamp(M*(1-m)+y*m,A,b),h=g?(Math.PI/2-2*Math.atan(Math.exp(-p/V)))*V:p*I,D=t.clamp(m,C,U);Y=Z,Z=h;const R=t.clamp(x,S,E);let N=R*I,J=r.sampleElevation(R,s,l);const K=1/T,Q=t.clamp(K,P,L),X=t.clamp(x*(1-Q)+v*Q,S,E);let $=Q,ee=X,te=X*I,ne=r.sampleElevation(X,s,l);if(1===e){const e=te-H,o=Y-_,s=ne-W,r=0*G;k[r]=e,k[r+1]=o,k[r+2]=s,j(e,o,s,O);const a=t.clamp(K,P,L);w.setValues(z,Math.round(a*n.maxUint16),Math.round(i*n.maxUint16))}for(let o=1;o<=B;o++){const c=te,m=ne,g=(o+1)/T,M=t.clamp(g,P,L),y=t.clamp(x*(1-g)+v*g,S,E),A=ee;ee=y;{const t=z+1,c=t*G;if(1===e||o===B){const u=y*I,d=r.sampleElevation(y,s,l);if(1===e&&o<B){const e=u-H,o=a-_,s=d-W;k[c]=e,k[c+1]=o,k[c+2]=s,j(e,o,s,O),w.setValues(t,Math.round(M*n.maxUint16),Math.round(i*n.maxUint16))}te=u,ne=d}else te=k[c]+H,ne=k[c+2]+W}const b=te,V=ne,C=N,U=J;N=c,J=m;const R=(z-B)*G,K=1===e?r.sampleElevation(A,u,l):k[R+2]+W,Q=r.sampleElevation(A,p,l);if(e<B){const e=z+B,t=e*G,o=c-H,s=h-_,r=Q-W;k[t]=o,k[t+1]=s,k[t+2]=r,j(o,s,r,O);const i=$;$=M,w.setValues(e,Math.round(i*n.maxUint16),Math.round(D*n.maxUint16))}{const e=b-C,t=d-h,n=t*(V-U),o=e*(K-Q),s=-t*e,r=n*n+o*o+s*s;if(0===r)f.compressNormal(F,z,0,0,1,q);else{const e=1/Math.sqrt(r);f.compressNormal(F,z,n*e,o*e,s*e,q)}}++z}}}(e),l.edgeVerticesStartIndex=V,I(e),v(e),A(l,[],d),e.intersectionData=null},e.createSphericalGlobePatch=function(e,t){const{tile:s,geometry:a,geometryState:l}=e,{extentInRadians:c,surface:u}=s,{isWebMercator:d,renderer:m}=u,{numVerticesPerSide:g,wireframe:h}=l,v=g-1,y=(g-2)**2,S=d&&(t===i.PatchType.HAS_SOUTH_POLE||t===i.PatchType.HAS_BOTH_POLES),E=d&&(t===i.PatchType.HAS_NORTH_POLE||t===i.PatchType.HAS_BOTH_POLES),b=6*((S?1:0)+(E?1:0))*g,V=_(l),T=y+b+4*V,B=m.tileGeometryCache.acquire(T);a.numVerticesPerSide=g,a.vertexAttributes=B,a.maxEdgeVertexCount=V;const{boundingBox:P}=a;o.empty(P);const C=M(e);R.update(v,c,C),function(e){const{tile:t}=e;if(!t.intersectsClippingArea)return;const{geometry:o,geometryState:s,localOrigin:i}=e,{numVerticesPerSide:a,samplerData:l}=s,c=a-2,u=a-1,{vertexAttributes:d,boundingBox:m}=o,{position:p,uv0:g}=d,{typedBuffer:h,typedBufferStride:x}=d.normalCompressed,{extent:M}=t,v=M[0],y=M[2],S=M[1],E=M[3],A=t.ellipsoid.radius,b=i[0],V=i[1],I=i[2],T=p.typedBuffer,B=p.typedBufferStride,P=1/u;let C=0;if(1<=c){const e=P,t=S*(1-e)+E*e,o=R.sinLatLUT[1],s=R.cosLatLUT[1];for(let i=1;i<=c;i++){const a=i*P,c=v*(1-a)+y*a,u=R.sinLonLUT[i],d=R.cosLonLUT[i],f=A+r.sampleElevation(c,t,l),p=f*d*s-b,h=f*u*s-V,x=f*o-I;j(p,h,x,m);const M=(i-1)*B;T[M]=p,T[M+1]=h,T[M+2]=x,g.setValues(i-1,Math.round(a*n.maxUint16),Math.round(e*n.maxUint16))}}for(let e=1;e<=c;e++){const t=e*P,o=S*(1-t)+E*t,s=R.sinLatLUT[e],i=R.cosLatLUT[e],a=e+1,d=a*P,p=S*(1-d)+E*d,M=R.sinLatLUT[a],L=R.cosLatLUT[a],U=R.sinLonLUT[0],O=R.cosLonLUT[0],D=A+r.sampleElevation(v,o,l);let N=O*i*D-b,w=U*i*D-V,F=s*D-I;const q=C*B;let H=T[q],_=T[q+1],W=T[q+2];for(let t=1;t<=c;t++){const a=t*P,E=v*(1-a)+y*a,U=R.sinLonLUT[t],O=R.cosLonLUT[t];let D=0,q=0,k=0;if(t<c){const e=(C+1)*B;D=T[e],q=T[e+1],k=T[e+2]}else{const e=R.sinLonLUT[u],t=R.cosLonLUT[u],n=A+r.sampleElevation(y,o,l);D=t*i*n-b,q=e*i*n-V,k=s*n-I}const G=N,z=w,J=F;N=H,w=_,F=W,H=D,_=q,W=k;const K=D-G,Q=q-z,X=k-J;let Y=0,Z=0,$=0;if(e>1){const e=(C-c)*B;Y=T[e],Z=T[e+1],$=T[e+2]}else{const e=R.sinLatLUT[0],t=R.cosLatLUT[0],n=A+r.sampleElevation(E,S,l);Y=O*t*n-b,Z=U*t*n-V,$=e*n-I}const ee=A+r.sampleElevation(E,p,l),te=O*L*ee-b,ne=U*L*ee-V,oe=M*ee-I;if(e<c){const e=C+c,t=e*B;T[t]=te,T[t+1]=ne,T[t+2]=oe,j(te,ne,oe,m),g.setValues(e,Math.round(a*n.maxUint16),Math.round(d*n.maxUint16))}const se=Y-te,re=Z-ne,ie=$-oe;let ae=O*i,le=U*i,ce=s;ce*ce<.999&&(ae=X*re-Q*ie,le=K*ie-X*se,ce=Q*se-K*re);const ue=1/Math.sqrt(ae*ae+le*le+ce*ce);f.compressNormal(h,C,ae*ue,le*ue,ce*ue,x),++C}}}(e),a.poleVerticesStartIndex=y;const L=function(e,t,o){const{tile:s,localOrigin:r,geometry:i}=e,{extent:a,ellipsoid:l}=s,{boundingBox:c,numVerticesPerSide:u,vertexAttributes:d,poleVerticesStartIndex:m}=i,p=u-1,g=r[0],h=r[1],M=r[2],v=l.radius,y=a[1],S=a[3],E=[];let A=m;const b=(e,t)=>{const o=t*u;j(-g,-h,e*v-M,c),E.push(new O(1===e,o,1===e?0:2,A,6));const s=x(-1===e?y:S,v),r=e*Math.PI/2-s,i=.99*(1===e?1:-1),a=v+0,{position:l,uv0:m}=d,{typedBuffer:b,typedBufferStride:V}=d.normalCompressed;for(let e=1;e<=6;++e){const t=s+r*(e/6),o=Math.cos(t),u=Math.sin(t);for(let e=0;e<=p;e++){const t=e/p,s=R.sinLonLUT[e],r=R.cosLonLUT[e]*o,d=s*o,x=u,v=r*a-g,y=d*a-h,S=x*a-M;j(v,y,S,c),l.setValues(A,v,y,S),m.setValues(A,Math.round(t*n.maxUint16),Math.round(i*n.maxUint16)),f.compressNormal(b,A,r,d,x,V),++A}}};return t&&b(-1,0),o&&b(1,p),E}(e,S,E);a.edgeVerticesStartIndex=y+b,I(e),p(e),A(a,L,h),e.intersectionData=null},e.updateCornerSpherical=function(e){e.tile.intersectsClippingArea&&(h(e),g(e,!0),L(e),e.intersectionData=null)},e.updateCornersPlanar=function(e,t){e.tile.intersectsClippingArea&&(S(e),y(e,!0),L(e),e.intersectionData=null)},e.updateEdgeElevationsAndResolutionsPlanar=function(e,t){e.tile.intersectsClippingArea&&(T(e),v(e),L(e),U(e),e.intersectionData=null)},e.updateEdgeElevationsAndResolutionsSpherical=function(e){e.tile.intersectsClippingArea&&(T(e),p(e),L(e),U(e),e.intersectionData=null)},e.updateEdgesAndCornersPlanar=function(e,t){e.tile.intersectsClippingArea&&(v(e),L(e),e.intersectionData=null)},e.updateEdgesAndCornersSpherical=function(e){e.tile.intersectsClippingArea&&(p(e),L(e),e.intersectionData=null)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));