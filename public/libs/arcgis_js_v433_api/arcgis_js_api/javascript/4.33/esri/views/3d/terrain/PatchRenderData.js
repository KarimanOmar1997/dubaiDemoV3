// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/has","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./interfaces","./LayerClass","./NeighborIndex","./PatchGeometry","./TerrainConst","./terrainUtils","./TextureFader","./TextureReference","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject","../../webgl/enums"],(function(e,t,r,i,s,n,a,l,o,d,g,h,c,u,m,f,y,p,x,_,A,v,b,C,E){"use strict";const T=a.create(),S=a.create(),$=a.create(),D=a.create(),R=a.create(),V=a.create(),w=[null,null,null,null];function N(e,t){return t?.loaded||t===e?t:null}const I=[0,1,2,3];e.PatchRenderData=class{constructor(){this.geometry=new m.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._vao=null,this._texture=null,this._textureOpacity=1,this._textureRef=new p.TextureFader((()=>this._tile.surface.fadeDuration)),this.overlay=new _,this._localOrigin=null,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._modifiedFlags=0}get tile(){return this._tile}get localOrigin(){return this._localOrigin}init(e,t){this.clear(),this._tile=e,this.geometry.reset(),this.intersectionData=null,this.geometryState=new g.GeometryState,this._localOrigin=t,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this.wireframeChanged||this.clippingAreaChanged||this.samplerDataChanged||this.numVerticesPerSideChanged||this.dirtyCorners||this.dirtyEdgeResolutions||this.dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),y.enableTerrainInternalChecks&&this.tile.intersectsClippingArea)for(let e=0;e<4;++e)y.internalAssert(this.geometry.getEdgeCount(e)===this.geometryState.edgeResolutions[e]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,n=y.neighborEdgeIndices[e];if(!t)return y.internalAssert(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(n)),i;if(t.loaded){const r=t,n=r.renderData.geometryState,a=s-r.level;if(y.internalAssert(a>=0),0===a){const e=n.numVerticesPerSide-1;return Math.max(e,i)}const l=2**a,o=n.edgeResolutions[(e+2)%4]/l;return Math.max(1,o)}y.internalAssert(!t.leaf);let a=i;return t.forAllSubtreeOnSide(y.oppositeEdge(n),(e=>e===r||(e.loaded?(a=Math.max(a,2**(e.level-s)),!0):(y.internalAssert(!e.leaf),!1)))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState,r=t=>(t.loaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let a=0;a<4;++a){const l=e.findNeighborTile(y.neighborEdgeIndices[a],r),o=N(e,l),d=o?.renderData?.geometryState.samplerDataVersion??-1,g=s[a],h=o!==N(e,g),c=n[a]!==d;y.enableTerrainInternalChecks&&l&&(y.internalAssert(e.level>=l.level),y.internalAssert(e.level-l.level<=f.maxTileNeighborLevelDelta)),s[a]=l,(h||c)&&(n[a]=d,this._markEdgeDirty(a));const u=t.edgeResolutions[a],m=this._calculateEdgeResolution(a,l);y.internalAssert(i.isPowerOfTwo(m)),y.internalAssert(m>=1),t.edgeResolutions[a]=m,u!==m&&this._markEdgeResolutionDirty(a)}for(let i=0;i<4;++i){const n=e.findNeighborTile(y.neighborCornerIndices[i],r);t.cornerPeerNeighbors[i]=n;const a=N(e,s[i]),l=N(e,s[(i+1)%4]),o=N(e,n);w[i]=o,w[(i+1)%4]=l,w[(i+2)%4]=e,w[(i+3)%4]=a,y.internalAssert(w.some((t=>t?.loaded||t===e)));const d=w.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);w.forEach(((e,t)=>{e&&e?.level>d&&(w[t]=null)})),y.internalAssert(w.some((t=>t?.loaded||t===e)));const g=t.cornerNeighborCornerTiles,h=t.cornerNeighborCornerTileSamplerVersions;for(let e=0;e<4;++e){const t=w[e],r=t?.renderData.geometryState.samplerDataVersion??-1,s=4*i+e,n=g[s]!==t,a=!n&&h[s]!==r;(n||a)&&(g[s]=t,h[s]=r,this._markCornerDirty(i))}y.enableTerrainInternalChecks&&y.internalAssert(I.some((t=>g[4*i+t]?.loaded||g[4*i+t]===e)))}y.enableTerrainInternalChecks&&y.internalAssert(this.geometryState.edgeResolutions.every((e=>e>0)));for(let e=0;e<4;++e)w[e]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;y.enableTerrainInternalChecks&&y.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const{tile:t,_vao:r,geometry:i,geometryState:s}=this,n=!r||this.wireframeChanged||this.samplerDataChanged||this.clippingAreaChanged||this.numVerticesPerSideChanged,a=0!==this.dirtyEdgeResolutions,l=s.edgeResolutions.reduce(((e,t)=>e+t+1),0),o=n||a&&l>(i?.maxEdgeVertexCount??0),d=!o&&a,g=!d&&(0!==this.dirtyEdges||a),h=!g&&0!==this.dirtyCorners;o?(this.releaseGeometry(),this._createGeometry(e)):d?t.updateEdgeElevationsAndResolutions():g||h?t.updateEdgeElevations():h?t.updateCornerElevations():console.warn("Update for no reason?"),this._modifiedFlags=0}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=s.disposeMaybe(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r,i){const s=t?E.PixelFormat.RGBA:E.PixelFormat.RGB;return null!=this._texture&&(r===h.TextureUpdate.FADING&&this._tile.surface.fadeDuration>0&&this._isTextureVisible(this._texture)||this._texture.descriptor.width!==e||this._texture.descriptor.pixelFormat!==s)&&this.releaseTexture(),null==this._texture&&(this._texture=i(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){this._texture&&(this._texture=s.releaseMaybe(this._texture),this.tile.setMemoryDirty())}reuseTexture(e,t){return!(!e||!this._texture||(e.setTextureReference(new x.TextureReference(this._texture,h.TextureUpdate.FADING,t,this._textureOpacity,0,1)),0))}get numVerticesPerSideChanged(){return!!(1&this._modifiedFlags)}get samplerDataChanged(){return!!(2&this._modifiedFlags)}get clippingAreaChanged(){return!!(4&this._modifiedFlags)}get wireframeChanged(){return!!(8&this._modifiedFlags)}get dirtyEdges(){return this._modifiedFlags>>4&15}get dirtyCorners(){return this._modifiedFlags>>8&15}get dirtyEdgeResolutions(){return this._modifiedFlags>>12&15}_markCornerDirty(e){const t=1<<e<<8;this._modifiedFlags|=t}_markEdgeDirty(e){const t=1<<e<<4;this._modifiedFlags|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e<<12;this._modifiedFlags|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._modifiedFlags|=65520}updateGeometryState(){const e=this._elevationInfo,r=this.tile,i=e.samplerData?r.getElevationVerticesPerSide(e.maxTileLevel):r.minimumVerticesPerSide,s=Math.max(i,5);let n=r.clippingArea;r.intersectsClippingArea&&!r.withinClippingArea||(n=null);const a=this.geometryState;let l=!1;a.numVerticesPerSide!==s&&(this._modifiedFlags|=1,a.numVerticesPerSide=s,a.samplerDataVersion++,l=!0),e.changed&&(this._modifiedFlags|=2,a.samplerData=e.samplerData,a.samplerDataVersion++,l=!0),t.equals(a.clippingArea,n)||(this._modifiedFlags=4,a.clippingArea=n,l=!0);const o=r.surface.wireframe;return a.wireframe!==o&&(this._modifiedFlags=8,a.wireframe=o,l=!0),this._geometryStateChangedSinceLastUpdate||=l,l&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new v.VertexArrayObject(e,b.vertexAttributeLocations,new Map([["geometry",d.glLayout(t.layout)]]),new Map([["geometry",C.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)]]),C.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=p.ActivationTime.Immediate){e?.texture===this._texture?this._textureOpacity=e.opacities[0]:this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_isTextureVisible(e){return this._textureRef.current?.texture===e||this._textureRef.next?.texture===e&&this._textureRef.fadeFactor<1}get _elevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[c.LayerClass.ELEVATION],r=t.length,i=new Array(r);let s=0,n=0,a=!1;for(let l=0;l<r;l++){const r=t[l],o=r.upsampleInfo?.tile;if(o){const t=o.layerInfo[c.LayerClass.ELEVATION][l].data,r=t&&t.samplerData;e&&e[s]===r||(a=!0),i[s++]=r,n=Math.max(n,o.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(l,c.LayerClass.ELEVATION);if(A.fallsWithinLayerView(this.tile,t)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,n=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const l=s>0,o=l?i:null;return l&&(i.length=s),{changed:a,samplerData:o,maxTileLevel:n}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){}checkGeometryWaterproofness(){if(!y.enableTerrainInternalChecks)return;const e=this.tile;if(!e.loaded||!e.intersectsClippingArea||0===e.level)return void y.internalAssert(e?.loaded);const t=e.surface.extent;if(null!=t&&!e.intersectsExtent(t))return;const r=y.neighborEdgeIndices.map(((r,i)=>null!=t&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0)),s=e.level;y.internalAssert(0===this.dirtyCorners),y.internalAssert(0===this.dirtyEdges),y.internalAssert(0===this.dirtyEdgeResolutions),y.internalAssert(!this.numVerticesPerSideChanged),y.internalAssert(!this.samplerDataChanged),y.internalAssert(!this.clippingAreaChanged),y.internalAssert(!this.wireframeChanged);const d=y.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.loaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),g=this.geometryState;for(let t=0;t<4;++t){const r=g.cornerPeerNeighbors[t],i=d[t];y.internalAssert(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}y.neighborEdgeIndices.forEach(((t,d)=>{if(r[d])return;const g=e.findNeighborTile(t,(e=>(e.level===s||e?.loaded)&&e?.intersectsClippingArea));if(!g){const r=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void y.internalAssert(!r)}y.internalAssert(g.loaded||g.level===e.level),y.internalAssert(g===this.geometryState.edgePeerNeighbors[d]);const h=s-g.level;if(!g.loaded)return y.internalAssert(!g.leaf),void y.internalAssert(0===h);const c=g.renderData;y.internalAssert(e.isEdgeNeighbor(g,t)),y.internalAssert(h>=0);const m=2**h;if(h<0)return void y.internalAssert(!1);const f=e.renderData,p=f.geometry,x=f.localOrigin,_=p.getEdgeCount(d),A=p.numVerticesPerSide-1,v=c.geometry;if(!v)return void y.internalAssert(!1);const b=c.localOrigin,C=this.geometryState.edgePeerNeighbors[d];if(C?.loaded){const e=C.renderData;y.internalAssert(f.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion),y.internalAssert(this.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion)}const E=(d+2)%4,w=v.getEdgeCount(E),N=_-1,I=w-1;y.internalAssert(N*m===I,`Tile[${e.lij}]:e${d},res=${N} edgeRes mismatch with Neighbor[${g.lij}]:e${E},res=${I} (expected:${N*m})`);const P=e.extent,F=t===u.NeighborIndex.NORTH||t===u.NeighborIndex.SOUTH,O=w-1,G=O>>h,j=_-1;if(G<1)return void y.internalAssert(1===j);y.internalAssert(G===j),y.internalAssert(i.isPowerOfTwo(G));const M=v.numVerticesPerSide-1;y.internalAssert(h>0||G===Math.max(M,A));const L=e.getNeighborEdgeStartVertexIndex(d,g);y.internalAssert(0<=L&&L<m);const k=L*G;y.internalAssert(0<=k&&k<=O-G);let U=0,B=k;p.getEdgeVertexPosition(d,T,x,0),p.getEdgeVertexPosition(d,S,x,_-1);const X=n.distance(T,S),H=Math.max(1,1e-4*X);for(let r=0;r<=G;++r){p.getEdgeVertexPosition(d,T,x,U),v.getEdgeVertexPosition(E,S,b,B);const i=r/G,s=F?P[0]+i*(P[2]-P[0]):t===u.NeighborIndex.WEST?P[0]:P[2],h=F?t===u.NeighborIndex.SOUTH?P[1]:P[3]:P[1]+i*(P[3]-P[1]),m=e.surface.extent;if(null==m||l.containsXY(m,s,h)){const t=n.dist(T,S),r=n.len(T)-o.earth.radius,i=n.len(S)-o.earth.radius,l=t<H;if(!l){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${d}[${U}/${_}] and [${g.lij}].edge${E}[${B}/${w}]`),null!=m&&console.warn("  surface extent= ",m," x,y=",s,",",h);const o=a.create();n.subtract(o,f.localOrigin,c.localOrigin),n.len(o)>0&&console.warn(`   localOrigins: ${f.localOrigin} vs ${c.localOrigin} d=${n.len(o)} [${o}]`),(()=>{const t=a.clone(T),r=a.clone(S);e.updateEdgeElevations(),g.updateEdgeElevations(),p.getEdgeVertexPosition(d,T,x,U),v.getEdgeVertexPosition(E,S,b,B);const i=a.create();n.sub(i,T,t),n.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${T} d=${n.len(i)} [${i}]`),n.sub(i,S,r),n.len(i)>0&&console.warn(`  XXX Neighbor[${g.lij}] edge out of date: ${r} vs ${S} d=${n.len(i)} [${i}]`)})();const u=p.getEdgeCount(d),A=v.getEdgeCount(w);y.internalAssert(l,`Mismatch in tile [${e.lij}].edge[${d}][${U}/${u}] vs neighbor [${g.lij}].edge[${E}][${B}/${A}] ${y.v32s(T)} vs ${y.v32s(S)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}p.getEdgeNormal(d,$,U),v.getEdgeNormal(E,D,B),n.normalize(R,$),n.normalize(V,D);const u=n.dot(R,V),A=1-u<.01||e===g;if(!A){const t=a.create();n.sub(t,$,D);const r=()=>`Mismatch in tile edge normal ${y.lij2s(e.lij)} (${U}/${_-1}) edge ${d} vs neighbor ${y.lij2s(g.lij)}  (${B}/${w-1}) nedge ${E} :${y.v32s($)} vs ${y.v32s(D)}  dot = ${u} : ${y.v32s(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),g.updateEdgeElevations();const t=a.create(),r=a.create();p.getEdgeNormal(d,t,U),v.getEdgeNormal(E,r,B),n.equals($,t)||console.warn("Missing update in tile normal: ",y.v32s($)," => ",y.v32s(t)),n.equals(D,r)||console.warn("Missing update in neighbor normal: ",y.v32s(D)," => ",y.v32s(r))}y.internalAssert(A,r())}}U+=1,B+=1}}))}},e.neighborTileIfLoadedOrSelf=N,e.zeroToFour=I,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));