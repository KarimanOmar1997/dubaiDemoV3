// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/mathUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/projection/lonLatToSphericalPCPF","../../../geometry/support/DoubleArray","../../../geometry/support/frustum","../../../chunks/sphere","./interfaces","./PatchGeometryFactory","./terrainUtils","./Tile","./TileFrustumVisibility","./tileUtils"],(function(e,t,i,s,n,o,r,a,l,c,h,u,d,p){"use strict";class m extends u.Tile{constructor(e,t,i,s,n){super(),this._convexHull=new Array(24),this._boundingSphere=a.create(),this._baseUsedMemory=1816,this.init(e,t,i,s,n)}init(e,s,o,r,a){super.init(e,s,o,r,a);const l=this.ellipsoid.radius,c=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],d=this.extentInRadians[3],p=t.lerp(h,d,.5),m=t.lerp(c,u,.5),f=0===e?0:Math.min(Math.abs(h),Math.abs(d));this._edgeLen=(u-c)*Math.cos(f)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),n.lonLatToSphericalPCPF(this.centerAtSeaLevel,m,p,this.ellipsoid.radius),i.normalize(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])i.set(a.getCenter(e[u.CenterPosition.MIDDLE]),0,0,0),i.set(e[u.CenterPosition.TOP],0,0,0),i.set(e[u.CenterPosition.BOTTOM],0,0,0),e[u.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const i=e[u.CenterPosition.MIDDLE],o=this.convexHull;let r=0;for(let e=0;e<8;++e)r=Math.max(r,(s=o,n=3*e,g((t=a.getCenter(i))[0],t[1],t[2],s[n],s[n+1],s[n+2])));e[u.CenterPosition.MIDDLE][3]=Math.sqrt(r)}var t,s,n}_calculateFrustumVisibility(e){if(!r.intersectsSphere(e,this._boundingSphere))return d.TileFrustumVisibility.OUTSIDE;if(this.lij[0]<10)return d.TileFrustumVisibility.INTERSECTS;const t=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let n=0;n<r.numPlanes;n++){const o=n===r.PlaneIndex.NEAR,a=e[n],l=a[0],c=a[1],h=a[2],u=a[3]-(o?i:0);let p=!1;for(let e=0;e<8;++e){const i=3*e;if(l*t[i]+c*t[i+1]+h*t[i+2]+u<0){if(p=!0,!s)break}else s=!1}if(!p)return d.TileFrustumVisibility.OUTSIDE}return s?d.TileFrustumVisibility.INSIDE:d.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){c.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),h.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const e=this._boundingSphere,t=a.getCenter(e),s=this.elevationBoundsMin,n=this.elevationBoundsMax,o=this.ellipsoid.radius,r=n;if(0===this.level)i.set(t,0,0,0),e[3]=o+r;else{const r=this.extentInRadians,a=.5*(r[0]+r[2]),l=r[1],c=r[3];x(v,a,l,o),x(_,a,c,o),i.add(t,v,_);const h=o+.5*(s+n);i.scale(t,t,h/i.len(t));const u=this.convexHull;let d=0;const p=(e,t)=>{const i=e[0]-u[3*t],s=e[1]-u[3*t+1],n=e[2]-u[3*t+2];return Math.sqrt(i*i+s*s+n*n)};for(let e=0;e<8;++e){const i=p(t,e);d=Math.max(d,i)}const m=d;e[3]=m+2}}_updateConvexHull(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const n=this.elevationBoundsMin,o=this.elevationBoundsMax,r=this._getPatchType(),a=this.surface.isWebMercator,c=a&&r===l.PatchType.HAS_NORTH_POLE,u=a&&r===l.PatchType.HAS_SOUTH_POLE,d=u||c,p=Math.PI/2,m=e[0],f=e[2],g=u?-p:e[1],v=c?p:e[3],_=.5*(m+f),T=n,$=t+(d?Math.min(0,T-1):T),M=(e,t,i)=>x(e,t,i,$),S=s.create(),y=s.create(),P=s.create(),E=s.create();M(S,m,g),M(y,m,v),M(P,f,v),M(E,f,g);const C=(e,t)=>{for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]};C(S,0),C(y,1),C(P,2),C(E,3);const A=o,I=t+(d?Math.max(0,A+1):A),B=s.create(),L=s.create(),H=s.create();x(L,_,v,$),x(H,_,g,$),i.add(B,L,H),i.normalize(B,B);const D=s.create(),R=s.create(),V=(e,t)=>{i.sub(R,e,t),i.normalize(R,R);const s=-i.dot(e,D)/i.dot(R,D);h.internalAssert(s>=0),i.scale(R,R,s),i.add(e,e,R)};if(2**this.lij[0]>2*this.lij[1]){const e=H,t=s.create();i.cross(t,b,e),i.normalize(t,t),i.cross(D,e,t),i.normalize(D,D),h.internalAssert(h.almostEquals(i.dot(D,e)/i.len(e),0)),V(S,y),V(E,P),C(S,0),C(E,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=L,t=s.create();i.cross(t,b,e),i.normalize(t,t),i.cross(D,t,e),i.normalize(D,D),V(y,S),V(P,E),C(y,1),C(P,2)}const j=(e,t)=>{const s=I/i.dot(t,B);for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]*s};j(4,S),j(5,y),j(6,P),j(7,E)}_getPatchType(){const e=this.lij[1],t=0===e,i=e===(1<<this.level)-1;return t?i?l.PatchType.HAS_BOTH_POLES:l.PatchType.HAS_NORTH_POLE:i?l.PatchType.HAS_SOUTH_POLE:l.PatchType.REGULAR}intersectsRay(e,t,i,s){const n=this._boundingSphere,o=n[3]+i,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],a=n[0]-e[0],l=n[1]-e[1],c=n[2]-e[2],h=(a*t[0]+l*t[1]+c*t[2])/r,u=t[0]*h-a,d=t[1]*h-l,p=t[2]*h-c;return u*u+d*d+p*p<o*o}get minimumVerticesPerSide(){return this.level<f.length?f[this.level]+1:2}updateCornerElevations(){c.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){c.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){c.updateEdgeElevationsAndResolutionsSpherical(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!h.enableTerrainInternalChecks)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],n=a.getCenter(e),r=s.create(),l=this.ellipsoid.radius,c=this.elevationBoundsMin,d=this.elevationBoundsMax,m=l+c,f=this._center[u.CenterPosition.MIDDLE][3],b=this.convexHull,v=(e,t)=>{for(let i=0;i<3;++i)e[i]=b[3*t+i]};{const e=s.create(),t=s.create(),n=s.create(),o=s.create(),r=s.create(),a=(s,a,l,c)=>{v(t,s),v(n,a),v(o,l),i.sub(t,t,n),i.sub(o,o,n),i.cross(e,t,o),i.normalize(e,e);const u=i.dot(e,n);v(r,c);const d=i.dot(e,r),p=Math.abs(d-u);h.internalAssert(h.almostEquals(p,0),`Non coplanar ${s},${a},${l},${c} diff = ${p}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const _=o.newDoubleArray(24),T=s.create(),$=s.create(),M=s.create(),S=s.create(),y=(e,t,s,n)=>{v(T,t),v($,s),v(M,n),i.sub(T,T,$),i.normalize(T,T),i.sub(M,M,$),i.normalize(M,M),i.cross(S,T,M),i.normalize(S,S);const o=i.dot(S,$);((e,t,i)=>{const s=4*e;for(let e=0;e<3;++e)_[s+e]=t[e];_[s+3]=i})(e,S,o)};y(0,0,1,2),y(1,1,0,4),y(2,1,5,2),y(3,3,2,6),y(4,4,0,3),y(5,4,6,5);const P=(e,t,i,s)=>{const n=4*e;return _[n]*t+_[n+1]*i+_[n+2]*s-_[n+3]},E=(e,t,i,s)=>P(e,t,i,s)>=-1,C=(e,t)=>E(e,t[0],t[1],t[2]),A=2**this.lij[0]>2*this.lij[1],I=(e,i,s)=>Math.sqrt(g(e,i,s,n[0],n[1],n[2]))<t,B=e=>I(e[0],e[1],e[2]),L=this.extentInRadians,H=.5*(L[0]+L[2]),D=L[1],R=L[3],V=s.create(),j=s.create();x(V,H,R,m),x(j,H,D,m);const O=A?"Upper":"Lower";let F=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const i=3*t,s=E(e,b[i],b[i+1],b[i+2]);F&&=s,h.internalAssert(s,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}h.internalAssert(C(e,j),`Tile[${this.lij}] (${O}) bottom mid outside of plane ${e}`),h.internalAssert(C(e,V),`Tile[${this.lij}] (${O}) top mid outside of plane ${e}`)}h.internalAssert(F,"Not all convex hull points are inside  convex hull polyhedron"),h.internalAssert(B(j),`Tile[${this.lij}] (${O}) bottom mid outside of bounding sphere`),h.internalAssert(B(V),`Tile[${this.lij}] (${O}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=I((z=b)[k=3*e],z[k+1],z[k+2]);h.internalAssert(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}var z,k;for(let e=0;e<6;++e)for(let t=0;t<8;++t){const i=3*t;E(e,b[i],b[i+1],b[i+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:N}=this,U=Math.max(N[2]-N[0],N[3]-N[1]),q=Math.round(U*l),{renderData:w}=this;if(!w)return;const{geometry:G,geometryState:W,localOrigin:J}=w,K=G.vertexAttributes?.position;if(!K)return;const Q=s.create(),X=G.numVerticesPerSide-2,{indices:Y,indexCount:Z,edgeVerticesStartIndex:ee,poleVerticesStartIndex:te}=G;if(!Y)return;const ie=new Set;for(let e=0;e<Z;++e){const s=Y[e];if(ie.has(s))continue;ie.add(s);const o=s<te,a=s>=ee;let h=!1,u=-1;if(a){let e=ee;for(let t=0;t<4;++t){const i=W.edgeResolutions[t];if(s===e||s===e+i-1){h=!0;break}if(e+=i,s<e){u=t;break}}}const m=a?W.edgePeerNeighbors[u]:null,g=a&&m&&p.compareTilesByLij(this,m)>0;K.getVec(s,r),i.add(Q,r,J);const x=i.len(Q)-l;let b=0,v=!1;const _=c-x,T=x-d,$=_>1,M=T>1,S=$||M,y=()=>{const e=o?"internal":a&&!h?"edge":h?"corner":"pole";return`Tile[${this.lij}].vertex[${s}]:${e}`+($?"(below)":M?"(above)":"")+(g?"(Neighbor)":"")},C=i.dist(Q,n);if(C>=t+0){const e=C-t;S||(console.error(`${y()} is out of the bounding sphere by ${e.toFixed(0)} / ${t.toFixed(0)}[tol=0] h=${x.toFixed(0)} / [${c.toFixed(0)}..${d.toFixed(0)}] (${(e/t).toFixed(0)})`),v=!0)}for(let e=0;e<6;++e)if(!E(e,Q[0],Q[1],Q[2])){const i=P(e,Q[0],Q[1],Q[2]),n=s%X,o=(s-n)/X;0===e&&_||5===e&&T||(console.error(`${y()} (${n},${o})|${X}] is out of the bounding trapezoid plane ${e} h=${Math.round(x)} / [${Math.round(c)}..${Math.round(d)}] dist=${Math.round(i)} radii = ${Math.round(t)}/${Math.round(f)}} : maxL = ${q}`),++b)}if(v||b>0)break}}get convexHull(){return this._convexHull}}const f=[128,64,64,32,16,8,8,4];function g(e,t,i,s,n,o){const r=s-e,a=n-t,l=o-i;return r*r+a*a+l*l}const x=(e,t,i,s)=>{const n=Math.cos(t),o=Math.sin(t),r=Math.cos(i),a=Math.sin(i);e[0]=s*r*n,e[1]=s*r*o,e[2]=s*a},b=[0,0,1],v=s.create(),_=s.create();e.SphericalPatch=m,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));