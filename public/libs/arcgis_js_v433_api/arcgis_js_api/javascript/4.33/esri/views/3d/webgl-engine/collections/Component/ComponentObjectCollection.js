// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../../core/Logger","../../../../../core/MapUtils","../../../../../core/PooledArray","../../../../../core/typedArrayUtil","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/support/aaBoundingBox","../../../../../geometry/support/Indices","../../../../../chunks/vec3","../../../../../chunks/vec33","../../../../ViewingMode","../../../layers/support/symbolColorUtils","../../../support/orientedBoundingBox","../../../support/buffer/glUtil","../../../support/buffer/InterleavedLayout","./ComponentData","./ComponentObject","./IntersectionGeometry","./Renderable","./RenderGeometry","./RenderSubmitSystem","./SourceGeometry","./UniformComponentParameters","./Material/ComponentMaterial","./Material/ComponentTechnique","./Material/shader/ComponentData.glsl","../../effects/geometry/olidUtils","../../lib/ComponentUtils","../../lib/Util","../../lib/VertexAttribute","../../lib/verticalOffsetUtils","../../lib/TextureBackedBuffer/BufferManager","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,n,i,o,r,a,s,l,c,m,h,f,g,p,d,u,b,y,v,C,_,M,O,w,x,D,A,R,S,P,V,E,I,U,B,j){"use strict";const H=()=>n.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection"),L=d.glLayout(u.newLayout().u16(V.VertexAttribute.COMPONENTINDEX));function T(e,t){return e===t?x.ComponentParameterSummary.All:0===e?x.ComponentParameterSummary.None:x.ComponentParameterSummary.Some}const N=l.create();t.ComponentObjectCollection=class{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._activeHighlightOptions=new Map,this._visible=new o,this._hidden=new o,this._renderSubmit=new M.RenderSubmitSystem(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new I.BufferManager(e.rctx,2+(R.olidEnabled()?1:0))}destroy(){P.assert(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._visible.forAll((e=>e.destroy())),this._visible.clear(),this._hidden.forAll((e=>e.destroy())),this._hidden.clear()}createObject(e){const t=e.geometry,n=new b.ComponentData(this._componentBufferManager,c.compactIndices(t.componentOffsets)),i=this._createRenderable(e,n),o=new v.IntersectionGeometry(this._viewingMode,t.positionData,n),r=new y.ComponentObject(e.transform,e.toMapSpace,e.obb.clone(),n,i,o);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const n=e;t!==n.visible&&(t?(this._hidden.removeUnordered(n),this._visible.push(n)):(this._visible.removeUnordered(n),this._hidden.push(n)),n.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=a.squaredDistance(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const n=e.renderable.material;t(n),n.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const n=e;n.componentData.visibility.reset(t),n.componentData.markVisibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.componentData.visibility.forEachComponent(t)}getComponentCount(e){const t=e,n=t.componentData.visibility.componentCount;return{visible:n,invisible:t.componentData.count-n}}setComponentData(e,t){const n=e,{renderable:i,componentData:o}=n,r=i.material,a=o.materialDataBuffer,s=o.materialDataIndices,l=new w.UniformComponentParameters,c=a.textureBuffer,m=new Uint8Array(4),h=new Uint32Array(m.buffer);let f=0,d=0,u=0,b=o.verticalOffsets,y=1/0,v=-1/0,C=!1,_=!1,M=0;for(let e=0;e<o.count;e++){t(e,l),f+=+(l.externalColor[3]<1),d+=+(l.externalColorMixMode===g.ColorMixModeEnum.Replace&&1===l.externalColor[3]),u+=+l.castShadows,g.encodeSymbolColor(l.externalColor,l.externalColorMixMode,m),m[2]=254&m[2]|+l.castShadows,c.setData(s[e],0,m[0],m[1],m[2],m[3]),C||=e>0&&M!==h[0],M=h[0],_||=0!==l.elevationOffset,_&&null==b&&(b=new Array(e).fill(0)),null!=b&&(b[e]=l.elevationOffset),y=Math.min(y,l.elevationOffset),v=Math.max(v,l.elevationOffset),A.encodeElevationOffset(l.elevationOffset,m),c.setData(s[e],1,m[0],m[1],m[2],m[3]);const n=l.objectAndLayerIdColor;null!=n&&c.setData(s[e],2,n[0],n[1],n[2],n[3]),l.pickable!==S.getVisibility(o.pickability,e)&&S.updatePickabilityWithCount(o,e,l.pickable)}o.verticalOffsets=_?b:null,n.offsetObb=_?p.computeOffsetObb(n.obb,y,v,this._viewingMode,n.offsetObb??n.obb.clone()):null,C||_||R.olidEnabled()?(r.componentParameters=new x.ComponentParametersVarying,r.componentParameters.castShadows=T(u,o.count),r.componentParameters.transparent=T(f,o.count),r.componentParameters.opaqueOverride=T(d,o.count),r.componentParameters.texture=c,c.updateTexture()):(r.componentParameters=new x.ComponentParametersUniform,r.componentParameters.castShadows=l.castShadows?x.ComponentParameterSummary.All:x.ComponentParameterSummary.None,r.componentParameters.externalColor=l.externalColor,r.componentParameters.externalColorMixMode=l.externalColorMixMode),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,n,i=!1){e.intersectionGeometry.getComponentAabb(t,n);const o=e,r=o.componentData.verticalOffsets;if(i||null==r)return n;const a=r[t];if(this._viewingMode===f.ViewingMode.Local||0===a)return n[2]+=a,n[5]+=a,n;const s=E.getVerticalOffsetI3S(a);return s.localOrigin=o.transform.position,s.applyToAabb(n)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,n){return e.intersectionGeometry.getComponentPositions(t,n)}expandRangeWithComponentObjectElevationRange(e,t,n,i){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||i.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const o=e,r=o.componentData,a=r.count,s=r.verticalOffsets,l=o.intersectionGeometry,c=this._viewingMode===f.ViewingMode.Local,m=l.getComponentAabbs(),h=N;let g=1/0,p=-1/0;for(let e=0;e<a;e++){const r=6*e,a=s?.[e]??0;let l=1/0,f=-1/0;if(c)l=m[r+2]+a+t,f=m[r+5]+a+t;else{if(h[0]=m[r],h[1]=m[r+1],h[2]=m[r+2],h[3]=m[r+3],h[4]=m[r+4],h[5]=m[r+5],0!==a){const e=E.getVerticalOffsetI3S(a);e.localOrigin=o.transform.position,e.applyToAabb(h)}const e=Math.max(Math.abs(h[3]),Math.abs(h[0])),s=Math.max(Math.abs(h[4]),Math.abs(h[1])),l=t+h[5]+n;i.expandElevationRangeValues(t+h[2],Math.sqrt(e*e+s*s+l*l)-n)}i.expandElevationRangeValues(l,f),g=Math.min(g,l),p=Math.max(p,f)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=g,this._elevationRangeCacheMax=p}intersect(e,t,n,i,o,r,a){const s=e,{transform:l,componentData:c,intersectionGeometry:m}=s;return null!=o&&(o.localOrigin=l.position),m.intersect(t,n,i,o,c.verticalOffsets,l,r,a)}addEdges(e,t,n,i,o){const r=e,{indices:a,positions:s}=r.intersectionGeometry,l=r.componentData.offsets;return t.addComponentObject(r,s,a,l,n,i,o)}async extractEdgeInformation(t,n,i){const o=t,r=o.componentData.visibility;if(r.allInvisible()){const{extractComponentsEdgeLocationsLayout:t}=await new Promise(((t,n)=>e(["../../lib/edgeRendering/edgeProcessing"],t,n)));return{buffer:t.createBuffer(0),origin:[0,0,0]}}const{indices:a,positions:l}=o.intersectionGeometry,c=o.componentData.offsets,{EdgeInputBufferLayout:f}=await new Promise(((t,n)=>e(["../../lib/edgeRendering/bufferLayouts"],t,n))),g=f.createBuffer(l.length/3);h.copy(g.position.typedBuffer,l,g.position.typedBufferStride,3),m.transformMat3View(g.position,g.position,o.transform.rotationScale),this._setComponentIndices(g.componentIndex,a,c);const p=g.count,d=this._computeVisibilityIndices(a,r,c,p);return{origin:s.clone(o.transform.position),buffer:await n.extractComponentsEdgeLocations({indices:d,indicesLength:d.length,skipDeduplicate:!0,data:g,writerSettings:{reducedPrecision:!1,variants:0}},i)}}_setComponentIndices(e,t,n){let i=0;for(let o=0;o<n.length-1;o++){const r=n[o],a=n[o+1];for(let n=r;n<a;n++){const o=t?t[n]:n;e.set(o,i)}i++}}_computeVisibilityIndices(e,t,n,i){if(e&&t.allVisible())return e;let o=0;t.forEachComponentRange(((e,t)=>(o+=n[t]-n[e],!0)));const a=r.isTypedArray(e)?2===e?.BYTES_PER_ELEMENT||i<=65536?new Uint16Array(o):new Uint32Array(o):new Array(o);let s=0;return t.forEachComponentRange(((t,i)=>{const o=n[t],r=n[i];for(let t=o;t<r;t++)a[s++]=e?e[t]:t;return!0})),a}addComponentHighlight(e,t,n){const o=e.componentData,r=i.getOrCreateMapValue(o.componentHighlights,n,(()=>new Uint32Array(o.count+1)));{const e=this._activeHighlightOptions.get(n)??0;this._activeHighlightOptions.set(n,e+1)}0===r[t]++&&(o.markHighlightsDirty(),this._notifyDirty()),r[o.count]++}removeComponentHighlight(e,t,n){const{componentData:i}=e,o=i.componentHighlights.get(n);if(void 0===o)return void H().warn("Removing non-existing highlight.");const r=o[t];if(0===r)return void H().warn("Removing non-existing highlight.");this._removeActiveHighlight(n);const a=o[i.count];if(r>1)return o[t]=r-1,void(o[i.count]=a-1);o[t]=0,1===a?i.componentHighlights.delete(n):o[i.count]=a-1,i.markHighlightsDirty(),this._notifyDirty()}_removeActiveHighlight(e,t=1){const n=this._activeHighlightOptions.get(e);if(void 0===n)H().warn("Removing non-existing highlight.");else{const i=n-t;i<0&&H().warn("Removing non-existing highlight."),i<=0?this._activeHighlightOptions.delete(e):this._activeHighlightOptions.set(e,i)}}clearHighlights(e){const{componentData:t}=e,{componentHighlights:n}=t;if(n.size>0){for(const e of n)this._removeActiveHighlight(e[0],e[1][t.count]);n.clear(),t.markHighlightsDirty(),this._notifyDirty()}}hasHighlight(e){return this._activeHighlightOptions.has(e)}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const n=this._renderManager.rctx,i=e.geometry,o=i.vertices.layoutParameters,r=U.BufferObject.createVertex(n,B.Usage.STATIC_DRAW,i.vertices.data),a=i.indices?U.BufferObject.createIndex(n,B.Usage.STATIC_DRAW,i.indices):null,s=d.glLayout(O.createVertexBufferLayout(o)),l=new Uint16Array(i.vertices.count);for(let e=0;e<t.count;e++){const n=t.offsets[e],o=t.offsets[e+1],r=t.materialDataIndices[e];if(null!=i.indices)for(let e=n;e<o;e++)l[i.indices[e]]=r;else for(let e=n;e<o;e++)l[e]=r}const c=U.BufferObject.createVertex(n,B.Usage.STATIC_DRAW,l.buffer),m=new x.ComponentMaterial(e.transform,e.toMapSpace),h=new j.VertexArrayObject(n,D.vertexAttributeLocations,new Map([["data",s],["componentIndices",L]]),new Map([["data",r],["componentIndices",c]]),a),f=new _.RenderGeometry(h,B.PrimitiveType.TRIANGLES,o,null!=a),g={cameraDepthSquared:.5,gpuMemoryEstimate:r.usedMemory+c.usedMemory+(null!=a?a.usedMemory:0)};return new C.Renderable(m,f,g)}_notifyDirty(){this._renderManager.notifyDirty()}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));