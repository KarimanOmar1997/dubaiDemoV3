// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/tslib.es6","../../../../core/maybe","../../../../core/accessorSupport/decorators/property","../../../../core/has","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../webgl","../../webgl/RenderNode","../core/FBOCacheFormats","./basicInterfaces","./DefaultVertexAttributeLocations","../../../support/Scheduler","../../../support/Yield","../../../webgl/enums","../../../webgl/renderState","../../../webgl/Sync","../../../webgl/Texture","../../../webgl/TextureDescriptor"],(function(e,t,i,r,o,s,n,h,a,u,c,l,p,_,d,f,g,m,x,y,P,v,T,b){"use strict";e.GPUPointOcclusionQuery=class extends _{constructor(e){super(e),this.category=p.RenderCategory.COMPOSITE,this.running=!1,this.done=!0,this._origin=l.create(),this._textureWidth=256,this._uploadBuffer=new Float32Array(3*this._textureWidth),this._counter=0,this._width=0,this._height=0,this._pipeline=P.makePipelineState({colorWrite:P.defaultColorWrite}),this._format=0}initialize(){this.view.resourceController.scheduler.registerTask(m.TaskPriority.GRAPHICS_CORE,this),this.produces="disabled",this.consumes.required=[this.category],this.formatOverride&&(this._format=this.formatOverride)}destroy(){this._program=i.disposeMaybe(this._program);const e=this.gl;this._sync=i.destroyMaybe(this._sync),this._pixelBuffer&&(e.deleteBuffer(this._pixelBuffer),this._pixelBuffer=null),this._texture=i.disposeMaybe(this._texture)}precompile(){this._ensureShader(this.renderingContext)}render(e){const t=e.find((({name:e})=>e===this.category));if(this._sync)return t;this.produces="disabled";const i=this.renderingContext,r=this.gl,o=t.getTexture(r.DEPTH_STENCIL_ATTACHMENT);if(!o)return t;const s=this.view.stage.renderer.fboCache.acquire(this._width,this._height,"hud visibility",d.ColorFormat.R32FLOAT);i.bindFramebuffer(s.fbo),i.setPipelineState(this._pipeline);const n=this._ensureShader(i);return i.useProgram(n),i.bindTexture(o,0),n.setUniform1i("depthTex",0),i.bindTexture(this._texture,1),n.setUniform1i("positionTex",1),a.multiply(C,this.camera.viewMatrix,a.fromTranslation(C,this._origin)),n.setUniformMatrix4fv("view",C),n.setUniformMatrix4fv("proj",this.camera.projectionMatrix),n.setUniform1i("count",this._counter),i.screen.draw(),this._pixelBuffer||(this._pixelBuffer=r.createBuffer()),0===this._format&&(this._format=r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)===y.PixelFormat.RED&&r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE)===y.DataType.FLOAT?y.PixelFormat.RED:y.PixelFormat.RGBA),r.bindBuffer(r.PIXEL_PACK_BUFFER,this._pixelBuffer),r.bufferData(r.PIXEL_PACK_BUFFER,this._width*this._height*(this._format===y.PixelFormat.RED?4:16),r.STREAM_READ),r.readPixels(0,0,this._width,this._height,this._format,y.DataType.FLOAT,0),this._sync=new v.Sync(r),s.release(),setTimeout((()=>this.running=!0),0),t}runTask(){if(!this._sync)return void(this.running=!1);try{if(!this._sync.poll())return x.Yield}catch(e){return this.running=!1,void(this._sync=i.destroyMaybe(this._sync))}this.running=!1,this._sync=i.destroyMaybe(this._sync);const e=this.gl;e.bindBuffer(e.PIXEL_PACK_BUFFER,this._pixelBuffer),this._cpuBuffer=new Float32Array(this._width*this._height*(this._format===y.PixelFormat.RED?1:4)),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,this._cpuBuffer),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),this.done=!0}init(e,t){const i=this._textureWidth;if(this._width=i,this._height=Math.ceil(e/i),this._counter=0,this._texture?.dispose(),0===this._height)return;const r=new b.TextureDescriptor(this._width,this._height);r.pixelFormat=y.PixelFormat.RGB,r.dataType=y.PixelType.FLOAT,r.samplingMode=y.TextureSamplingMode.NEAREST,this._texture=new T.Texture(this.renderingContext,r),this.done=!1,c.set(this._origin,Math.fround(t[0]),Math.fround(t[1]),Math.fround(t[2]))}addPosition(e){const t=this._width;if(this._counter>=t*this._height)return-1;const i=this._counter%t;return c.sub(F,e,this._origin),this._uploadBuffer[3*i+0]=F[0],this._uploadBuffer[3*i+1]=F[1],this._uploadBuffer[3*i+2]=F[2],i===t-1&&this._flush(),this._counter++}start(){if(0===this._width||0===this._height)return;const e=this._width;this._counter%e>0&&this._flush(),this.produces=this.category,this.requestRender(f.RenderRequestType.UPDATE)}getOcclusion(e){return this._cpuBuffer?.[this._format===y.PixelFormat.RED?e:4*e]??-1}_flush(){const e=this._width,t=Math.floor(this._counter/e);this._texture?.updateData(0,0,t,e,1,this._uploadBuffer)}_ensureShader(e){return null!=this._program||(this._program=e.programCache.acquire(w,E,g.Default3D)),this._program}},t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"category",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"formatOverride",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"running",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"done",void 0),e.GPUPointOcclusionQuery=t.__decorate([h.subclass("esri.views.3d.webgl-engine.lib.GPUPointOcclusionQuery")],e.GPUPointOcclusionQuery);const w="#version 300 es\nprecision highp float;\nin vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}",E="#version 300 es\nprecision highp float;\nout highp vec4 fragColor;\n\nuniform highp mat4 proj;\nuniform highp mat4 view;\n\nuniform highp int count;\n\nuniform highp sampler2D depthTex;\nuniform highp sampler2D positionTex;\n\nfloat linearizeDepth(float depth) {\n  float depthNdc = depth * 2.0 - 1.0;\n  float c1 = proj[3][2];\n  float c2 = proj[2][2];\n  return -c1 / (depthNdc + c2 + 1e-7);\n}\n\nvoid main() {\n  int u = int(floor(gl_FragCoord.x));\n  int v = int(floor(gl_FragCoord.y));\n  if (u + v * textureSize(positionTex, 0).x >= count) {\n    fragColor = vec4(-1);\n    return;\n  }\n  vec4 posWorld = vec4(texelFetch(positionTex, ivec2(u, v), 0).rgb, 1.0);\n\n  vec4 posView = view * posWorld;\n  vec4 projected = proj * posView;\n\n  vec3 clipPos = projected.xyz / projected.w;\n\n  if (clipPos.x < -1.0 || clipPos.x > 1.0 || clipPos.y < -1.0 || clipPos.y > 1.0) {\n    fragColor = vec4(-1);\n    return;\n  }\n\n  vec3 uvDepth = 0.5 * clipPos + vec3(0.5);\n\n  float depth = texture(depthTex, uvDepth.xy).r;\n\n  if (uvDepth.z <= depth) {\n    fragColor = vec4(0);\n    return;\n  }\n\n  fragColor = vec4(linearizeDepth(depth) - linearizeDepth(uvDepth.z));\n}\n",F=l.create(),C=u.create();Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));