// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/DoubleArray","../../../../geometry/support/FloatArray","../../../../geometry/support/Indices","../../../../geometry/support/plane","../../../../geometry/support/ray","./Attribute","./BufferVectorMath","./Geometry","./Util","./VertexAttribute","./IntersectableGeometry"],(function(t,e,r,n,o,a,s,u,l,c,i,h,A,f,b){"use strict";const y=i.Vec3Compact,p=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],m=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],w=[0,0,1,0,1,1,0,1],V=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],g=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)g[6*t+e]=t;const O=new Array(36);for(let t=0;t<6;t++)O[6*t]=0,O[6*t+1]=1,O[6*t+2]=2,O[6*t+3]=2,O[6*t+4]=3,O[6*t+5]=0;const d=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],x=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],I=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],M=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7],P=r.fromValues(-.5,0,-.5),G=r.fromValues(.5,0,-.5),N=r.fromValues(0,0,.5),T=r.fromValues(0,.5,0),S=r.create(),F=r.create(),R=r.create(),L=r.create(),z=r.create();e.subtract(S,P,T),e.subtract(F,P,G),e.cross(R,S,F),e.normalize(R,R),e.subtract(S,G,T),e.subtract(F,G,N),e.cross(L,S,F),e.normalize(L,L),e.subtract(S,N,T),e.subtract(F,N,P),e.cross(z,S,F),e.normalize(z,z);const C=[P,G,N,T],E=[0,-1,0,R[0],R[1],R[2],L[0],L[1],L[2],z[0],z[1],z[2]],D=[0,1,2,3,1,0,3,2,1,3,0,2],U=[0,0,0,1,1,1,2,2,2,3,3,3];function v(t,e,r){const n=t;let o,s;if(r)o=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],s=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const t=n*(1+Math.sqrt(5))/2;o=[-n,t,0,n,t,0,-n,-t,0,n,-t,0,0,-n,t,0,n,t,0,-n,-t,0,n,-t,t,0,-n,t,0,n,-t,0,-n,-t,0,n],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let e=0;e<o.length;e+=3)y.scale(o,e,t/y.length(o,e));let u={};function l(e,r){e>r&&([e,r]=[r,e]);const n=e.toString()+"."+r.toString();if(u[n])return u[n];let a=o.length;return o.length+=3,y.add(o,3*e,o,3*r,o,a),y.scale(o,a,t/y.length(o,a)),a/=3,u[n]=a,a}for(let t=0;t<e;t++){const t=s.length,e=new Array(4*t);for(let r=0;r<t;r+=3){const t=s[r],n=s[r+1],o=s[r+2],a=l(t,n),u=l(n,o),c=l(o,t),i=4*r;e[i]=t,e[i+1]=a,e[i+2]=c,e[i+3]=n,e[i+4]=u,e[i+5]=a,e[i+6]=o,e[i+7]=c,e[i+8]=u,e[i+9]=a,e[i+10]=u,e[i+11]=c}s=e,u={}}const i=a.floatArrayFrom(o);for(let t=0;t<i.length;t+=3)y.normalize(i,t);return[[f.VertexAttribute.POSITION,new c.Attribute(a.floatArrayFrom(o),s,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(i,s,3,!0)]]}const B=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function k(t,e,n,o,s=!0,u=!0){let l=0;const i=e,h=t;let A=r.fromValues(0,l,0),b=r.fromValues(0,l+h,0),y=r.fromValues(0,-1,0),p=r.fromValues(0,1,0);o&&(l=h,b=r.fromValues(0,0,0),A=r.fromValues(0,l,0),y=r.fromValues(0,1,0),p=r.fromValues(0,-1,0));const m=[b,A],w=[y,p],V=n+2,g=Math.sqrt(h*h+i*i);if(o)for(let t=n-1;t>=0;t--){const e=t*(2*Math.PI/n),o=r.fromValues(Math.cos(e)*i,l,Math.sin(e)*i);m.push(o);const a=r.fromValues(h*Math.cos(e)/g,-i/g,h*Math.sin(e)/g);w.push(a)}else for(let t=0;t<n;t++){const e=t*(2*Math.PI/n),o=r.fromValues(Math.cos(e)*i,l,Math.sin(e)*i);m.push(o);const a=r.fromValues(h*Math.cos(e)/g,i/g,h*Math.sin(e)/g);w.push(a)}const O=new Array,d=new Array;if(s){for(let t=3;t<m.length;t++)O.push(1),O.push(t-1),O.push(t),d.push(0),d.push(0),d.push(0);O.push(m.length-1),O.push(2),O.push(1),d.push(0),d.push(0),d.push(0)}if(u){for(let t=3;t<m.length;t++)O.push(t),O.push(t-1),O.push(0),d.push(t),d.push(t-1),d.push(1);O.push(0),O.push(2),O.push(m.length-1),d.push(1),d.push(2),d.push(w.length-1)}const x=a.newFloatArray(3*V);for(let t=0;t<V;t++)x[3*t]=m[t][0],x[3*t+1]=m[t][1],x[3*t+2]=m[t][2];const I=a.newFloatArray(3*V);for(let t=0;t<V;t++)I[3*t]=w[t][0],I[3*t+1]=w[t][1],I[3*t+2]=w[t][2];return[[f.VertexAttribute.POSITION,new c.Attribute(x,O,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(I,d,3,!0)]]}function q(t,o,s,i,A,b,y=r.fromValues(0,0,0)){const p=o.length,m=a.newFloatArray(s.length*p*3+(6*i.length||0)),w=a.newFloatArray(s.length*p*3+(i?6:0)),V=new Array,g=new Array;let O=0,d=0;const x=n.create(),I=n.create(),M=n.create(),P=n.create(),G=n.create(),N=n.create(),T=n.create(),S=n.create(),F=n.create(),R=n.create(),L=n.create(),z=n.create(),C=n.create(),E=u.create();e.set(F,0,1,0),e.subtract(I,s[1],s[0]),e.normalize(I,I),b?(e.add(S,s[0],y),e.normalize(M,S)):e.set(M,0,0,1),j(I,M,F,F,G,M,H),e.copy(P,M),e.copy(z,G);for(let t=0;t<i.length;t++)e.scale(N,G,i[t][0]),e.scale(S,M,i[t][2]),e.add(N,N,S),e.add(N,N,s[0]),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2];w[d++]=-I[0],w[d++]=-I[1],w[d++]=-I[2];for(let t=0;t<A.length;t++)V.push(A[t][0]>0?A[t][0]:-A[t][0]-1+i.length),V.push(A[t][1]>0?A[t][1]:-A[t][1]-1+i.length),V.push(A[t][2]>0?A[t][2]:-A[t][2]-1+i.length),g.push(0),g.push(0),g.push(0);let D=i.length;const U=i.length-1;for(let t=0;t<s.length;t++){let r=!1;t>0&&(e.copy(x,I),t<s.length-1?(e.subtract(I,s[t+1],s[t]),e.normalize(I,I)):r=!0,e.add(R,x,I),e.normalize(R,R),e.add(L,s[t-1],P),u.fromPositionAndNormal(s[t],R,E),u.intersectRay(E,l.wrap(L,x),S)?(e.subtract(S,S,s[t]),e.normalize(M,S),e.cross(G,R,M),e.normalize(G,G)):j(R,P,z,F,G,M,H),e.copy(P,M),e.copy(z,G)),b&&(e.add(S,s[t],y),e.normalize(C,S));for(let n=0;n<p;n++)if(e.scale(N,G,o[n][0]),e.scale(S,M,o[n][1]),e.add(N,N,S),e.normalize(T,N),w[d++]=T[0],w[d++]=T[1],w[d++]=T[2],e.add(N,N,s[t]),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2],!r){const t=(n+1)%p;V.push(D+n),V.push(D+p+n),V.push(D+t),V.push(D+t),V.push(D+p+n),V.push(D+p+t);for(let t=0;t<6;t++){const e=V.length-6;g.push(V[e+t]-U)}}D+=p}const v=s[s.length-1];for(let t=0;t<i.length;t++)e.scale(N,G,i[t][0]),e.scale(S,M,i[t][1]),e.add(N,N,S),e.add(N,N,v),m[O++]=N[0],m[O++]=N[1],m[O++]=N[2];const B=d/3;w[d++]=I[0],w[d++]=I[1],w[d++]=I[2];const k=D-p;for(let t=0;t<A.length;t++)V.push(A[t][0]>=0?D+A[t][0]:-A[t][0]-1+k),V.push(A[t][2]>=0?D+A[t][2]:-A[t][2]-1+k),V.push(A[t][1]>=0?D+A[t][1]:-A[t][1]-1+k),g.push(B),g.push(B),g.push(B);const q=[[f.VertexAttribute.POSITION,new c.Attribute(m,V,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(w,g,3,!0)]];return new h.Geometry(t,q)}function Z(t,r,n,o,a){return!(Math.abs(e.dot(r,t))>a||(e.cross(n,t,r),e.normalize(n,n),e.cross(o,n,t),e.normalize(o,o),0))}function j(t,e,r,n,o,a,s){return Z(t,e,o,a,s)||Z(t,r,o,a,s)||Z(t,n,o,a,s)}const H=.99619469809,J=n.create();t.cgToGIS=function(t,e=t){const r=t.attributes,n=r.get(f.VertexAttribute.POSITION).data,o=r.get(f.VertexAttribute.NORMAL).data;if(o){const t=e.getMutableAttribute(f.VertexAttribute.NORMAL).data;for(let e=0;e<o.length;e+=3){const r=o[e+1];t[e+1]=-o[e+2],t[e+2]=r}}if(n){const t=e.getMutableAttribute(f.VertexAttribute.POSITION).data;for(let e=0;e<n.length;e+=3){const r=n[e+1];t[e+1]=-n[e+2],t[e+2]=r}}},t.createBoxGeometry=function(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let t=0;t<8;t++)r[3*t]=p[t][0]*e[0],r[3*t+1]=p[t][1]*e[1],r[3*t+2]=p[t][2]*e[2];return new h.Geometry(t,[[f.VertexAttribute.POSITION,new c.Attribute(r,V,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(m,g,3)],[f.VertexAttribute.UV0,new c.Attribute(w,O,2)]])},t.createConeGeometry=function(t,e,r,n,o,a=!0,s=!0){return new h.Geometry(t,k(e,r,n,o,a,s))},t.createConeGeometryData=k,t.createCylinderGeometry=function(t,n,o,s,u,l,i){const A=u?r.clone(u):r.fromValues(1,0,0),b=l?r.clone(l):r.fromValues(0,0,0);i??=!0;const y=r.create();e.normalize(y,A);const p=r.create();e.scale(p,y,Math.abs(n));const m=r.create();e.scale(m,p,-.5),e.add(m,m,b);const w=r.fromValues(0,1,0);Math.abs(1-e.dot(y,w))<.2&&e.set(w,0,0,1);const V=r.create();e.cross(V,y,w),e.normalize(V,V),e.cross(w,V,y);const g=2*s+(i?2:0),O=s+(i?2:0),d=a.newFloatArray(3*g),x=a.newFloatArray(3*O),I=a.newFloatArray(2*g),M=new Array(3*s*(i?4:2)),P=new Array(3*s*(i?4:2));i&&(d[3*(g-2)]=m[0],d[3*(g-2)+1]=m[1],d[3*(g-2)+2]=m[2],I[2*(g-2)]=0,I[2*(g-2)+1]=0,d[3*(g-1)]=d[3*(g-2)]+p[0],d[3*(g-1)+1]=d[3*(g-2)+1]+p[1],d[3*(g-1)+2]=d[3*(g-2)+2]+p[2],I[2*(g-1)]=1,I[2*(g-1)+1]=1,x[3*(O-2)]=-y[0],x[3*(O-2)+1]=-y[1],x[3*(O-2)+2]=-y[2],x[3*(O-1)]=y[0],x[3*(O-1)+1]=y[1],x[3*(O-1)+2]=y[2]);const G=(t,e,r)=>{M[t]=e,P[t]=r};let N=0;const T=r.create(),S=r.create();for(let t=0;t<s;t++){const r=t*(2*Math.PI/s);e.scale(T,w,Math.sin(r)),e.scale(S,V,Math.cos(r)),e.add(T,T,S),x[3*t]=T[0],x[3*t+1]=T[1],x[3*t+2]=T[2],e.scale(T,T,o),e.add(T,T,m),d[3*t]=T[0],d[3*t+1]=T[1],d[3*t+2]=T[2],I[2*t]=t/s,I[2*t+1]=0,d[3*(t+s)]=d[3*t]+p[0],d[3*(t+s)+1]=d[3*t+1]+p[1],d[3*(t+s)+2]=d[3*t+2]+p[2],I[2*(t+s)]=t/s,I[2*t+1]=1;const n=(t+1)%s;G(N++,t,t),G(N++,t+s,t),G(N++,n,n),G(N++,n,n),G(N++,t+s,t),G(N++,n+s,n)}if(i){for(let t=0;t<s;t++){const e=(t+1)%s;G(N++,g-2,O-2),G(N++,t,O-2),G(N++,e,O-2)}for(let t=0;t<s;t++){const e=(t+1)%s;G(N++,t+s,O-1),G(N++,g-1,O-1),G(N++,e+s,O-1)}}const F=[[f.VertexAttribute.POSITION,new c.Attribute(d,M,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(x,P,3,!0)],[f.VertexAttribute.UV0,new c.Attribute(I,M,2,!0)]];return new h.Geometry(t,F)},t.createDiamondGeometry=function(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let t=0;t<6;t++)r[3*t]=d[t][0]*e[0],r[3*t+1]=d[t][1]*e[1],r[3*t+2]=d[t][2]*e[2];return new h.Geometry(t,[[f.VertexAttribute.POSITION,new c.Attribute(r,I,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(x,M,3)]])},t.createExtrudedTriangle=function(t,e,r,n,o,a=0){const s=new Array(18),u=[[-r,a,o/2],[n,a,o/2],[0,e+a,o/2],[-r,a,-o/2],[n,a,-o/2],[0,e+a,-o/2]];for(let t=0;t<6;t++)s[3*t]=u[t][0],s[3*t+1]=u[t][1],s[3*t+2]=u[t][2];return new h.Geometry(t,[[f.VertexAttribute.POSITION,new c.Attribute(s,[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5],3,!0)]])},t.createPathExtrusionGeometry=q,t.createPointGeometry=function(t,{normal:e,position:r,color:o,rotation:a,size:u,centerOffsetAndDistance:l,uvi:i,featureAttribute:A,objectAndLayerIdColor:y=null}={}){const p=r?n.clone(r):n.create(),m=e?n.clone(e):n.fromValues(0,0,1),w=o?[255*o[0],255*o[1],255*o[2],o.length>3?255*o[3]:255]:[255,255,255,255],V=null!=u&&2===u.length?u:[1,1],g=null!=a?[a]:[0],O=s.getZeroIndexArray(1),d=[[f.VertexAttribute.POSITION,new c.Attribute(p,O,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(m,O,3,!0)],[f.VertexAttribute.COLOR,new c.Attribute(w,O,4,!0)],[f.VertexAttribute.SIZE,new c.Attribute(V,O,2)],[f.VertexAttribute.ROTATION,new c.Attribute(g,O,1,!0)]];if(i&&d.push([f.VertexAttribute.UVI,new c.Attribute(i,O,i.length)]),null!=l){const t=[l[0],l[1],l[2],l[3]];d.push([f.VertexAttribute.CENTEROFFSETANDDISTANCE,new c.Attribute(t,O,4)])}if(A){const t=[A[0],A[1],A[2],A[3]];d.push([f.VertexAttribute.FEATUREATTRIBUTE,new c.Attribute(t,O,4)])}return new h.Geometry(t,d,null,b.GeometryType.Point,y)},t.createPolySphereData=v,t.createPolySphereGeometry=function(t,e,r,n){const o=v(e,r,n);return new h.Geometry(t,o)},t.createPolylineGeometry=function(t,e,r,n){A.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),A.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),A.assert(null==r||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),A.assert(null==r||3===r[0].length,"createPolylineGeometry(): malformed normal");const u=o.newDoubleArray(3*e.length),l=new Array(2*(e.length-1));let i=0,y=0;for(let t=0;t<e.length;t++){for(let r=0;r<3;r++)u[i++]=e[t][r];t>0&&(l[y++]=t-1,l[y++]=t)}const p=[[f.VertexAttribute.POSITION,new c.Attribute(u,l,3,!0)]];if(r){const t=a.newFloatArray(3*r.length);let n=0;for(let o=0;o<e.length;o++)for(let e=0;e<3;e++)t[n++]=r[o][e];p.push([f.VertexAttribute.NORMAL,new c.Attribute(t,l,3,!0)])}return n&&p.push([f.VertexAttribute.COLOR,new c.Attribute(n,s.getContinuousIndexArray(n.length/4),4)]),new h.Geometry(t,p,null,b.GeometryType.Line)},t.createSphereGeometry=function(t,e,r,n,o={uv:!0}){const u=-Math.PI,l=2*Math.PI,i=-Math.PI/2,A=Math.PI,b=Math.max(3,Math.floor(r)),y=Math.max(2,Math.floor(n)),p=(b+1)*(y+1),m=a.newFloatArray(3*p),w=a.newFloatArray(3*p),V=a.newFloatArray(2*p),g=[];let O=0;for(let t=0;t<=y;t++){const r=[],n=t/y,o=i+n*A,a=Math.cos(o);for(let t=0;t<=b;t++){const s=t/b,c=u+s*l,i=Math.cos(c)*a,h=Math.sin(o),A=-Math.sin(c)*a;m[3*O]=i*e,m[3*O+1]=h*e,m[3*O+2]=A*e,w[3*O]=i,w[3*O+1]=h,w[3*O+2]=A,V[2*O]=s,V[2*O+1]=n,r.push(O),++O}g.push(r)}const d=new Array;for(let t=0;t<y;t++)for(let e=0;e<b;e++){const r=g[t][e],n=g[t][e+1],o=g[t+1][e+1],a=g[t+1][e];0===t?(d.push(r),d.push(o),d.push(a)):t===y-1?(d.push(r),d.push(n),d.push(o)):(d.push(r),d.push(n),d.push(o),d.push(o),d.push(a),d.push(r))}const x=[[f.VertexAttribute.POSITION,new c.Attribute(m,d,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(w,d,3,!0)]];return o.uv&&x.push([f.VertexAttribute.UV0,new c.Attribute(V,d,2,!0)]),o.offset&&(x[0][0]=f.VertexAttribute.OFFSET,x.push([f.VertexAttribute.POSITION,new c.Attribute(Float64Array.from(o.offset),s.getZeroIndexArray(d.length),3,!0)])),new h.Geometry(t,x)},t.createSquareGeometry=function(t,e=B){const r=new Array(12);for(let t=0;t<4;t++)for(let n=0;n<3;n++)r[3*t+n]=e[t][n];const n=[0,1,2,2,3,0],o=[0,0,0,0,0,0],a=[[f.VertexAttribute.POSITION,new c.Attribute(r,n,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute([0,0,1],o,3,!0)],[f.VertexAttribute.UV0,new c.Attribute([0,0,1,0,1,1,0,1],n,2,!0)],[f.VertexAttribute.COLOR,new c.Attribute([255,255,255,255],o,4,!0)]];return new h.Geometry(t,a)},t.createTetrahedronGeometry=function(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let t=0;t<4;t++)r[3*t]=C[t][0]*e[0],r[3*t+1]=C[t][1]*e[1],r[3*t+2]=C[t][2]*e[2];return new h.Geometry(t,[[f.VertexAttribute.POSITION,new c.Attribute(r,D,3,!0)],[f.VertexAttribute.NORMAL,new c.Attribute(E,U,3)]])},t.createTubeGeometry=function(t,e,r,n,o,a){n=n||10,o=null==o||o,A.assert(e.length>1);const s=[],u=[];for(let t=0;t<n;t++){s.push([0,-t-1,-(t+1)%n-1]);const e=t/n*2*Math.PI;u.push([Math.cos(e)*r,Math.sin(e)*r])}return q(t,u,e,[[0,0,0]],s,o,a)},t.makeOrthoBasisDirUpFallback=j,t.transformInPlace=function(t,r){const n=t.getMutableAttribute(f.VertexAttribute.POSITION).data;for(let t=0;t<n.length;t+=3){const o=n[t],a=n[t+1],s=n[t+2];e.set(J,o,a,s),e.transformMat4(J,J,r),n[t]=J[0],n[t+1]=J[1],n[t+2]=J[2]}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));