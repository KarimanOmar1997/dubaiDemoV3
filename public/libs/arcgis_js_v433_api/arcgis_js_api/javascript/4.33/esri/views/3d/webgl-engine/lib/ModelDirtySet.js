// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../chunks/tslib.es6","../../../../core/Accessor","../../../../core/has","../../../../core/NestedMap","../../../../core/uid","../../../../core/accessorSupport/decorators/property","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","./ModelDirtyTypes","./Util"],(function(e,t,r,o,i,s,d,a,n,c,y){"use strict";class h{constructor(e,t,r,o){this.operation=e,this.geometry=t,this.states=r,this.sync=o}}let m=class extends t{constructor(e){super(e),this._residentGeomRecords=new o.NestedMap,this._dirtyGeomRecords=new o.NestedMap,this._dirtyRecordCount=0}get dirty(){return this._dirtyRecordCount>0}commitLayer(e,t){const r=this._dirtyGeomRecords.getInner(e),o=this.model.getLayer(e);if(!r||!o)return;let i=0;r.forEach(((r,s)=>{const d=this._ensureGeomRecord(e,s);this._dirtyGeomRecords.delete(e,s),i+=r.size,r.forEach((({geometry:e,operation:r,states:i},a)=>{let n=!1;if(r===c.DirtyOperation.UPDATE){const r=d.get(a);if(r){if(i&c.DirtyState.TRANSFORMATION){const t=o.getObject(s);this.model.updateRenderGeometryTransformation(t,e,r)&&(n=!0)}n||t.updates.push({renderGeometry:r,updateType:i})}else y.assert(!1,"ModelDirtySet.commitLayer: invalid update")}if(r===c.DirtyOperation.REMOVE||n){const e=d.get(a);e?(t.removes.push(e),d.delete(a)):r===c.DirtyOperation.REMOVE&&y.assert(!1,"ModelDirtySet.commitLayer: invalid remove")}if(r===c.DirtyOperation.ADD||n){const r=o.getObject(s);if(null!=r){const o=this.model.getRenderGeometry(r,e);t.adds.push(o),d.set(a,o)}}})),0===d.size&&this._residentGeomRecords.delete(e,s)})),this._dirtyRecordCount-=i}commitSyncUpdates(e,t){const r=this._dirtyGeomRecords.getInner(e),o=this.model.getLayer(e);r&&o&&r.forEach(((r,i)=>{const s=this._ensureGeomRecord(e,i);r.forEach((({geometry:e,operation:r,states:d,sync:a},n)=>{let h=!1;if(r===c.DirtyOperation.UPDATE&&a){const r=s.get(n);if(r){if(d&c.DirtyState.TRANSFORMATION){const t=o.getObject(i);this.model.updateRenderGeometryTransformation(t,e,r)&&(h=!0)}h||t.updates.push({renderGeometry:r,updateType:d})}else y.assert(!1,"ModelDirtySet.commitSyncUpdates: invalid update")}}))}))}_objectStateChanged(e,t){for(const r of t.geometries)this._updateOrCreateDirtyRecord(t,r,c.DirtyOperation.UPDATE,e)}visibilityChanged(e){this._objectStateChanged(c.DirtyState.VISIBILITY,e)}highlightChanged(e){this._objectStateChanged(c.DirtyState.HIGHLIGHT,e)}occlusionChanged(e){this._objectStateChanged(c.DirtyState.OCCLUDEE,e)}attributesChanged({object:e,geometry:t,sync:r}){this._updateOrCreateDirtyRecord(e,t,c.DirtyOperation.UPDATE,c.DirtyState.GEOMETRY,r)}layerAdded(e){e.objects.forEach((e=>this.layerObjectAdded(e)))}layerRemoved(e){e.objects.forEach((e=>this.layerObjectRemoved(e)))}layerObjectAdded(e){for(const t of e.geometries)this._geometryAdded(e,t)}layerObjectRemoved(e){for(const t of e.geometries)this._geometryRemoved(e,t)}layerObjectsAdded(e){for(const t of e)this.layerObjectAdded(t)}layerObjectsRemoved(e){for(const t of e)this.layerObjectRemoved(t)}transformationChanged(e){const t=this._getLayerId(e),r=e.id;this._ensureGeomRecord(t,r).forEach((({geometry:t})=>this._updateOrCreateDirtyRecord(e,t,c.DirtyOperation.UPDATE,c.DirtyState.TRANSFORMATION)))}shaderTransformationChanged(e){const t=this._getLayerId(e),r=e.id;this._ensureGeomRecord(t,r).forEach((t=>t.objectShaderTransformationChanged(e.shaderTransformation)))}geometryAdded(e){this._geometryAdded(e.object,e.geometry)}_geometryAdded(e,t){this._updateOrCreateDirtyRecord(e,t,c.DirtyOperation.ADD)}geometryRemoved(e){this._geometryRemoved(e.object,e.geometry)}_geometryRemoved(e,t){this._updateOrCreateDirtyRecord(e,t,c.DirtyOperation.REMOVE)}_updateOrCreateDirtyRecord(e,t,r,o=c.DirtyState.NONE,i=!1){const s=this._getLayerId(e),d=e.id,a=t.id,n=this._ensureDirtyRecord(s,d),m=n.get(a);if(m){const e=m.operation;e===c.DirtyOperation.REMOVE&&r===c.DirtyOperation.ADD&&m.states!==c.DirtyState.NONE?m.operation=c.DirtyOperation.UPDATE:e===c.DirtyOperation.REMOVE&&r===c.DirtyOperation.ADD||e===c.DirtyOperation.ADD&&r===c.DirtyOperation.REMOVE?(n.delete(a),this._dirtyRecordCount--):e!==c.DirtyOperation.UPDATE||r!==c.DirtyOperation.REMOVE&&r!==c.DirtyOperation.UPDATE?(y.assert((e===c.DirtyOperation.REMOVE||e===c.DirtyOperation.ADD)&&r===c.DirtyOperation.UPDATE,"ModelDirtySet.objectGeometryAdded: inconsistent state"),m.states|=o):(m.operation=r,m.states|=o),m.sync=m.sync||i}else n.set(a,new h(r,t,o,i)),this._dirtyRecordCount++}_ensureGeomRecord(e,t){let r=this._residentGeomRecords.get(e,t);return r||(r=new Map,this._residentGeomRecords.set(e,t,r)),r}assertLayerClean(e){y.assert(null==this._dirtyGeomRecords.getInner(e),"Dirty geometry records for removed layer")}_ensureDirtyRecord(e,t){const r=this.model.getLayer(e);y.assert(null!=r,"Updating geometry record for an unregistered layer");let o=this._dirtyGeomRecords.get(e,t);return o||(o=new Map,this._dirtyGeomRecords.set(e,t,o)),o}_getLayerId(e){return e.layer?.id??i.nullUid}formatDebugInfo(){const e=["ADD","UPD",void 0,"REM"];let t="";return this._dirtyGeomRecords.forAll(((r,o,i)=>{t.length>0&&(t+="\n"),t+=o+"."+i;const s=[];r.forEach((e=>{const t=e.operation;s[t]||(s[t]=[]),s[t].push(e.geometry.id)}));for(let r=0;r<s.length;r++)if(s[r]){t+=" "+e[r-1]+": ";for(let e=0;e<s[r].length;e++)t+=s[r][e]+", "}})),t}get test(){}};return e.__decorate([s.property({constructOnly:!0})],m.prototype,"model",void 0),e.__decorate([s.property()],m.prototype,"_dirtyRecordCount",void 0),m=e.__decorate([n.subclass("esri.views.3d.webgl-engine.lib.ModelDirtySet")],m),m}));