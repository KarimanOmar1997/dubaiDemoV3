// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/has","../../../../core/uid","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/sphere","../../support/mathUtils","./basicInterfaces","./Object3DStateID","./Util","./VertexAttribute","../materials/renderers/utils"],(function(t,e,i,s,o,r,a,n,h,m,c,l,d,g){"use strict";class u{constructor(){this.min=a.fromValues(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=a.fromValues(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class b extends u{constructor(){super(...arguments),this.bounds=n.create()}}function f(t,e,i){const o=t.bbMin,a=t.bbMax;if(s.hasIdentityRotation(i)){const t=r.set(_,i[12],i[13],i[14]);r.add(v,o,t),r.add(p,a,t);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],v[t]),e.max[t]=Math.max(e.max[t],p[t])}else if(r.transformMat4(v,o,i),r.exactEquals(o,a))for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],v[t]),e.max[t]=Math.max(e.max[t],v[t]);else{r.transformMat4(p,a,i);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],v[t],p[t]),e.max[t]=Math.max(e.max[t],v[t],p[t]);for(let t=0;t<3;++t){r.copy(v,o),r.copy(p,a),v[t]=a[t],p[t]=o[t],r.transformMat4(v,v,i),r.transformMat4(p,p,i);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],v[t],p[t]),e.max[t]=Math.max(e.max[t],v[t],p[t])}}}const _=a.create(),v=a.create(),p=a.create(),S=a.create();var y;!function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"}(y||(y={})),t.BoundingVolume=b,t.Object3D=class{constructor(t={}){this.id=i.generateUID(),this._highlightIds=new Set,this._shaderTransformation=null,this._visible=!0,this.castShadow=t.castShadow??!0,this.usesVerticalDistanceToGround=t.usesVerticalDistanceToGround??!1,this.graphicUid=t.graphicUid,this.layerViewUid=t.layerViewUid,t.isElevationSource&&(this.lastValidElevationBB=new u),this._geometries=t.geometries?Array.from(t.geometries):new Array}dispose(){this._geometries.length=0}get layer(){return this._layer}set layer(t){l.assert(null==this._layer||null==t,"Object3D can only be added to a single Layer"),this._layer=t}addGeometry(t){t.visible=this._visible,this._geometries.push(t);for(const e of this._highlightIds)t.addHighlight(e);this._emit("geometryAdded",{object:this,geometry:t}),this._highlightIds.size&&this._emit("highlightChanged",this),this._invalidateBoundingVolume()}removeGeometry(t){const e=this._geometries.splice(t,1)[0];if(e){for(const t of this._highlightIds)e.removeHighlight(t);this._emit("geometryRemoved",{object:this,geometry:e}),this._highlightIds.size&&this._emit("highlightChanged",this),this._invalidateBoundingVolume()}}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(t,e,i=!1){this._emit("attributesChanged",{object:this,geometry:t,attribute:e,sync:i}),d.affectsGeometry(e)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometries)t.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new c.Object3DOccludeeStateID;for(const e of this._geometries)e.occludees=g.addObject3DStateID(e.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometries)e.occludees=g.removeObject3DStateID(e.occludees,t);this._emit("occlusionChanged",this)}highlight(t){const e=new c.Object3DHighlightStateID(t);for(const t of this._geometries)t.addHighlight(e);return this._emit("highlightChanged",this),this._highlightIds.add(e),e}removeHighlight(t){this._highlightIds.delete(t);for(const e of this._geometries)e.removeHighlight(t);this._emit("highlightChanged",this)}removeStateID(t){t.channel===m.Object3DState.Highlight?this.removeHighlight(t):this.removeOcclude(t)}getCombinedStaticTransformation(t,e){return s.multiply(e,this.transformation,t.transformation)}getCombinedShaderTransformation(t,e=o.create()){return s.multiply(e,this.effectiveTransformation,t.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new b,this._validateBoundingVolume(this._bvWorldSpace,y.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new b,this._validateBoundingVolume(this._bvObjectSpace,y.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(t,e){const i=e===y.ObjectSpace;for(const e of this._geometries){const s=e.boundingInfo;s&&f(s,t,i?e.transformation:this.getCombinedShaderTransformation(e))}r.lerp(n.getCenter(t.bounds),t.min,t.max,.5);for(const e of this._geometries){const s=e.boundingInfo;if(null==s)continue;const o=i?e.transformation:this.getCombinedShaderTransformation(e),a=h.maxScale(o);r.transformMat4(S,s.center,o);const m=r.distance(S,n.getCenter(t.bounds)),c=s.radius*a;t.bounds[3]=Math.max(t.bounds[3],m+c)}}_invalidateBoundingVolume(){const t=this._bvWorldSpace?.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this.layer&&t&&this.layer.notifyObjectBBChanged(this,t)}_emit(t,e){this.layer?.events.emit(t,e)}get geometries(){return this._geometries}get transformation(){return this._transformation??o.IDENTITY}set transformation(t){this._transformation=s.copy(this._transformation??o.create(),t),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(t){this._shaderTransformation=t?s.copy(this._shaderTransformation??o.create(),t):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}get test(){}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));