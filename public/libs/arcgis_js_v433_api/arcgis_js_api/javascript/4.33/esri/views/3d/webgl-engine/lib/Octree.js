// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["../../../../core/ObjectPool","../../../../core/PooledArray","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/frustum","../../../../geometry/support/ray","../../../../chunks/sphere","./Util"],(function(e,t,n,r,o,i,s,a){"use strict";class h{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(e,t){this.objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new l,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}destroy(){this._degenerateObjects.clear(),l.clearPool(),T[0]=null,B.prune(),v.prune()}add(e){const t=Array.from(e);this._grow(t);const n=l.acquire();for(const e of t)++this._objectCount,this._isDegenerate(e)?this._degenerateObjects.add(e):(n.init(this._root),this._add(e,n));l.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=l.acquire();for(const r of e){const e=t??s.copy(this.objectToBoundingSphere(r),D);S(e[3])?(n.init(this._root),c(r,e,n)):this._degenerateObjects.delete(r)}l.release(n),this._shrink()}update(e,t){if(!S(t[3])&&this._isDegenerate(e))return;const n=function(e){return T[0]=e,T}(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const r=i.wrap(e,t);d(this._root,(e=>{if(!function(e,t){return _(s.getCenter(t.bounds),2*-t.halfSize,N),_(s.getCenter(t.bounds),2*t.halfSize,M),a.rayBoxTest(e.origin,e.direction,N,M)}(r,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,n,r){const o=i.wrap(e,t);d(this._root,(e=>{if(!function(e,t,n){return _(s.getCenter(t.bounds),2*-t.halfSize,N),_(s.getCenter(t.bounds),2*t.halfSize,M),n.applyToMinMax(N,M),a.rayBoxTest(e.origin,e.direction,N,M)}(o,e,r))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(o,e,r)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(o,e,r)&&n(e)})),!0}))}forEach(e){d(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,r,i=()=>!0,a=1/0){let h=1/0,l=1/0,d=null;const c=b(e,t),f=n=>{if(--a,!i(n))return;const u=this.objectToBoundingSphere(n);if(!o.intersectsSphere(r,u))return;const c=g(e,t,s.getCenter(u)),f=c-u[3],m=c+u[3];f<h&&(h=f,l=m,d=n)};return u(this._root,(i=>{if(a<=0||!o.intersectsSphere(r,i.bounds))return!1;if(n.scale(C,c,i.halfSize),n.add(C,C,s.getCenter(i.bounds)),g(e,t,C)>l)return!1;const h=i.node;return h.terminals.forAll((e=>f(e))),null!==h.residents&&h.residents.forAll((e=>f(e))),!0}),e,t),d}forEachInDepthRange(e,t,r,i,a,l,d){let c=-1/0,f=1/0;const m={setRange:e=>{r===h.DepthOrder.FRONT_TO_BACK?(c=Math.max(c,e.near),f=Math.min(f,e.far)):(c=Math.max(c,-e.far),f=Math.min(f,-e.near))}};m.setRange(i);const _=g(t,r,e),p=b(t,r),S=b(t,-r),O=e=>{if(!d(e))return;const n=this.objectToBoundingSphere(e),i=s.getCenter(n),h=g(t,r,i)-_,u=h-n[3],p=h+n[3];u>f||p<c||!o.intersectsSphere(l,n)||a(e,m)};u(this._root,(e=>{if(!o.intersectsSphere(l,e.bounds))return!1;if(n.scale(C,p,e.halfSize),n.add(C,C,s.getCenter(e.bounds)),g(t,r,C)-_>f)return!1;if(n.scale(C,S,e.halfSize),n.add(C,C,s.getCenter(e.bounds)),g(t,r,C)-_<c)return!1;const i=e.node;return i.terminals.forAll((e=>O(e))),null!==i.residents&&i.residents.forAll((e=>O(e))),!0}),t,r)}forEachNode(e){d(this._root,(t=>e(t.node,t.bounds,t.halfSize,t.depth)))}forEachNeighbor(e,t){const r=s.getRadius(t),o=s.getCenter(t),i=t=>{const i=this.objectToBoundingSphere(t),a=s.getRadius(i),h=r+a;return!(n.squaredDistance(s.getCenter(i),o)-h*h<=0)||e(t)};let a=!0;const h=e=>{a&&(a=i(e))};d(this._root,(e=>{const t=s.getRadius(e.bounds),i=r+t;if(n.squaredDistance(s.getCenter(e.bounds),o)-i*i>0)return!1;const l=e.node;return l.terminals.forAll(h),a&&null!==l.residents&&l.residents.forAll(h),a})),a&&this.forEachDegenerateObject(h)}_intersectsObject(e,t){const n=this.objectToBoundingSphere(t);return!(n[3]>0)||s.intersectsRay(n,e)}_intersectsObjectWithOffset(e,t,n){const r=this.objectToBoundingSphere(t);return!(r[3]>0)||s.intersectsRay(n.applyToBoundingSphere(r),e)}_add(e,t){t.advanceTo(this.objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const r=l.acquire().init(e);this._add(t.at(n),r),l.release(r)}}_grow(e){if(p(e,(e=>this.objectToBoundingSphere(e)),A),S(A[3])&&!this._fitsInsideTree(A))if(f(this._root.node))s.copy(A,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(A);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(A,e):this._growRootAsSubNode(e),l.release(e)}}_rebuildTree(e,t){n.copy(s.getCenter(R),s.getCenter(t.bounds)),R[3]=t.halfSize,p([e,R],(e=>e),y);const r=l.acquire().init(this._root);this._root.initFrom(null,y,y[3]),this._root.increaseHalfSize(1.25),d(r,(e=>(this.add(e.node.terminals.data),null!==e.node.residents&&this.add(e.node.residents.data),!0))),l.release(r)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return d(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let r=-1/0;const o=this._root.bounds,i=this._root.halfSize;for(let e=0;e<3;e++){const s=o[e]-i-(n[e]-t),a=n[e]+t-(o[e]+i),h=Math.max(0,Math.ceil(s/(2*i))),l=Math.max(0,Math.ceil(a/(2*i)))+1,d=2**Math.ceil(Math.log(h+l)*Math.LOG2E);r=Math.max(r,d),F[e].min=h,F[e].max=l}for(let e=0;e<3;e++){let t=F[e].min,n=F[e].max;const s=(r-(t+n))/2;t+=Math.ceil(s),n+=Math.floor(s);const a=o[e]-i-t*i*2;z[e]=a+(n+t)*i}const s=r*i;return z[3]=s*j,l.acquire().initFrom(null,z,s,0)}_growRootAsSubNode(e){const t=this._root.node;n.copy(s.getCenter(A),s.getCenter(this._root.bounds)),A[3]=this._root.halfSize,this._root.init(e),e.advanceTo(A,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,r=0;for(;r<t.length&&null==e;)n=r++,e=t[n];for(;r<t.length;)if(t[r++])return-1;return n}_isDegenerate(e){return!S(this.objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}toJSON(){const{maximumDepth:e,maximumObjectsPerNode:t,_objectCount:n}=this,r=this._nodeToJSON(this._root.node);return{maximumDepth:e,maximumObjectsPerNode:t,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:r}}}_nodeToJSON(e){const t=e.children.map((e=>e?this._nodeToJSON(e):null)),n=e.residents?.map((e=>this.objectToBoundingSphere(e))),r=e.terminals?.map((e=>this.objectToBoundingSphere(e)));return{children:t,residents:n,terminals:r}}static fromJSON(e){const t=new h((e=>e),{maximumDepth:e.maximumDepth,maximumObjectsPerNode:e.maximumObjectsPerNode});return t._objectCount=e.objectCount,t._root.initFrom(e.root.node,e.root.bounds,e.root.halfSize,e.root.depth),t}}class l{constructor(){this.bounds=s.create(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,r=this.depth){return this.node=null!=e?e:l.createEmptyNode(),t&&s.copy(t,this.bounds),this.halfSize=n,this.depth=r,this}increaseHalfSize(e){this.halfSize*=e,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*j}advance(e){let t=this.node.children[e];t||(t=l.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=O[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const r=this._childIndex(e);t&&t(this,r),this.advance(r)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new t({shrink:!0}),residents:new t({shrink:!0})}}static{this._pool=new e(l)}static acquire(){return l._pool.acquire()}static release(e){l._pool.release(e)}static clearPool(){l._pool.prune()}}function d(e,t){let n=l.acquire().init(e);const r=[n];for(;0!==r.length;){if(n=r.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++)n.node.children[e]&&r.push(l.acquire().init(n).advance(e));l.release(n)}}function u(e,t,n,r=h.DepthOrder.FRONT_TO_BACK){let o=l.acquire().init(e);const i=[o];for(function(e,t,n){if(!v.length)for(let e=0;e<8;++e)v.push({index:0,distance:0});for(let n=0;n<8;++n){const r=O[n];v.data[n].index=n,v.data[n].distance=g(e,t,r)}v.sort(((e,t)=>e.distance-t.distance));for(let e=0;e<8;++e)n[e]=v.data[e].index}(n,r,V);0!==i.length;){if(o=i.pop(),t(o)&&!o.isLeaf())for(let e=7;e>=0;--e){const t=V[e];o.node.children[t]&&i.push(l.acquire().init(o).advance(t))}l.release(o)}}function c(e,n,r){B.clear();const o=r.advanceTo(n,((e,t)=>{B.push(e.node),B.push(t)}))?r.node.terminals:r.node.residents;if(o.removeUnordered(e),0===o.length)for(let e=B.length-2;e>=0&&(i=B.data[e],(s=B.data[e+1])>=0&&(i.children[s]=null),f(i)&&(null===i.residents&&(i.residents=new t({shrink:!0})),1));e-=2);var i,s}function f(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}function m(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function _(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function p(e,t,r){N[0]=1/0,N[1]=1/0,N[2]=1/0,M[0]=-1/0,M[1]=-1/0,M[2]=-1/0;for(const n of e){const e=t(n);S(e[3])&&(i=e,(o=N)[0]=Math.min(o[0],i[0]-i[3]),o[1]=Math.min(o[1],i[1]-i[3]),o[2]=Math.min(o[2],i[2]-i[3]),m(M,e))}var o,i;n.lerp(s.getCenter(r),N,M,.5),r[3]=Math.max(M[0]-N[0],M[1]-N[1],M[2]-N[2])/2}function b(e,t){let n,r=1/0;for(let o=0;o<8;++o){const i=g(e,t,x[o]);i<r&&(r=i,n=x[o])}return n}function g(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function S(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}!function(e){var t;(t=e.DepthOrder||(e.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(h||(h={}));const O=[r.fromValues(-1,-1,-1),r.fromValues(1,-1,-1),r.fromValues(-1,1,-1),r.fromValues(1,1,-1),r.fromValues(-1,-1,1),r.fromValues(1,-1,1),r.fromValues(-1,1,1),r.fromValues(1,1,1)],x=[r.fromValues(-1,-1,-1),r.fromValues(-1,-1,1),r.fromValues(-1,1,-1),r.fromValues(-1,1,1),r.fromValues(1,-1,-1),r.fromValues(1,-1,1),r.fromValues(1,1,-1),r.fromValues(1,1,1)],j=Math.sqrt(3),T=[null],z=s.create(),C=r.create(),N=r.create(),M=r.create(),B=new t,D=s.create(),A=s.create(),R=s.create(),y=s.create(),F=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],v=new t,V=[0,0,0,0,0,0,0,0];return h}));