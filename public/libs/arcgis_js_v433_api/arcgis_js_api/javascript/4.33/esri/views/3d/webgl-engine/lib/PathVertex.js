// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/mat2","../../../../core/libs/gl-matrix-2/factories/mat2f64","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","./PathExtruder","./PathGeometry"],(function(t,e,r,a,i,s,h,o,n,c){"use strict";class g{constructor(){this.vLeft=o.create(),this.vRight=o.create(),this.vMinSiblingLength=0,this.frame=new n.Frame2D}setFrameFromUpVector(t){h.copy(this.frame.up,t),h.add(R,this.vLeft,this.vRight),h.normalize(R,R),h.scale(x,this.frame.up,h.dot(R,this.frame.up)),h.subtract(A,R,x),h.normalize(A,A),h.cross(this.frame.right,A,this.frame.up)}get foldingAngle(){return Math.PI-this.rotationAngle}}class l extends g{get rotationFrameUp(){return this.frame.up}get rotationRight(){return s.UNIT_X}get rotationAngle(){return h.scale(M,this.frame.up,h.dot(this.frame.up,this.vLeft)),h.subtract(M,this.vLeft,M),h.negate(M,M),h.normalize(M,M),h.scale(b,this.frame.up,h.dot(this.frame.up,this.vRight)),h.subtract(b,this.vRight,b),h.normalize(b,b),h.cross(v,this.rotationFrameUp,this.vLeft),Math.sign(h.dot(v,this.vRight))*(Math.PI-e.acosClamped(h.dot(M,b)))}get maxStretchDistance(){return Math.abs(this.vMinSiblingLength/Math.cos(.5*this.foldingAngle))}applyMiterStretch(t,r){const a=this.rotationAngle;if(Math.abs(a)<=0)return r;const s=e.reciprocalClamped(Math.cos(.5*a));return i.set(t,(s-1+1)*r[0],r[1])}}class m extends g{get rotationFrameUp(){const t=Math.sign(h.dot(this.frame.right,this.vRight));return h.cross(f,this.vRight,this.vLeft),h.scale(f,f,t),h.normalize(f,f)}get rotationRight(){const t=this.rotationFrameUp,e=h.dot(t,this.frame.up),r=h.dot(t,this.frame.right);var a,s,o;return h.scale(p,this.frame.up,-r),h.scale(d,this.frame.right,e),h.add(p,p,d),h.normalize(p,p),a=u,s=this.frame,o=p,i.set(a,h.dot(o,s.right),h.dot(o,s.up)),u}get rotationAngle(){const t=Math.sign(h.dot(this.frame.right,this.vRight));return h.negate(v,this.vLeft),-t*(Math.PI-e.acosClamped(h.dot(v,this.vRight)))}get maxStretchDistance(){return Math.abs(this.vMinSiblingLength*e.reciprocalClamped(Math.cos(.5*this.foldingAngle)))}applyMiterStretch(t,a){const s=this.rotationAngle;if(0===Math.abs(s))return a;const h=e.reciprocalClamped(Math.cos(.5*s)),o=this.rotationRight,n=r.set(L,1+(h-1)*o[0]*o[0],(h-1)*o[0]*o[1],(h-1)*o[0]*o[1],1+(h-1)*o[1]*o[1]);return i.transformMat2(t,a,n)}}const f=o.create(),u=s.create(),p=o.create(),d=o.create(),v=o.create(),M=o.create(),b=o.create(),x=o.create(),R=o.create(),A=o.create(),L=a.create();t.PathVertex=g,t.newPathVertex=function(t){switch(t){case c.UpVectorAlignment.World:return new l;case c.UpVectorAlignment.Path:return new m}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));