// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/arrayUtils","../../../../../core/memoryEstimations","../IntersectorInterfaces","../IntersectorResult","../IntersectorType","../VertexAttribute","./Intersector"],(function(e,t,r,n,s,i,o,u){"use strict";class a{constructor(e,t,r,n){this.material=e,this.bufferWriter=e.createBufferWriter(),this.vertexBufferLayout=this.bufferWriter.vertexBufferLayout,this.buffer=t,this.elementCount=r,this.boundingInfo=n}get numTriangles(){return this.elementCount/3}get numVertices(){return this.elementCount}computeUsedMemory(){return this.buffer.byteLength+r.baseTypedArrayMemory}getRenderGeometry(){return this}intersect(e,t,r,n,s,i,o,u){const a=this.bufferWriter,c=this.buffer;a.intersect(c,this.material.parameters,null,e,r,n,((r,n,a)=>m(r,n,a,e,t,i,o,s,u)))}}function m(e,t,r,o,a,m,c,l,f){if(e<0)return;if(a&&!a(o.rayBegin,o.rayEnd,e))return;const h=new u.LodTarget(m.layerViewUid,m.graphicUid(l),r,c,f);if((null==o.results.min.distance||e<o.results.min.distance)&&o.results.min.set(i.IntersectorType.LOD,h,e,t,o.transform.transform),(null==o.results.max.distance||e>o.results.max.distance)&&o.results.max.set(i.IntersectorType.LOD,h,e,t,o.transform.transform),o.options.store===n.StoreResults.ALL){const r=new s.IntersectorResult(o.results.min.ray);r.set(i.IntersectorType.LOD,h,e,t,o.transform.transform),o.results.all.push(r)}}e.LodComponentEngineGeometry=class{constructor(e){this.engineGeometry=e}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.attributes.get(o.VertexAttribute.POSITION).indices.length}get numTriangles(){return this.engineGeometry.indexCount/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce(((e,t)=>e+r.estimateNumberArrayMemory(t.data,t.indices)),0)}getRenderGeometry(){const e=this.material,t=this.engineGeometry,r=t.attributes,n=t.boundingInfo,s=e.createBufferWriter(),i=s.vertexBufferLayout,o=s.elementCount(r),u=i.createBuffer(o);return s.write(null,null,r,null,u,0),new a(e,u.buffer,o,n)}intersect(e,t,r,n,s,i,o,u){const a=this.engineGeometry;this.material.intersect(a,e.transform.transform,e,r,n,((r,n,a)=>m(r,n,a,e,t,i,o,s,u)))}},e.LodComponentRenderGeometry=a,e.LodComponentResources=class{constructor(e,t=null){this.geometry=e,this.textures=t}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}},e.LodLevelResources=class{constructor(e,r,n){this.components=e,this.minScreenSpaceRadius=r,this.pivotOffset=n;const s=t.unique(this.components.map((e=>e.geometry)));this.numVertices=s.reduce(((e,t)=>e+t.numVertices),0)}},e.LodResources=class{constructor(e){this.levels=e,this.levels.sort(((e,t)=>e.minScreenSpaceRadius===t.minScreenSpaceRadius?e.numVertices-t.numVertices:e.minScreenSpaceRadius-t.minScreenSpaceRadius))}getMaterials(){const e=[];return this.levels.forEach((t=>t.components.forEach((t=>e.push(t.geometry.material))))),t.unique(e)}getTextures(){const e=new Array;return this.levels.forEach((t=>t.components.forEach((t=>{null!=t.textures&&e.push(...t.textures)})))),t.unique(e)}getGeometries(){const e=new Array;return this.levels.forEach((t=>t.components.forEach((t=>{e.push(t.geometry)})))),t.unique(e)}getEngineGeometries(){return this.getGeometries().map((e=>e.engineGeometry)).filter((e=>null!=e))}computeUsedMemory(){const e=this.getGeometries(),t=this.getTextures(),r=e.reduce(((e,t)=>e+t.computeUsedMemory()),0);return t.reduce(((e,t)=>e+t.usedMemory),0)+r}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));