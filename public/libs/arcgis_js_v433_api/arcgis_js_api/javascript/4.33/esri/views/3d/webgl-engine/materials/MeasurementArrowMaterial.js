// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../lib/GLMaterial","../lib/Material","../lib/RenderSlot","../lib/VertexAttribute","../shaders/MeasurementArrowTechnique","../shaders/MeasurementArrowTechniqueConfiguration","../../../../webscene/support/AlphaCutoff"],(function(e,t,r,s,o,i,n,a,u,l,c,f,h){"use strict";class p extends a.Material{constructor(e){super(e,g),this._configuration=new f.MeasurementArrowTechniqueConfiguration,this.vertexAttributeLocations=c.vertexAttributeLocations,this.intersectDraped=void 0,this.produces=new Map([[u.RenderSlot.OPAQUE_MATERIAL,e=>!this._transparent&&i.isColorOrColorEmission(e)],[u.RenderSlot.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>this._transparent&&i.isColorOrColorEmission(e)]])}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this._transparent,this._configuration.oitPass=t.oitPass,this._configuration}get visible(){const{outlineColor:e,stripeEvenColor:t,stripeOddColor:r}=this.parameters;return e[3]>=h.alphaCutoff||t[3]>=h.alphaCutoff||r[3]>=h.alphaCutoff}intersect(){}createGLMaterial(e){return new d(e)}createBufferWriter(){return new v}get _transparent(){const{parameters:e}=this;return e.outlineColor[3]<1||e.stripeEvenColor[3]<1||e.stripeOddColor[3]<1}}class d extends n{beginSlot(e){return this.getTechnique(c.MeasurementArrowTechnique,e)}}class g extends a.MaterialParameters{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=s.fromValues(1,.5,0,1),this.stripeEvenColor=s.fromValues(1,1,1,1),this.stripeOddColor=s.fromValues(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const m=o.newLayout().vec3f(l.VertexAttribute.POSITION).vec3f(l.VertexAttribute.NORMAL).vec2f(l.VertexAttribute.UV0).f32(l.VertexAttribute.LENGTH),A=r.create(),b=r.create(),C=r.create(),M=r.create(),O=r.create();class v{constructor(){this.vertexBufferLayout=m}elementCount(e){return 2*(e.get(l.VertexAttribute.POSITION).indices.length/2+1)}write(e,r,s,o,i,n){const{data:a,indices:u}=s.get(l.VertexAttribute.POSITION),c=s.get(l.VertexAttribute.NORMAL).data,f=a.length/3;u&&u.length!==2*(f-1)&&console.warn("MeasurementArrowMaterial does not support indices");const h=A,p=b,d=C,g=M,m=O,v=i.position,x=i.normal,T=i.uv0;let V=0;for(let s=0;s<f;++s){const o=3*s;if(t.set(h,a[o],a[o+1],a[o+2]),s<f-1){const e=3*(s+1);t.set(p,a[e],a[e+1],a[e+2]),t.set(m,c[e],c[e+1],c[e+2]),t.normalize(m,m),t.subtract(d,p,h),t.normalize(d,d),t.cross(g,m,d),t.normalize(g,g)}const i=t.distance(h,p);e&&r&&(t.transformMat4(h,h,e),t.transformMat4(p,p,e),t.transformMat4(g,g,r));const u=n+2*s,l=u+1;v.setVec(u,h),v.setVec(l,h),x.setVec(u,g),x.setVec(l,g),T.set(u,0,V),T.set(u,1,-1),T.set(l,0,V),T.set(l,1,1),s<f-1&&(V+=i)}const w=i.length;for(let e=0;e<2*f;++e)w.set(n+e,V);return null}}e.MeasurementArrowMaterial=p,e.Parameters=g,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));