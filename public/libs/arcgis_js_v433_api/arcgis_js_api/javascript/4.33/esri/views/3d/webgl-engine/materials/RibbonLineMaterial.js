// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/Logger","../../../../core/mathUtils","../../../../core/screenUtils","../../../../core/libs/gl-matrix-2/math/vec2","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/support/float16","../../../../geometry/support/frustum","../../../../geometry/support/lineSegment","../../../../geometry/support/plane","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../effects/geometry/olidUtils","../lib/GLMaterial","../lib/Material","../lib/RenderSlot","../lib/Util","../lib/VertexAttribute","./VisualVariablePassParameters","./internal/bufferWriterUtils","../shaders/LineMarkerTechniqueConfiguration","../../../../chunks/RibbonLine.glsl","../shaders/RibbonLineTechnique","../shaders/RibbonLineTechniqueConfiguration","../../../../webscene/support/AlphaCutoff"],(function(e,t,r,i,a,s,n,o,l,c,u,h,d,p,T,f,m,A,E,_,R,g,S,b,O,I,P){"use strict";var v;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(v||(v={}));class L extends m.Material{constructor(e){super(e,C),this._configuration=new I.RibbonLineTechniqueConfiguration,this.vertexAttributeLocations=O.vertexAttributeLocations,this.produces=new Map([[A.RenderSlot.OPAQUE_MATERIAL,e=>p.isHighlightOrOID(e)||p.isColorOrColorEmission(e)&&this.parameters.renderOccluded===m.RenderOccludedFlag.OccludeAndTransparentStencil],[A.RenderSlot.OPAQUE_MATERIAL_WITHOUT_NORMALS,e=>p.isDepth(e)],[A.RenderSlot.OCCLUDER_MATERIAL,e=>p.isColorEmissionHighlightOIDOrDepth(e)&&this.parameters.renderOccluded===m.RenderOccludedFlag.OccludeAndTransparentStencil],[A.RenderSlot.TRANSPARENT_OCCLUDER_MATERIAL,e=>p.isColorEmissionHighlightOIDOrDepth(e)&&this.parameters.renderOccluded===m.RenderOccludedFlag.OccludeAndTransparentStencil],[A.RenderSlot.TRANSPARENT_MATERIAL,e=>p.isColorOrColorEmission(e)&&this.parameters.writeDepth&&this.parameters.renderOccluded!==m.RenderOccludedFlag.OccludeAndTransparentStencil],[A.RenderSlot.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>p.isColorOrColorEmission(e)&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==m.RenderOccludedFlag.OccludeAndTransparentStencil],[A.RenderSlot.DRAPED_MATERIAL,e=>p.is2DGeometryOutput(e)]])}getConfiguration(e,t){super.getConfiguration(e,t,this._configuration),this._configuration.oitPass=t.oitPass,this._configuration.draped=t.slot===A.RenderSlot.DRAPED_MATERIAL;const r=null!=this.parameters.stipplePattern&&e!==p.ShaderOutput.Highlight;var i;return this._configuration.stippleEnabled=r,this._configuration.stippleOffColorEnabled=r&&null!=this.parameters.stippleOffColor,this._configuration.stipplePreferContinuous=r&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=null!=this.parameters.markerParameters&&(i=this.parameters.markerParameters).anchor===S.LineMarkerAnchor.Tip&&i.hideOnShortSegments&&"begin-end"===i.placement&&i.worldSpace,this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&null!=this.parameters.innerColor,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.hasOccludees=t.hasOccludees,this._configuration.occluder=this.parameters.renderOccluded===m.RenderOccludedFlag.OccludeAndTransparentStencil,this._configuration.terrainDepthTest=t.terrainDepthTest&&p.isColorOrColorEmission(e),this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration.wireframe=this.parameters.wireframe,this._configuration}get visible(){return this.parameters.color[3]>=P.alphaCutoff||null!=this.parameters.stipplePattern&&(this.parameters.stippleOffColor?.[3]??0)>P.alphaCutoff}intersectDraped({attributes:e,screenToWorldRatio:t},i,a,s,n){if(!i.options.selectionMode)return;const o=e.get(_.VertexAttribute.SIZE);let l=this.parameters.width;if(this.parameters.vvSize){const t=e.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE).data[0];Number.isNaN(t)?l*=this.parameters.vvSize.fallback[0]:l*=r.clamp(this.parameters.vvSize.offset[0]+t*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else o&&(l*=o.data[0]);const c=a[0],u=a[1],h=(l/2+4)*t;let d=Number.MAX_VALUE,p=0;const T=e.get(_.VertexAttribute.POSITION).data,f=D(this.parameters,e)?T.length-2:T.length-5;for(let e=0;e<f;e+=3){const t=T[e],i=T[e+1],a=(e+3)%T.length,s=c-t,n=u-i,o=T[a]-t,l=T[a+1]-i,h=o*s+l*n,f=o*o+l*l,m=r.clamp(h/f,0,1),A=o*m-s,E=l*m-n,_=A*A+E*E;_<d&&(d=_,p=e/3)}d<h*h&&s(n.distance,n.normal,p)}intersect(e,i,n,o,l,d){const{options:p,camera:T,rayBegin:f,rayEnd:m}=n;if(!p.selectionMode||!e.visible||!T)return;if(!E.isTranslationMatrix(i))return void t.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const A=e.attributes,R=A.get(_.VertexAttribute.POSITION).data;let g=this.parameters.width;if(this.parameters.vvSize){const e=A.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE).data[0];Number.isNaN(e)||(g*=r.clamp(this.parameters.vvSize.offset[0]+e*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0]))}else A.has(_.VertexAttribute.SIZE)&&(g*=A.get(_.VertexAttribute.SIZE).data[0]);const S=w;a.copy(S,n.point);const b=g*T.pixelRatio/2+4*T.pixelRatio;s.set(Y[0],S[0]-b,S[1]+b,0),s.set(Y[1],S[0]+b,S[1]+b,0),s.set(Y[2],S[0]+b,S[1]-b,0),s.set(Y[3],S[0]-b,S[1]-b,0);for(let e=0;e<4;e++)if(!T.unprojectFromRenderScreen(Y[e],q[e]))return;h.fromPoints(T.eye,q[0],q[1],X),h.fromPoints(T.eye,q[1],q[2],Q),h.fromPoints(T.eye,q[2],q[3],K),h.fromPoints(T.eye,q[3],q[0],$);let O=Number.MAX_VALUE,I=0;const P=D(this.parameters,A)?R.length-2:R.length-5;for(let e=0;e<P;e+=3){V[0]=R[e]+i[12],V[1]=R[e+1]+i[13],V[2]=R[e+2]+i[14];const t=(e+3)%R.length;if(F[0]=R[t]+i[12],F[1]=R[t+1]+i[13],F[2]=R[t+2]+i[14],h.signedDistance(X,V)<0&&h.signedDistance(X,F)<0||h.signedDistance(Q,V)<0&&h.signedDistance(Q,F)<0||h.signedDistance(K,V)<0&&h.signedDistance(K,F)<0||h.signedDistance($,V)<0&&h.signedDistance($,F)<0)continue;if(T.projectToRenderScreen(V,B),T.projectToRenderScreen(F,J),B[2]<0&&J[2]>0){s.subtract(U,V,F);const e=T.frustum,t=-h.signedDistance(e[c.PlaneIndex.NEAR],V)/s.dot(U,h.getNormal(e[c.PlaneIndex.NEAR]));s.scale(U,U,t),s.add(V,V,U),T.projectToRenderScreen(V,B)}else if(B[2]>0&&J[2]<0){s.subtract(U,F,V);const e=T.frustum,t=-h.signedDistance(e[c.PlaneIndex.NEAR],F)/s.dot(U,h.getNormal(e[c.PlaneIndex.NEAR]));s.scale(U,U,t),s.add(F,F,U),T.projectToRenderScreen(F,J)}else if(B[2]<0&&J[2]<0)continue;B[2]=0,J[2]=0;const r=u.distance2(u.fromPoints(B,J,G),S);r<O&&(O=r,s.copy(H,V),s.copy(z,F),I=e/3)}if(O<b*b){let e=Number.MAX_VALUE;if(u.closestLineSegmentPoint(u.fromPoints(H,z,G),u.fromPoints(f,m,k),M)){s.subtract(M,M,f);const t=s.length(M);s.scale(M,M,1/t),e=t/s.distance(f,m)}d(e,M,I)}}get _layout(){const e=d.newLayout().vec3f(_.VertexAttribute.POSITION).vec4f16(_.VertexAttribute.PREVIOUSDELTA).vec4f16(_.VertexAttribute.NEXTDELTA).f32(_.VertexAttribute.U0).vec2f16(_.VertexAttribute.LINEPARAMETERS);return this.parameters.vvColor?e.f32(_.VertexAttribute.COLORFEATUREATTRIBUTE):e.vec4u8(_.VertexAttribute.COLOR,{glNormalized:!0}),this.parameters.vvSize?e.f32(_.VertexAttribute.SIZEFEATUREATTRIBUTE):e.f32(_.VertexAttribute.SIZE),this.parameters.vvOpacity&&e.f32(_.VertexAttribute.OPACITYFEATUREATTRIBUTE),T.olidEnabled()&&e.vec4u8(_.VertexAttribute.OLIDCOLOR),e}createBufferWriter(){return new x(this._layout,this.parameters)}createGLMaterial(e){return new N(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),null!=e.markerParameters&&(e.markerScale=e.markerParameters.width/e.width)}}class N extends f{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextures.release(this._stipplePattern),this._stipplePattern=null}beginSlot(e){const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters({stippleTexture:this._stippleTextures.swap(t,this._stipplePattern)}),this._stipplePattern=t),this.getTechnique(O.RibbonLineTechnique,e)}}class C extends R.VisualVariablePassParameters{constructor(){super(...arguments),this.width=0,this.color=o.ONES,this.join="miter",this.cap=I.CapType.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.wireframe=!1}get transparent(){return this.color[3]<1||null!=this.stipplePattern&&(this.stippleOffColor?.[3]??0)<1}}class x{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t;const r=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=b.ribbonlineNumRoundJoinSubdivisions+r}}_isClosed(e){return D(this._parameters,e)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=e.get(_.VertexAttribute.POSITION).indices.length/2+1,r=this._isClosed(e);let i=r?2:4;return i+=((r?t:t-1)-(r?0:1))*(2*this.numJoinSubdivisions+4),i+=2,this._parameters.wireframe&&(i=2+4*(i-2)),i}write(e,t,r,i,a,n){const o=r.get(_.VertexAttribute.POSITION),c=o.indices,u=o.data.length/3,h=r.get(_.VertexAttribute.DISTANCETOSTART)?.data;c&&c.length!==2*(u-1)&&console.warn("RibbonLineMaterial does not support indices");const d=(this.vertexBufferLayout.fields.has(_.VertexAttribute.SIZEFEATUREATTRIBUTE)?r.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE)?.data[0]:r.get(_.VertexAttribute.SIZE)?.data[0])??1;let p=[1,1,1,1],f=0;const m=this.vertexBufferLayout.fields.has(_.VertexAttribute.COLORFEATUREATTRIBUTE);m?f=r.get(_.VertexAttribute.COLORFEATUREATTRIBUTE).data[0]:r.has(_.VertexAttribute.COLOR)&&(p=r.get(_.VertexAttribute.COLOR).data);const A=this.vertexBufferLayout.fields.has(_.VertexAttribute.OPACITYFEATUREATTRIBUTE),E=A?r.get(_.VertexAttribute.OPACITYFEATUREATTRIBUTE).data[0]:0,R=new Float32Array(a.buffer),S=l.makeFloat16Array(a.buffer),b=new Uint8Array(a.buffer),O=this.vertexBufferLayout.stride/4;let I=n*O;const P=I;let L=0;const N=h?(e,t,r)=>L=h[r]:(e,t,r)=>L+=s.distance(e,t),C=R.BYTES_PER_ELEMENT/S.BYTES_PER_ELEMENT,x=4/C,D=(e,t,r,a,s,n,o)=>{R[I++]=t[0],R[I++]=t[1],R[I++]=t[2],g.writeDeltaF16Vector(e,t,S,I*C),I+=x,g.writeDeltaF16Vector(r,t,S,I*C),I+=x,R[I++]=o;let l=I*C;if(S[l++]=a,S[l++]=s,I=Math.ceil(l/C),m)R[I]=f;else{const e=Math.min(4*n,p.length-4),t=4*I;b[t]=255*p[e],b[t+1]=255*p[e+1],b[t+2]=255*p[e+2],b[t+3]=255*p[e+3]}if(I++,R[I++]=d,A&&(R[I++]=E),T.olidEnabled()){let e=4*I;i?(b[e++]=i[0],b[e++]=i[1],b[e++]=i[2],b[e++]=i[3]):(b[e++]=0,b[e++]=0,b[e++]=0,b[e++]=0),I=Math.ceil(.25*e)}};I+=O,s.set(Z,o.data[0],o.data[1],o.data[2]),e&&s.transformMat4(Z,Z,e);const V=this._isClosed(r);if(V){const t=o.data.length-3;s.set(j,o.data[t],o.data[t+1],o.data[t+2]),e&&s.transformMat4(j,j,e)}else s.set(W,o.data[3],o.data[4],o.data[5]),e&&s.transformMat4(W,W,e),D(Z,Z,W,1,v.LEFT_CAP_START,0,0),D(Z,Z,W,1,v.RIGHT_CAP_START,0,0),s.copy(j,Z),s.copy(Z,W);const F=V?0:1,U=V?u:u-1;for(let t=F;t<U;t++){const r=(t+1)%u*3;s.set(W,o.data[r],o.data[r+1],o.data[r+2]),e&&s.transformMat4(W,W,e),N(j,Z,t),D(j,Z,W,0,v.LEFT_JOIN_END,t,L),D(j,Z,W,0,v.RIGHT_JOIN_END,t,L);const i=this.numJoinSubdivisions;for(let e=0;e<i;++e){const r=(e+1)/(i+1);D(j,Z,W,r,v.LEFT_JOIN_END,t,L),D(j,Z,W,r,v.RIGHT_JOIN_END,t,L)}D(j,Z,W,1,v.LEFT_JOIN_START,t,L),D(j,Z,W,1,v.RIGHT_JOIN_START,t,L),s.copy(j,Z),s.copy(Z,W)}return V?(s.set(W,o.data[3],o.data[4],o.data[5]),e&&s.transformMat4(W,W,e),L=N(j,Z,U),D(j,Z,W,0,v.LEFT_JOIN_END,F,L),D(j,Z,W,0,v.RIGHT_JOIN_END,F,L)):(L=N(j,Z,U),D(j,Z,Z,0,v.LEFT_CAP_END,U,L),D(j,Z,Z,0,v.RIGHT_CAP_END,U,L)),y(R,P+O,R,P,O),I=y(R,I-O,R,I,O),this._parameters.wireframe&&this._addWireframeVertices(a,P,I,O),null}_addWireframeVertices(e,t,r,i){const a=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),s=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=y(s,e,a,n,i);for(let e=0;e<s.length-1;e+=2*i)o(e),o(e+2*i),o(e+1*i),o(e+2*i),o(e+1*i),o(e+3*i)}}function y(e,t,r,i,a){for(let s=0;s<a;s++)r[i++]=e[t++];return i}function D(e,t){return!!e.isClosed&&t.get(_.VertexAttribute.POSITION).indices.length>2}const V=n.create(),F=n.create(),U=n.create(),M=n.create(),w=n.create(),B=i.createRenderScreenPointArray3(),J=i.createRenderScreenPointArray3(),H=n.create(),z=n.create(),G=u.create(),k=u.create(),j=n.create(),Z=n.create(),W=n.create(),Y=[i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3()],q=[n.create(),n.create(),n.create(),n.create()],X=h.create(),Q=h.create(),K=h.create(),$=h.create();e.Parameters=C,e.RibbonLineMaterial=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));