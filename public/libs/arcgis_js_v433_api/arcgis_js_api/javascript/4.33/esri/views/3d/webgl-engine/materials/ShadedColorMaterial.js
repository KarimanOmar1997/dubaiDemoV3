// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/buffer/BufferView","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../lib/basicInterfaces","../lib/GLMaterial","../lib/Material","../lib/RayIntersections","../lib/RenderSlot","../lib/Util","../lib/VertexAttribute","./internal/bufferWriterUtils","../shaders/ShadedColorMaterialTechnique","../shaders/ShadedColorMaterialTechniqueConfiguration","../../../../webscene/support/AlphaCutoff"],(function(e,t,r,i,a,s,n,o,c,l,u,h,p,f,d,b,S,g,m){"use strict";class T extends u.Material{constructor(e){super(e,E),this._configuration=new g.ShadedColorMaterialTechniqueConfiguration,this.vertexAttributeLocations=S.vertexAttributeLocations,this.supportsEdges=!0,this._pp0=r.fromValues(0,0,1),this._pp1=r.fromValues(0,0,0),this.produces=new Map([[p.RenderSlot.OPAQUE_MATERIAL,e=>e===o.ShaderOutput.Highlight||o.isColorOrOID(e)&&!this.parameters.transparent],[p.RenderSlot.TRANSPARENT_MATERIAL,e=>o.isColorOrOID(e)&&this.parameters.transparent&&this.parameters.writeDepth],[p.RenderSlot.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>o.isColorOrOID(e)&&this.parameters.transparent&&!this.parameters.writeDepth]])}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.screenSizeEnabled=this.parameters.screenSizeEnabled,this._configuration.shadingEnabled=this.parameters.shadingEnabled,this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest&&o.isColorOrColorEmission(e),this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}get visible(){return this.parameters.color[3]>=m.alphaCutoff}intersect(e,t,r,i,a,s){this._intersect(e,r,i,a,s)}intersectDraped(e,t,r,i){return this._pp0[0]=this._pp1[0]=r[0],this._pp0[1]=this._pp1[1]=r[1],this._intersect(e,t,this._pp0,this._pp1,i)}_intersect(e,r,i,s,n){if(this.parameters.screenSizeEnabled){const o=e.attributes.get(d.VertexAttribute.OFFSET),c={applyToVertex:(e,i,a,s)=>{const n=t.set(x,o.data[3*s],o.data[3*s+1],o.data[3*s+2]),c=t.set(O,e,i,a);return t.scale(n,n,this.parameters.screenSizeScale*(r.camera?.computeScreenPixelSizeAt(n)??1)),t.add(c,c,n),[c[0],c[1],c[2]]},applyToAabb:e=>{const t=a.center(e,x);return a.scale(e,this.parameters.screenSizeScale*(r.camera?.computeScreenPixelSizeAt(t)??1))}};h.intersectTriangleGeometry(e,r,i,s,c,n)}else h.intersectTriangleGeometry(e,r,i,s,void 0,n)}createGLMaterial(e){return new A(e)}createBufferWriter(){return new _(this.parameters.screenSizeEnabled)}}class A extends l{beginSlot(e){return this.getTechnique(S.ShadedColorMaterialTechnique,e)}}class E extends u.MaterialParameters{constructor(){super(...arguments),this.color=i.fromValues(1,1,1,1),this.shadingTint=i.fromValues(0,0,0,.25),this.shadingDirection=t.normalize(r.create(),[.5,-.5,-.5]),this.screenSizeScale=14,this.forceTransparentMode=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=c.CullFaceOptions.None,this.screenSizeEnabled=!1,this.shadingEnabled=!0}get transparent(){return this.color[3]<1||this.forceTransparentMode}}class _{constructor(e){this.screenSizeEnabled=e;const t=n.newLayout().vec3f(d.VertexAttribute.POSITION).vec3f(d.VertexAttribute.NORMAL);this.screenSizeEnabled&&t.vec3f(d.VertexAttribute.OFFSET),this.vertexBufferLayout=t}elementCount(e){return e.get(d.VertexAttribute.POSITION).indices.length}write(e,t,r,i,a,n){const o=b.writeDefaultAttributes(r,i,this.vertexBufferLayout,e,t,a,n);if(this.screenSizeEnabled){if(!r.has(d.VertexAttribute.OFFSET))throw new Error(`${d.VertexAttribute.OFFSET} vertex attribute required for screenSizeEnabled ShadedColorMaterial`);{const e=r.get(d.VertexAttribute.OFFSET);f.assert(3===e.size);const i=a.getField(d.VertexAttribute.OFFSET,s.BufferViewVec3f);if(!i)throw new Error("unable to acquire view for "+d.VertexAttribute.OFFSET);b.writePosition(e,t,i,n)}}return o}}const x=r.create(),O=r.create();e.Parameters=E,e.ShadedColorMaterial=T,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));