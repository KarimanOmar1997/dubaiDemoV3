// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../chunks/vec42","../../../core/libs/gl-matrix-2/factories/vec4f64","../../../geometry/support/geodesicConstants","../../../geometry/support/geodesicUtils","../../../geometry/support/plane","../../../chunks/sphere","../../3d/support/mathUtils","./normalizedPoint","../../support/geometry3dUtils","../../support/geometry2dUtils"],(function(e,t,n,s,r,i,c,a,o,l,u,d,h,f,p,P,L){"use strict";class C{intersect(e){return Z(this,e)}closestPoints(e){return[this.closestTo(e)]}}class g extends C{constructor(e){super(),this.point=e}equals(e){return this===e||te(e)&&i.exactEquals(this.point,e.point)}closestTo(){return p.clone(this.point)}}class V extends C{constructor(e,t,n){super(),this.start=e,this.end=t,this.lineLike={start:e,end:t,type:n}}equals(e){return this===e||ne(e)&&this.lineLike.type===e.lineLike.type&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)}closestTo(e){const t=p.createWritable();return P.projectPointToLineLike(e,this.lineLike,t),t}}class m extends V{constructor(e,t){super(e,t,L.LineType.LINE)}}class _ extends V{constructor(e,t){super(e,t,L.LineType.RAY)}}class y extends C{constructor(e){super(),this.constraints=e}equals(e){return this===e||ee(e)&&t.equals(this.constraints,e.constraints,((e,t)=>e.equals(t)))}closestTo(e){let t,n=1/0;for(const s of this.constraints){const r=s.closestTo(e),c=i.squaredDistance(e,r);c<n&&(n=c,t=r)}return p.clone(t??e)}closestPoints(e){return this.constraints.flatMap((t=>t===this?[]:t.closestPoints(e)))}}class A extends C{constructor(e,t){super(),this.center=e,this.radius=t}equals(e){return this===e||ie(e)&&this.center[0]===e.center[0]&&this.center[1]===e.center[1]&&this.radius===e.radius}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalCylinder(e,this.center,this.radius,t),t}}class k extends C{constructor(e,t){super(),this.center=e,this.radius=t}equals(e){return this===e||ce(e)&&i.exactEquals(this.center,e.center)&&this.radius===e.radius}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalCylinder(e,this.center,this.radius,t),t[2]=this.center[2],t}asCircle(){return new x(p.clone(this.center),this.radius,p.fromValues(0,0,1))}}class x extends C{constructor(e,t,n,s=void 0){super(),this.center=e,this.radius=t,this.normal=n,this.slicePlane=s}equals(e){return this===e||ae(e)&&i.exactEquals(this.center,e.center)&&i.exactEquals(this.normal,e.normal)&&this.radius===e.radius}closestTo(e){const{center:t,radius:n}=this;d.projectPoint(this.getPlane(v),e,q);const s=i.sub(q,q,t),r=i.squaredLength(s);if(P.isClose(r,0))return p.clone(e);const c=n/Math.sqrt(r),a=p.createWritable();i.scaleAndAdd(a,t,s,c);const{slicePlane:o}=this;if(o&&!P.isPointInsidePlane(o,a)){const t=H(o,this);return t?.closestTo(e)??p.clone(e)}return a}getPlane(e=d.create()){return d.fromPositionAndNormal(this.center,this.normal,e)}}const q=c.create(),v=d.create();class T extends C{constructor(e){super(),this.z=e}equals(e){return this===e||se(e)&&this.z===e.z}closestTo(e){return p.fromValues(e[0],e[1],this.z)}getPlane(e=d.create()){return i.set(z,0,0,this.z),d.fromPositionAndNormal(z,c.UNIT_Z,e)}}const z=c.create();class M extends C{constructor(e,t,n){super(),this.start=e,this.end=t,this.planeLike={start:p.asVec2(e),end:p.asVec2(t),type:n}}equals(e){return this===e||re(e)&&this.planeLike.type===e.planeLike.type&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalPlane(e,this.planeLike,t),t}closestEndTo(e){const{start:t,end:n}=this.planeLike;return Math.sign(s.dot(s.subtract(b,n,t),s.subtract(E,p.asVec2(e),t)))>0?this.end:this.start}getPlane(e=d.create()){const t=i.copy(w,this.end);return t[2]+=1,d.fromPoints(this.start,this.end,t,e)}getSlicePlane(e=d.create()){const{start:t,end:n,type:s}=this.planeLike;if(s===P.VerticalPlaneType.PLANE)return;const r=i.set(w,t[0],t[1],0),c=i.set(S,n[0],n[1],0),a=i.subtract(S,c,r);return d.fromPositionAndNormal(r,a,e),e}}const b=r.create(),E=r.create(),w=c.create(),S=c.create();class D extends C{constructor(e,t){super(),this.sphere=h.fromCenterAndRadius(e,t)}equals(e){return this===e||oe(e)&&h.exactEquals(this.sphere,e.sphere)}closestTo(e){const t=p.createWritable();return h.projectPoint(this.sphere,e,t),t}get center(){return h.getCenter(this.sphere)}get radius(){return this.sphere[3]}}class I extends C{constructor(e,t,n){super(),this.start=e,this.end=t,this.getZ=n,this.planeLike={start:p.asVec2(e),end:p.asVec2(t),type:P.VerticalPlaneType.PLANE}}equals(e){return this===e||le(e)&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)&&this.getZ===e.getZ}closestTo(e){return function(e,t){const n=p.createWritable();return P.projectPointToVerticalPlane(t,e.planeLike,n),n[2]=e.getZ(n[0],n[1])??ue,n}(this,e)}addIfOnTheGround(e,t){for(const n of t){const t=this.getZ(n[0],n[1])??0;P.isClose(n[2],t)&&(n[2]=t,e.push(n))}}}class R extends C{constructor(e,t,n){super(),this._x=e,this._y=t,this._z=n}equals(e){return this===e||e instanceof R&&this._x===e._x&&this._y===e._y&&this._z===e._z}closestTo([e,t,n]){return p.create(this._x??e,this._y??t,this._z??n)}}class N extends C{constructor(e,t,n,s,r){super(),this._origin=e,this._spatialReference=t,this._distanceMeters=n,this._z=s,this._directionDegrees=r}equals(e){return this===e||e instanceof N&&s.exactEquals(this._origin,e._origin)&&this._spatialReference===e._spatialReference&&this._distanceMeters===e._distanceMeters&&this._z===e._z&&this._directionDegrees===e._directionDegrees}closestTo([e,t,n]){return s.set(G,e,t),s.exactEquals(G,this._origin)||this._applyDirectionAndDistance(G),p.create(G[0],G[1],this._z??n)}_applyDirectionAndDistance(e){if(null!=this._directionDegrees&&null!=this._distanceMeters)u.directGeodeticSolver(e,this._origin,this._directionDegrees,this._distanceMeters,this._spatialReference);else if(null!=this._directionDegrees)!function(e,t,n,s,r){let{azimuth:i,distance:c}=u.inverseGeodeticSolver(j,t,s,r);i??=0;let a=c*Math.cos((i-n)*l.toRadians);a=Math.max(0,a),u.directGeodeticSolver(e,t,n,a,r)}(e,this._origin,this._directionDegrees,e,this._spatialReference);else if(null!=this._distanceMeters){const{azimuth:t}=u.inverseGeodeticSolver(W,this._origin,e,this._spatialReference);u.directGeodeticSolver(e,this._origin,t??0,this._distanceMeters,this._spatialReference)}}}const G=[0,0],W=new u.InverseGeodeticSolverResult,j=new u.InverseGeodeticSolverResult;function Z(e,t){if(ee(e)){const n=[];for(const s of e.constraints){const e=s.intersect(t);e&&n.push(e)}return $(n)}if(ee(t))return Z(t,e);if(le(e))return J(e,t);if(le(t))return J(t,e);if(te(e)){const{point:n}=e;if(te(t))return i.exactEquals(n,t.point)?e:void 0;const s=t.closestTo(n);return i.equals(s,n)?e:void 0}if(ne(e)){if(te(t))return Z(t,e);if(ne(t))return Q(P.intersectLineLikes(e.lineLike,t.lineLike));if(se(t))return U(e,t);if(re(t))return Q(P.intersectVerticalPlaneAndLineLike(t.planeLike,e.lineLike));if(ie(t))return Q(P.intersectLineLikeAndVerticalCylinder(e.lineLike,t.center,t.radius));if(ae(t))return Q(P.intersectLineLikeAndCircle(e.lineLike,t));if(ce(t))return function({lineLike:e},{center:t,radius:n}){const s=t[2];return Q(P.intersectLineLikeAndVerticalCylinder(e,t,n).filter((e=>P.isClose(e[2],s))))}(e,t);if(oe(t))return function({lineLike:e},{sphere:t}){return Q(h.intersectLine(t,e.start,e.end))}(e,t)}else if(se(e)){if(te(t)||ne(t))return Z(t,e);if(se(t))return function(e,t){return P.isClose(e.z,t.z)?e:void 0}(e,t);if(re(t))return function({z:e},{planeLike:t}){const[n,s]=t.start,[r,i]=t.end,c=p.fromValues(n,s,e),a=p.fromValues(r,i,e);return t.type===P.VerticalPlaneType.PLANE?new m(c,a):new _(c,a)}(e,t);if(ie(t))return function(e,t){const[n,s]=t.center;return new k(p.fromValues(n,s,e.z),t.radius)}(e,t);if(ae(t))return O(e,t);if(ce(t))return n=e,r=t,P.isClose(r.center[2],n.z)?r:void 0;if(oe(t))return function(e,{center:t,radius:n}){const s=Math.abs(t[2]-e.z);if(s>n&&!P.isClose(s,n))return;const r=p.fromValues(t[0],t[1],e.z),i=Math.sqrt(n**2-s**2);return P.isClose(i,0)?void 0:new k(r,i)}(e,t)}else if(re(e)){if(te(t)||ne(t)||se(t))return Z(t,e);if(re(t))return K(P.intersectVerticalPlanes(e.planeLike,t.planeLike));if(ie(t))return K(P.intersectVerticalPlaneAndVerticalCylinder(e.planeLike,t.center,t.radius));if(ae(t))return Y(e,t);if(ce(t))return F(e,t);if(oe(t))return B(e,t)}else if(ie(e)){if(te(t)||ne(t)||se(t)||re(t))return Z(t,e);if(ie(t))return K(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius));if(ae(t))return;if(ce(t))return function(e,t){const n=s.squaredDistance(p.asVec2(e.center),p.asVec2(t.center));return P.isClose(n,0)&&P.isClose(e.radius,t.radius)?t:X(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius),t.center[2])}(e,t);if(oe(t))return}else if(ae(e)){if(te(t)||ne(t)||se(t)||re(t)||ie(t))return Z(t,e);if(ae(t))return;if(ce(t))return void t.asCircle();if(oe(t))return}else if(ce(e)){if(te(t)||ne(t)||se(t)||re(t)||ie(t)||ae(t))return Z(t,e);if(ce(t))return function(e,t){if(!P.vectorsHaveCloseZ(e.center,t.center))return;const n=s.squaredDistance(p.asVec2(e.center),p.asVec2(t.center));return P.isClose(n,0)&&P.isClose(e.radius,t.radius)?e:X(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius),e.center[2])}(t,e);if(oe(t))return}else if(oe(e)){if(te(t)||ne(t)||se(t)||re(t)||ie(t)||ce(t))return Z(t,e);if(oe(t))return}var n,r}const U=(()=>{const e=d.create();return(t,n)=>{const{start:s,end:r}=t;if(P.vectorsHaveCloseZ(s,r)&&P.isClose(s[2],n.z))return t;const i=p.createWritable();return d.intersectLine(n.getPlane(e),s,r,i)?new g(i):void 0}})(),H=(()=>{const e=o.create(),t=c.create(),s=c.create();return(r,o,l)=>{const{normal:u,center:h,radius:L}=o;f.tangentFrame(u,t,s);const C=d.getNormal(r),V=L*i.dot(C,t),m=L*i.dot(C,s);a.set(e,h[0],h[1],h[2],1);const _=a.dot(r,e),y=Math.hypot(V,m),A=P.isClose(y,0);if(P.isClose(d.distance(r,h),0)){if(A)return o;if(P.isClose(L,0))return!l||P.isPointInsidePlane(l,h)?new g(p.clone(h)):void 0;i.cross(t,C,u),i.normalize(t,t);const e=new Array,n=c.clone(h);i.scaleAndAdd(n,n,t,L),l&&!P.isPointInsidePlane(l,n)||e.push(n);const s=c.clone(h);return i.scaleAndAdd(s,s,t,-L),l&&!P.isPointInsidePlane(l,s)||e.push(s),Q(e)}if(A)return;const k=-_/y;if(Math.abs(k)>1||P.isClose(k,1))return;const x=Math.atan(V/m),q=n.asinClamped(k)-x,v=Math.PI-q,T=new Array,z=c.create();i.scaleAndAdd(z,h,t,L*Math.cos(q)),i.scaleAndAdd(z,z,s,L*Math.sin(q)),T.push(z);const M=c.create();return i.scaleAndAdd(M,h,t,L*Math.cos(v)),i.scaleAndAdd(M,M,s,L*Math.sin(v)),T.push(M),Q(l?P.pointsInsidePlane(l,T):T)}})(),O=(()=>{const e=d.create();return(t,n)=>H(t.getPlane(e),n,n.slicePlane)})(),F=(()=>{const e=d.create();return(t,{center:n,radius:s})=>{const r=P.intersectVerticalPlaneAndVerticalCylinder(t.planeLike,n,s),i=n[2];t.getSlicePlane(e);const c=new Array;for(const[t,n]of r){const s=[t,n,i];P.isPointInsidePlane(e,s)&&c.push(s)}return Q(c)}})(),Y=(()=>{const e=d.create(),t=d.create();return(n,s)=>H(n.getPlane(e),s,n.getSlicePlane(t))})(),B=(()=>{const e=d.create();return(t,{center:n,radius:s})=>{const r=t.getPlane(e),a=d.signedDistance(r,n),o=Math.abs(a);if(o>s&&!P.isClose(o,s))return;const l=Math.sqrt(s**2-a**2);if(P.isClose(l,0)){const e=p.createWritable();return d.projectPoint(r,n,e),new g(e)}const u=p.createWritable(),h=c.clone(d.getNormal(r));return i.scaleAndAdd(u,n,h,a),new x(u,l,h,t.getSlicePlane())}})();function J(e,t){const{planeLike:n,getZ:s}=e,r=new Array;if(te(t))e.addIfOnTheGround(r,P.intersectVerticalPlaneAndPoint(n,t.point));else if(ne(t))e.addIfOnTheGround(r,P.intersectVerticalPlaneAndLineLike(n,t.lineLike));else if(ie(t))for(const[e,i]of P.intersectVerticalPlaneAndVerticalCylinder(n,t.center,t.radius)){const t=s(e,i);null!=t&&r.push(c.fromValues(e,i,t))}else if(re(t)||le(t))for(const[e,i]of P.intersectVerticalPlanes(n,t.planeLike)){const t=s(e,i)??ue;r.push(c.fromValues(e,i,t))}return Q(r)}function K(e){return $(e.map((([e,t])=>{const n=p.fromValues(e,t,0),s=p.fromValues(e,t,1);return new m(n,s)})))}function Q(e){return $(e.map((e=>e?new g(p.fromVec3(e)):void 0)))}function X(e,t){return Q(e.map((([e,n])=>[e,n,t])))}function $(e){if(0!==e.length)return 1===e.length?e[0]??void 0:new y(e.filter(t.isSome))}function ee(e){return e instanceof y}function te(e){return e instanceof g}function ne(e){return e instanceof V}function se(e){return e instanceof T}function re(e){return e instanceof M}function ie(e){return e instanceof A}function ce(e){return e instanceof k}function ae(e){return e instanceof x}function oe(e){return e instanceof D}function le(e){return e instanceof I}const ue=0;e.CircleConstraint=x,e.Constraint=C,e.CoordinateConstraint=R,e.DrapedLineConstraint=I,e.GeodesicConstraint=N,e.HorizontalCircleConstraint=k,e.HorizontalPlaneConstraint=T,e.LineConstraint=m,e.LineLikeConstraint=V,e.PointConstraint=g,e.RayConstraint=_,e.SetConstraint=y,e.SphereConstraint=D,e.VerticalCylinderConstraint=A,e.VerticalHalfPlaneConstraint=class extends M{constructor(e,t){super(e,t,P.VerticalPlaneType.HALF_PLANE)}},e.VerticalPlaneConstraint=class extends M{constructor(e,t){super(e,t,P.VerticalPlaneType.PLANE)}},e.VerticalPlaneLikeConstraint=M,e.constraintOrSet=$,e.isPoint=te,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));