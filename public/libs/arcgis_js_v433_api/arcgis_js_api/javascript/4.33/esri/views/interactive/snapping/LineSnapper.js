// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Cyclical","../../../core/quantityUtils","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../support/elevationInfoUtils","../sketch/normalizedPoint","./SnappingAlgorithm","./snappingUtils","./candidates/LineSnappingCandidate","../support/viewUtils","../../support/angularMeasurementUtils","../../support/geometry3dUtils","../../support/geometry2dUtils"],(function(e,t,n,i,o,s,r,a,c,l,d,g,p){"use strict";class h extends r.SnappingAlgorithm{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],i=n.edges.length,s=[];if(i<1)return s;const{spatialReference:r}=t,c=l.vectorToScreenPoint(e,r,o.absoluteHeightElevationInfo,this.view),{view:d}=this,g=n.edges[i-1];let p=g;do{if(this.edgeExceedsShortLineThreshold(p,t)){const n=a.editEdgeToSnappingEdge(p,d,t);this._processCandidateProposal(n.left,n.right,e,c,t,s)}p=p.leftVertex.leftEdge}while(p&&p!==g);return s}snapExistingVertex(e,t){const n=[],i=t.vertexHandle,r=i.component;if(r.edges.length<2)return n;const{view:c}=this,{spatialReference:d}=t,g=l.vectorToScreenPoint(e,d,o.absoluteHeightElevationInfo,c),p=i.leftEdge,h=i.rightEdge;p&&h&&this.edgeExceedsShortLineThreshold(p,t)&&this.edgeExceedsShortLineThreshold(h,t)&&this._processCandidateProposal(s.fromAnyMapPoint(p.leftVertex.pos,c,t),s.fromAnyMapPoint(h.rightVertex.pos,c,t),e,g,t,n);const u=r.edges[0];let f=u;do{if(f!==i.leftEdge&&f!==i.rightEdge&&this.edgeExceedsShortLineThreshold(f,t)){const i=a.editEdgeToSnappingEdge(f,c,t);this._processCandidateProposal(i.left,i.right,e,g,t,n)}f=f.rightVertex.rightEdge}while(f&&f!==u);return n}_processCandidateProposal(e,r,h,u,f,m){const{spatialReference:E,pointer:S}=f,P=i.create();!function(e,i,o,s,r,a){(function(e,i,o,s,{spatialReference:r},a){const c=d.radiansGeographicBetweenVec(i,o,r,r);if(null==c)return!1;const l=d.radiansGeographicBetweenVec(o,s,r,r);if(null==l)return!1;const g=a.geodesicDistance(o,s,r);if(null==g)return!1;const p=Math.abs(t.cyclicalPI.shortestSignedDiff(c,l))>Math.PI/2?t.cyclical2PI.normalize(c+Math.PI):c;return d.pointFromDistanceAlongAzimuth(e,o,r,n.valueInUnit(g,"meters"),n.createAngle(p,"radians","geographic"),"geodesic"),e[2]=s[2],!0})(e,i,o,s,r,a)||function(e,t,n,i){g.projectPointToLineLike(t,{start:n,end:i,type:p.LineType.LINE},e),e[2]=t[2]}(e,s,i,o)}(P,e,r,h,f,this._geodesicLengthMeasurementUtils);const v=s.markAsTarget(s.fromVec3(P));a.squaredScreenDistance(u,l.vectorToScreenPoint(v,E,o.absoluteHeightElevationInfo,this.view))<this.squaredProximityThreshold(S)&&m.push(new c.LineSnappingCandidate({lineStart:e,lineEnd:r,targetPoint:v,isDraped:"on-the-ground"===f.elevationInfo?.mode}))}}e.LineSnapper=h,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));