// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Cyclical","../../../core/quantityUtils","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../support/elevationInfoUtils","../sketch/constraints","../sketch/normalizedPoint","./SnappingAlgorithm","./snappingUtils","./candidates/RightAngleSnappingCandidate","../support/viewUtils","../../support/angularMeasurementUtils"],(function(e,t,n,i,r,a,s,o,c,g,l,p,h,d,f){"use strict";class u extends l.SnappingAlgorithm{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],i=[];if(n.vertices.length<2)return i;const{view:r}=this,a=d.vectorToScreenPoint(e,t.spatialReference,o.absoluteHeightElevationInfo,r),s=n.vertices.at(-1);this._checkForSnappingCandidate(h.SelfSnappingRightAngleType.LastVertex,i,s.leftEdge,s,s.leftEdge.leftVertex,e,a,t);const c=n.vertices[0];return this._checkForSnappingCandidate(h.SelfSnappingRightAngleType.FirstVertex,i,c.rightEdge,c,c.rightEdge.rightVertex,e,a,t),i}snapExistingVertex(e,t){const n=[],i=t.vertexHandle;if(i.component.vertices.length<3)return n;const{view:r}=this,a=d.vectorToScreenPoint(e,t.spatialReference,o.absoluteHeightElevationInfo,r),s=i.leftEdge,c=i.rightEdge;if(s?.leftVertex.leftEdge){const i=s.leftVertex.leftEdge;this._checkForSnappingCandidate(h.SelfSnappingRightAngleType.ExistingEdge,n,i,i.rightVertex,i.leftVertex,e,a,t)}if(c?.rightVertex.rightEdge){const i=c.rightVertex.rightEdge;this._checkForSnappingCandidate(h.SelfSnappingRightAngleType.ExistingEdge,n,i,i.leftVertex,i.rightVertex,e,a,t)}return n}_checkForSnappingCandidate(e,r,o,c,l,p,h,d){if(!this.edgeExceedsShortLineThreshold(o,d))return;const u=this.view,S=g.fromAnyMapPoint(c.pos,u,d),v=g.fromAnyMapPoint(l.pos,u,d);!function(e,r,o,c,l,p){(function(e,i,r,o,{spatialReference:c},g){const l=f.radiansGeographicBetweenVec(i,r,c,c);if(null==l)return!1;const p=f.radiansGeographicBetweenVec(r,o,c,c);if(null==p)return!1;const h=Math.sign(t.cyclical2PI.shortestSignedDiff(l,p))*Math.PI*.5,d=n.createAngle(l+h,"radians","geographic"),u=s.create(),V=g.geodesicDistance(r,o,c);return null!=V&&(f.pointFromDistanceAlongAzimuth(u,r,c,n.valueInUnit(V,"meters"),d,"geodesic"),a.subtract(e,u,r),!0)})(e,r,o,c,l,p)||function(e,t,n){const r=i.subtract(V,g.asVec2(n),g.asVec2(t));a.set(e,r[1],-r[0],0)}(e,r,o)}(x,v,S,p,d,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,r,v,S,x,p,h,d)}_checkForSnappingCandidateAlongProjectedRay(e,t,n,r,l,f,u,x){const{spatialReference:S,pointer:v}=x,m=i.subtract(V,g.asVec2(f),g.asVec2(r)),A=i.dot(l,m)/i.squaredLength(l),E=i.scaleAndAdd(V,g.asVec2(r),l,A),y=g.markAsTarget(g.fromValues(E[0],E[1],f[2]));if(p.squaredScreenDistance(u,d.vectorToScreenPoint(y,S,o.absoluteHeightElevationInfo,this.view))>this.squaredProximityThreshold(v)||this.isVertical(y,r,x)||this.isVertical(r,n,x))return;const T=a.scaleAndAdd(s.create(),r,l,Math.sign(A));t.push(new h.RightAngleSnappingCandidate({targetPoint:y,constraint:new c.VerticalHalfPlaneConstraint(r,g.fromVec3(T)),previousVertex:n,otherVertex:r,otherVertexType:h.OtherVertexType.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===x.elevationInfo?.mode}))}}const V=r.create(),x=s.create();e.RightAngleSnapper=u,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));