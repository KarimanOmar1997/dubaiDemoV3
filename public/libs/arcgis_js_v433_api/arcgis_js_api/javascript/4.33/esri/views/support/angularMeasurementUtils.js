// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../core/Cyclical","../../core/quantityUtils","../../core/unitUtils","../../core/libs/gl-matrix-2/math/vec2","../../core/libs/gl-matrix-2/factories/vec2f64","../../chunks/vec32","../../core/libs/gl-matrix-2/factories/vec3f64","../../geometry/projection/projectVectorToVector","../../geometry/support/geodesicUtils","../../geometry/support/spatialReferenceUtils"],(function(e,t,r,o,i,n,c,a,l,s,u){"use strict";var g;function d(e,t){if(null==e||null==t)return;const o=p(e,t);return null!=o?r.createAngle(o,"radians","geographic"):void 0}e.DirectionMode=void 0,(g=e.DirectionMode||(e.DirectionMode={})).Absolute="absolute",g.Relative="relative",g.RelativeBilateral="relative-bilateral";const p=(()=>{const e=a.create(),t=a.create();return(r,o)=>(c.set(e,r.x,r.y,r.z??0),c.set(t,o.x,o.y,o.z??0),v(e,t,r.spatialReference,o.spatialReference))})(),v=(()=>{const e=n.create(),t=a.create(),r=a.create();return(a,g,d,p)=>{if(c.exactEquals(a,g))return;const v=s.geodesicCompatibleSpatialReference(d),f=s.geodesicCompatibleSpatialReference(p);if(v&&f&&u.equals(v,f)&&l.projectVectorToVector(a,d,t,v)&&l.projectVectorToVector(g,p,r,f)){const{azimuth:e}=s.inverseGeodeticSolver(M,t,r,v);return null!=e?o.convertUnit(e,"degrees","radians"):void 0}e[0]=g[0]-a[0],e[1]=g[1]-a[1];let h=i.angle(n.UNIT_Y,e);return e[0]<0&&(h=b-h),h}})();function f(e,t,o){if(!e||!t||!o)return;const i=p(e,t),n=p(t,o);return null!=i&&null!=n?r.createAngle(n-i,"radians","geographic"):void 0}function h(t,o){if(null!=t)switch(o){case e.DirectionMode.Absolute:return m(t);case e.DirectionMode.Relative:{const e=R(t);let o=T.normalize(e,0,!0);return-180===o&&(o=180),r.createAngle(o,"degrees","geographic")}case e.DirectionMode.RelativeBilateral:{const e=R(t),o=Math.abs(T.normalize(e,0,!0));return r.createAngle(o,"degrees","geographic")}}}function m(e){const t=R(e),o=A.normalize(t,0,!0);return r.createAngle(o,"degrees","geographic")}const y=(()=>{const e=a.create();return(t,i,n,a,u,g="geodesic")=>{c.copy(e,i);const d=R(u);if("geodesic"===g){const r=s.geodesicCompatibleSpatialReference(n);if(r&&l.projectVectorToVector(e,n,e,r))return s.directGeodeticSolver(t,e,d,a,r),t[2]=i[2],!!l.projectVectorToVector(t,r,t,n)}const p=r.convertRotationType(d,"geographic","arithmetic"),v=o.convertUnit(p,"degrees","radians"),f=i[0]+a*Math.cos(v),h=i[1]+a*Math.sin(v),m=i[2];return c.set(t,f,h,m),!0}})();function R(e){if(null!=e)return r.convertRotationType(D(e),e.rotationType,"geographic")}function D(e){return o.convertUnit(e.value,e.unit,"degrees")}const M=new s.InverseGeodeticSolverResult,b=2*Math.PI,A=t.cyclicalDegrees,T=new t.Cyclical(-180,180);e.convertAngle=function(e,t,i){let n=o.convertUnit(e.value,e.unit,"degrees");return n=r.convertRotationType(n,e.rotationType,i),n=o.convertUnit(n,"degrees",t),r.createAngle(n,t,i)},e.directionBetweenPoints=d,e.directionForVertices=function(t,r,o,i=e.DirectionMode.Absolute){if(r&&o)switch(i){case e.DirectionMode.Absolute:return d(r,o);case e.DirectionMode.Relative:return h(f(t,r,o),e.DirectionMode.Relative);case e.DirectionMode.RelativeBilateral:return h(f(t,r,o),e.DirectionMode.RelativeBilateral)}},e.getDegreesArithmetic=function(e){if(null!=e)return r.convertRotationType(D(e),e.rotationType,"arithmetic")},e.getDegreesGeographic=R,e.getNormalizedDirection=h,e.getNormalizedGeographicOrientation=m,e.pointFromDistanceAlongAzimuth=y,e.radiansGeographicBetweenVec=v,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));