// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../core/mathUtils","../../core/libs/gl-matrix-2/math/vec2","../../core/libs/gl-matrix-2/factories/vec2f64","../../chunks/vec32","../../core/libs/gl-matrix-2/factories/vec3f64","../../core/libs/gl-matrix-2/math/common","../../geometry/support/plane","../3d/support/mathUtils","./geometry2dUtils"],(function(e,t,n,r,s,c,i,a,o,l){"use strict";function u(e,{start:t,end:n,type:r},i=c.create()){const a=s.sub(V,e,t),o=s.sub(m,n,t),u=s.dot(a,o)/s.dot(o,o);return s.scaleAndAdd(i,t,o,r===l.LineType.RAY?Math.max(u,0):u)}function d({start:e,end:t,type:n},r){const c=s.sub(V,r,e),a=s.sub(m,t,e);if(n===l.LineType.RAY&&s.dot(a,c)<-i.getEpsilon())return s.distance(e,r);const o=s.cross(g,a,c);return s.len(o)/s.len(a)}const p=(()=>{const e=c.create(),t=c.create(),i=c.create();return({start:u,end:d},{center:p,radius:L,normal:f,slicePlane:A})=>{const b=a.fromPositionAndNormal(p,f,M);if(y(a.distance(b,u),0)&&y(a.distance(b,d),0)){o.tangentFrame(f,e,t);const a=(r,c)=>(s.subtract(i,c,p),n.set(r,s.dot(i,e),s.dot(i,t)),r),y=l.intersectLineLikeAndCircle({start:a(h,u),end:a(E,d),type:l.LineType.LINE},r.ZEROS,L),b=[];for(const[n,r]of y){const i=s.copy(c.create(),p);s.scaleAndAdd(i,i,e,n),s.scaleAndAdd(i,i,t,r),A&&!P(A,i)||b.push(i)}return b}const T=c.create();return a.intersectLine(b,u,d,T)?!y(s.distance(T,p),L)||A&&!P(A,T)?[]:[T]:[]}})();function L(e,t){const n=e.start,r=e.end,a=t.start,o=t.end,u=s.sub(V,r,n),d=s.sub(m,o,a),p=s.sub(g,a,n),L=s.cross(N,u,d);if(!y(s.dot(p,L),0))return[];const f=s.sqrLen(L);if(y(f,0))return[];const A=s.cross(q,p,d),P=s.dot(A,L)/f,b=s.scaleAndAdd(I,n,u,P);if(e.type===l.LineType.RAY){const e=s.sub(C,b,n);if(s.dot(u,e)<-i.getEpsilon())return[]}if(t.type===l.LineType.RAY){const e=s.sub(C,b,a);if(s.dot(d,e)<-i.getEpsilon())return[]}return[c.clone(b)]}function f({start:e,end:t,type:n},r){const a=s.sub(V,r,e),o=s.sub(m,t,e),u=s.cross(g,o,a),d=s.sqrLen(u)/s.sqrLen(o),p=i.getEpsilon();if(d<p)switch(n){case l.LineType.LINE:return[c.clone(r)];case l.LineType.RAY:return s.dot(o,a)<-p?[]:[c.clone(r)]}return[]}function A(e,t,{start:n,end:r,type:c}){return s.set(e.start,n[0],n[1],t),s.set(e.end,r[0],r[1],t),e.type=T[c],e}function y(e,n){return t.floatEqualAbsolute(Math.abs(e-n),0,i.getEpsilon())}function P(e,t){return a.isPointInside(e,t)}var b;e.VerticalPlaneType=void 0,(b=e.VerticalPlaneType||(e.VerticalPlaneType={}))[b.PLANE=0]="PLANE",b[b.HALF_PLANE=1]="HALF_PLANE";const T={[e.VerticalPlaneType.PLANE]:l.LineType.LINE,[e.VerticalPlaneType.HALF_PLANE]:l.LineType.RAY},h=r.create(),E=r.create(),V=c.create(),m=c.create(),g=c.create(),N=c.create(),q=c.create(),I=c.create(),C=c.create(),M=a.create(),v={start:c.create(),end:c.create(),type:l.LineType.LINE},k={start:c.create(),end:c.create(),type:l.LineType.LINE};Object.defineProperty(e,"LineType",{enumerable:!0,get:()=>l.LineType}),e.intersectLineAndPoint=f,e.intersectLineLikeAndCircle=p,e.intersectLineLikeAndVerticalCylinder=function({start:e,end:t,type:r},i,a){const o=[],u=s.subtract(V,t,e),d=n.subtract(E,e,i),p=n.squaredLength(u),L=2*n.dot(u,d),f=L*L-4*p*(n.squaredLength(d)-a*a);if(0===f){const t=-L/(2*p);(r===l.LineType.LINE||t>=0)&&o.push(s.scaleAndAdd(c.create(),e,u,t))}else if(f>0){const t=Math.sqrt(f),n=(-L+t)/(2*p);(r===l.LineType.LINE||n>=0)&&o.push(s.scaleAndAdd(c.create(),e,u,n));const i=(-L-t)/(2*p);(r===l.LineType.LINE||i>=0)&&o.push(s.scaleAndAdd(c.create(),e,u,i))}return o},e.intersectLineLikes=L,e.intersectVerticalCylinderAndPoint=function(e,t,r){return y(n.squaredDistance(r,e),t*t)?[c.clone(r)]:[]},e.intersectVerticalCylinders=function(e,t,s,c){const[i,a]=e,[o,l]=s,u=o-i,d=l-a,p=u*u+d*d,L=Math.sqrt(p);if(L>t+c)return[];if(L<Math.abs(t-c))return[];if(y(L,0)&&y(t,c))return[];const f=(t*t-c*c+p)/(2*L),A=Math.sqrt(t*t-f*f),P=A*d/L,b=A*u/L,[T,E]=n.lerp(h,e,s,f/L);return y(P,b)?[r.fromValues(T,E)]:[r.fromValues(T+P,E-b),r.fromValues(T-P,E+b)]},e.intersectVerticalPlaneAndLineLike=function(t,r){const a=t.start,o=t.end,u=n.subtract(h,o,a),d=s.set(m,-u[1],u[0],0),p=r.start,L=r.end,f=s.sub(g,L,p),A=s.dot(f,d),y=s.set(N,a[0],a[1],0),P=s.sub(q,y,p),b=s.dot(P,d),T=i.getEpsilon();if(Math.abs(A)<T)return Math.abs(b),[];const V=b/A,M=s.scaleAndAdd(I,p,f,V);if(r.type===l.LineType.RAY){const e=s.sub(C,M,p);if(s.dot(e,f)<-T)return[]}if(t.type===e.VerticalPlaneType.HALF_PLANE){const e=n.sub(E,M,a);if(n.dot(e,u)<-T)return[]}return[c.clone(M)]},e.intersectVerticalPlaneAndPoint=function(e,t){return f(A(v,t[2],e),t)},e.intersectVerticalPlaneAndVerticalCylinder=function({start:t,end:s,type:c},i,a){const o=[],l=n.subtract(h,s,t),u=n.subtract(E,t,i),d=n.squaredLength(l),p=2*n.dot(l,u),L=p*p-4*d*(n.squaredLength(u)-a*a);if(0===L){const s=-p/(2*d);(c===e.VerticalPlaneType.PLANE||s>=0)&&o.push(n.scaleAndAdd(r.create(),t,l,s))}else if(L>0){const s=Math.sqrt(L),i=(-p+s)/(2*d);(c===e.VerticalPlaneType.PLANE||i>=0)&&o.push(n.scaleAndAdd(r.create(),t,l,i));const a=(-p-s)/(2*d);(c===e.VerticalPlaneType.PLANE||a>=0)&&o.push(n.scaleAndAdd(r.create(),t,l,a))}return o},e.intersectVerticalPlanes=function(e,t){return L(A(v,0,e),A(k,0,t)).map((([e,t])=>r.fromValues(e,t)))},e.isClose=y,e.isPointInsidePlane=P,e.pointToLineLikeDistance=d,e.pointToVerticalCylinderDistance=function(e,t,r){return n.distance(e,t)-r},e.pointToVerticalPlaneDistance=function(e,t){return d(A(v,e[2],t),e)},e.pointsInsidePlane=function(e,t){return t.filter((t=>P(e,t)))},e.projectPointToLineLike=u,e.projectPointToVerticalCylinder=function(e,t,r,s=c.create()){const i=n.subtract(h,e,t),a=n.length(i),o=0===a?1:r/a;return n.scaleAndAdd(s,t,i,o),s[2]=e[2],s},e.projectPointToVerticalPlane=function(e,t,n){return u(e,A(v,e[2],t),n)},e.vectorsHaveCloseZ=function(e,t){return y(e[2],t[2])},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));