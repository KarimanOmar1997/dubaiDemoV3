// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.33/esri/copyright.txt for details.
//>>built
define(["exports","../../core/Error","../../core/has","../../core/Logger","../../core/maybe","../../core/promiseUtils","./checkWebGLError","./enums","./FBOAttachmentType","./TextureDescriptor","./textureUtils","./ValidatedTextureDescriptor"],(function(e,t,i,r,s,a,o,n,p,l,m,d){"use strict";const h=()=>r.getLogger("esri/views/webgl/Texture");let c=class e{static{this.TEXTURE_UNIT_FOR_UPDATES=0}static{this.compressionWorkerHandle=null}constructor(e,i=null,r=null){if(this.type=p.FBOAttachmentType.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._shadowFilterDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=i;else{const r=d.ValidatedTextureDescriptor.validate(e,i);if(!r)throw new t("texture:invalid-descriptor","Texture descriptor invalid");this._descriptor=r}this._descriptor.target===n.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return l.estimateMemory(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty||this._shadowFilterDirty}get hasWebGLTextureObject(){return!!this._glName}dispose(){this.abortCompression(),this._descriptor.context.gl&&this.hasWebGLTextureObject&&(this._descriptor.context.instanceCounter.decrement(n.ResourceType.Texture,this),this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,i){const r=this._descriptor;if(r.width!==e||r.height!==i){if(this._wasImmutablyAllocated)throw new t("texture:immutable-resize","Immutable textures can't be resized!");r.width=e,r.height=i,this._descriptor.target===n.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.compress=e}disableCompression(){this._descriptor.compress=void 0}setData(e){this.abortCompression(),!m.isCompressedData(e)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in n.CompressedTextureFormat&&(this._descriptor.internalFormat=void 0),this._setData(e),!m.isCompressedData(e)&&this._descriptor.compress&&this._compressOnWorker(e)}updateData(i,r,s,a,o,n,p=0){n||h().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||h().error("An attempt to update uninitialized texture!");const l=this._descriptor;l.internalFormat=m.deriveInternalFormat(l);const{context:d,pixelFormat:c,dataType:_,target:u,isImmutable:T}=l;if(T&&!this._wasImmutablyAllocated)throw new t("texture:uninitialized","Cannot update immutable texture before allocation!");const g=d.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||r+a>l.width||s+o>l.height)&&h().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:x}=d;p&&(a&&o||h().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),x.pixelStorei(x.UNPACK_SKIP_ROWS,p)),m.isTexImageSource(n)?x.texSubImage2D(u,i,r,s,a,o,c,_,n):m.isCompressedData(n)?x.compressedTexSubImage2D(u,i,r,s,a,o,l.internalFormat,n.levels[i]):x.texSubImage2D(u,i,r,s,a,o,c,_,n),p&&x.pixelStorei(x.UNPACK_SKIP_ROWS,0),d.bindTexture(g,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(i,r,s,a,o,n,p,l){l||h().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||h().error("An attempt to update an uninitialized texture!");const d=this._descriptor;d.internalFormat=m.deriveInternalFormat(d);const{context:c,pixelFormat:_,dataType:u,isImmutable:T,target:g}=d;if(T&&!this._wasImmutablyAllocated)throw new t("texture:uninitialized","Cannot update immutable texture before allocation!");m.is3DTarget(g)||h().warn("Attempting to set 3D texture data on a non-3D texture");const x=c.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);c.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||a<0||r+o>d.width||s+n>d.height||a+p>d.depth)&&h().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:E}=c;if(m.isCompressedData(l))l=l.levels[i],E.compressedTexSubImage3D(g,i,r,s,a,o,n,p,d.internalFormat,l);else{const e=l;E.texSubImage3D(g,i,r,s,a,o,n,p,_,u,e)}c.bindTexture(x,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const i=this._descriptor;if(0===i.width||0===i.height)return;if(!i.hasMipmap){if(this._wasImmutablyAllocated)throw new t("texture:immutable-change","Cannot add mipmaps to immutable texture after allocation");i.hasMipmap=!0,this._samplingModeDirty=!0,m.validateTexture(i)}i.samplingMode===n.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,i.samplingMode=n.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):i.samplingMode===n.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,i.samplingMode=n.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(i.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new t("texture:immutable-change","Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,m.validateTexture(e)}e.samplingMode===n.TextureSamplingMode.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=n.TextureSamplingMode.LINEAR):e.samplingMode===n.TextureSamplingMode.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=n.TextureSamplingMode.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,m.validateTexture(this._descriptor),this._wrapModeDirty=!0)}setShadowFiltering(e){e!==this._descriptor.linearFilterDepth&&(this._descriptor.linearFilterDepth=this._descriptor.compareEnabled=e,this.setSamplingMode(e?n.TextureSamplingMode.LINEAR:n.TextureSamplingMode.NEAREST),m.validateTexture(this._descriptor),this._shadowFilterDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1),this._shadowFilterDirty&&(this._applyShadowMode(),this._shadowFilterDirty=!1)}abortCompression(){this._compressionAbortController=s.abortMaybe(this._compressionAbortController)}_setData(i,r){const s=this._descriptor,a=s.context?.gl;if(!a)return;o.checkWebGLError(a),this.hasWebGLTextureObject||(this._glName=a.createTexture(),s.context.instanceCounter.increment(n.ResourceType.Texture,this)),m.validateTexture(s);const p=s.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);s.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),o.checkWebGLError(a);const l=r??s.target,d=m.is3DTarget(l);if(m.isTexImageSource(i))this._setDataFromTexImageSource(i,l);else{const{width:e,height:r,depth:n}=s;if(null==e||null==r)throw new t("texture:missing-size","Width and height must be specified!");if(d&&null==n)throw new t("texture:missing-depth","Depth must be specified!");if(s.internalFormat=m.deriveInternalFormat(s),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(l,s.internalFormat,s.hasMipmap,e,r,n),m.isCompressedData(i)){if(!m.isCompressedFormat(s.internalFormat))throw new t("texture:format-mismatch","Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(i,s.internalFormat,l)}else this._texImage(l,0,s.internalFormat,e,r,n,i),o.checkWebGLError(a),s.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),this._applyShadowMode(),o.checkWebGLError(a),s.context.bindTexture(p,e.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let t=n.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;t<=n.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:i,preMultiplyAlpha:r}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,i?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_setDataFromTexImageSource(e,t){const{gl:i}=this._descriptor.context,r=this._descriptor;r.internalFormat=m.deriveInternalFormat(r);const s=m.is3DTarget(t),{width:a,height:n,depth:p}=m.getDimensions(e);r.width&&r.height,r.width||(r.width=a),r.height||(r.height=n),s&&r.depth,s&&(r.depth=p),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(t,r.internalFormat,r.hasMipmap,a,n,p),this._texImage(t,0,r.internalFormat,a,n,p,e),o.checkWebGLError(i),r.hasMipmap&&(this.generateMipmap(),o.checkWebGLError(i))}_setDataFromCompressedSource(e,t,i){const r=this._descriptor,{width:s,height:a,depth:o}=r,p=e.levels,l=m.calcMipmapLevels(i,s,a,o),d=Math.min(l,p.length)-1;this._descriptor.context.gl.texParameteri(r.target,n.TextureConstants.MAX_LEVEL,d),this._forEachMipmapLevel(((e,r,s,a)=>{const o=p[Math.min(e,p.length-1)];this._compressedTexImage(i,e,t,r,s,a,o)}),d)}_texStorage(e,i,r,s,a,o){const{gl:n}=this._descriptor.context;if(!m.isSizedPixelFormat(i)&&!m.isSizedDepthFormat(i)&&!m.isSizedDepthStencilFormat(i))throw new t("texture:missing-format","Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const p=r?m.calcMipmapLevels(e,s,a,o):1;if(m.is3DTarget(e)){if(null==o)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");n.texStorage3D(e,p,i,s,a,o)}else n.texStorage2D(e,p,i,s,a);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,a,o,n){const p=this._descriptor.context.gl,l=m.is3DTarget(e),{isImmutable:d,pixelFormat:h,dataType:c}=this._descriptor;if(d){if(null!=n){const r=n;if(l){if(null==o)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.texSubImage3D(e,i,0,0,0,s,a,o,h,c,r)}else p.texSubImage2D(e,i,0,0,s,a,h,c,r)}}else{const m=n;if(l){if(null==o)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.texImage3D(e,i,r,s,a,o,0,h,c,m)}else p.texImage2D(e,i,r,s,a,0,h,c,m)}}_compressedTexImage(e,i,r,s,a,o,n){const p=this._descriptor.context.gl,l=m.is3DTarget(e);if(this._descriptor.isImmutable){if(null!=n)if(l){if(null==o)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.compressedTexSubImage3D(e,i,0,0,0,s,a,o,r,n)}else p.compressedTexSubImage2D(e,i,0,0,s,a,r,n)}else if(l){if(null==o)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.compressedTexImage3D(e,i,r,s,a,o,0,n)}else p.compressedTexImage2D(e,i,r,s,a,0,n)}async _compressOnWorker(t){const{width:i,height:r,context:s,flipped:o,preMultiplyAlpha:p,hasMipmap:l}=this._descriptor,m=this._descriptor.compress?.compressionTracker,d=this._descriptor.compress?.compressionCallback,{compressedTextureETC:c,compressedTextureS3TC:_}=s.capabilities;if(!e.compressionWorkerHandle?.isCompressible(t,this._descriptor)||!c&&!_)return;this.abortCompression();const u=new AbortController;this._compressionAbortController=u,m?.increment();try{let s;t instanceof Uint8Array?s=t.buffer:(s=await createImageBitmap(t,{imageOrientation:o?"flipY":"none"}),a.throwIfAborted(u));const m={data:s,width:i,height:r,needsFlip:t instanceof Uint8Array&&this.descriptor.flipped,components:this._descriptor.pixelFormat===n.PixelFormat.RGBA?4:3,preMultiplyAlpha:p,hasMipmap:l,hasETC:!!c,hasS3TC:!!_},h=await e.compressionWorkerHandle.invoke(m,u.signal,"low");if(a.throwIfAborted(u),h.compressedTexture&&this.hasWebGLTextureObject){const e=this.usedMemory;this._descriptor.internalFormat=h.internalFormat,this._setData(h.compressedTexture),d?.(e-this.usedMemory)}}catch(e){a.isAbortError(e)||h().error("Texture compression failed!")}finally{m?.decrement(),this._compressionAbortController?.signal.aborted&&(this._compressionAbortController=null)}}_forEachMipmapLevel(e,i=1/0){let{width:r,height:s,depth:a,hasMipmap:o,target:p}=this._descriptor;const l=p===n.TextureType.TEXTURE_3D;if(null==r||null==s||l&&null==a)throw new t("texture:missing-size","Missing texture dimensions for mipmap calculation");for(let t=0;e(t,r,s,a),o&&(1!==r||1!==s||l&&1!==a)&&!(t>=i);++t)r=Math.max(1,r>>1),s=Math.max(1,s>>1),l&&(a=Math.max(1,a>>1))}_applySamplingMode(){const e=this._descriptor,t=e.context?.gl;let i=e.samplingMode,r=e.samplingMode;i===n.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||i===n.TextureSamplingMode.LINEAR_MIPMAP_LINEAR?(i=n.TextureSamplingMode.LINEAR,e.hasMipmap||(r=n.TextureSamplingMode.LINEAR)):i!==n.TextureSamplingMode.NEAREST_MIPMAP_NEAREST&&i!==n.TextureSamplingMode.NEAREST_MIPMAP_LINEAR||(i=n.TextureSamplingMode.NEAREST,e.hasMipmap||(r=n.TextureSamplingMode.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,i),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,r)}_applyWrapMode(){const e=this._descriptor,t=e.context?.gl;"number"==typeof e.wrapMode?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}_applyShadowMode(){const e=this._descriptor,t=e.context?.gl,i=e.compareEnabled?t.COMPARE_REF_TO_TEXTURE:t.NONE;t.texParameteri(e.target,t.TEXTURE_COMPARE_MODE,i),e.compareEnabled&&t.texParameteri(e.target,t.TEXTURE_COMPARE_FUNC,t.GREATER),o.checkWebGLError(t)}_applyAnisotropicFilteringParameters(){const e=this._descriptor,t=e.context.capabilities.textureFilterAnisotropic;t&&e.context.gl.texParameterf(e.target,t.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}};e.Texture=c,e.tracer=null,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));